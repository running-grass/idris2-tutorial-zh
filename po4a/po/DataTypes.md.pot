# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-05-15 04:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: ../src/Tutorial/DataTypes.md:1
#, no-wrap
msgid "Algebraic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:8
#, no-wrap
msgid ""
"In the [previous chapter](Functions1.md),\n"
"we learned how to write our own functions and combine\n"
"them to create more complex functionality. Of equal importance\n"
"is the ability to define our own data types and use them\n"
"as arguments and results in functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:15
#, no-wrap
msgid ""
"This is a lengthy chapter, densely packed with information.\n"
"If you are new to Idris and functional programming, make\n"
"sure to follow along slowly, experimenting with the examples,\n"
"and possibly coming up with your own. Make sure to try\n"
"and solve *all* exercises. The solutions to the exercises\n"
"can be found [here](../Solutions/DataTypes.idr).\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:16
#, no-wrap
msgid "module Tutorial.DataTypes\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:20
#, no-wrap
msgid "Enumerations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:24
#, no-wrap
msgid ""
"Let's start with a data type for the days of the week as an\n"
"example.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:25
#, no-wrap
msgid ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:38
#, no-wrap
msgid ""
"The declaration above defines a new *type* (`Weekday`) and\n"
"several new *values* (`Monday` to `Sunday`) of the given\n"
"type. Go ahead, and verify this at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:39
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:48
#, no-wrap
msgid ""
"So, `Monday` is of type `Weekday`, while `Weekday` itself is of\n"
"type `Type`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:52
#, no-wrap
msgid ""
"It is important to note that a value of type `Weekday` can only\n"
"ever be one of the values listed above. It is a *type error* to\n"
"use anything else where a `Weekday` is expected.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/DataTypes.md:53 ../src/Appendices/QTT.md:318
#, no-wrap
msgid "Pattern Matching"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:59
#, no-wrap
msgid ""
"In order to use our new data type as a function argument, we\n"
"need to learn about an important concept in functional programming\n"
"languages: Pattern matching. Let's implement a function which calculates\n"
"the successor of a weekday:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:60
#, no-wrap
msgid ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:81
#, no-wrap
msgid ""
"In order to inspect a `Weekday` argument, we match on the\n"
"different possible values and return a result for each of them.\n"
"This is a very powerful concept, as it allows us to match\n"
"on and extract values from deeply nested data structures.\n"
"The different cases in a pattern match are inspected from\n"
"top to bottom, each being compared against the current\n"
"function argument. Once a matching pattern is found, the\n"
"computation on the right hand side of this pattern is\n"
"evaluated. Later patterns are then ignored.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:89
#, no-wrap
msgid ""
"For instance, if we invoke `next` with argument `Thursday`,\n"
"the first three patterns (`Monday`, `Tuesday`, and `Wednesday`)\n"
"will be checked against the argument, but they do not match.\n"
"The fourth pattern is a match, and result `Friday` is being\n"
"returned. Later patterns are then ignored, even if they would\n"
"also match the input (this becomes relevant with catch-all patterns,\n"
"which we will talk about in a moment).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:98
#, no-wrap
msgid ""
"The function above is provably total. Idris knows about the\n"
"possible values of type `Weekday`, and can therefore figure\n"
"out that our pattern match covers all possible cases. We can\n"
"therefore annotate the function with the `total` keyword, and\n"
"Idris will answer with a type error if it can't verify the\n"
"function's totality. (Go ahead, and try removing one of\n"
"the clauses in `next` to get an idea about how an error\n"
"message from the coverage checker looks like.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:105
#, no-wrap
msgid ""
"Please remember that these are very strong guarantees from\n"
"the type checker: Given enough resources,\n"
"a provably total function will *always* return\n"
"a result of the given type in a finite amount of time\n"
"(*resources* here meaning computational resources like\n"
"memory or, in case of recursive functions, stack space).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:106
#, no-wrap
msgid "Catch-all Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:111
#, no-wrap
msgid ""
"Sometimes, it is convenient to only match on a subset\n"
"of the possible values and collect the remaining possibilities\n"
"in a catch-all clause:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:112
#, no-wrap
msgid ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:125
#, no-wrap
msgid ""
"The final line with the catch-all pattern is only invoked\n"
"if the argument is not equal to `Saturday` or `Sunday`.\n"
"Remember: Patterns in a pattern match are matched against\n"
"the input from top to bottom, and the first match decides\n"
"which path on the right hand side will be taken.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:129
#, no-wrap
msgid ""
"We can use catch-all patterns to implement an equality test for\n"
"`Weekday` (we will not yet use the `==` operator for this; this will\n"
"have to wait until we learn about *interfaces*):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:130
#, no-wrap
msgid ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:143
#, no-wrap
msgid "Enumeration Types in the Prelude"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:151
#, no-wrap
msgid ""
"Data types like `Weekday` consisting of a finite set\n"
"of values are sometimes called *enumerations*. The Idris\n"
"*Prelude* defines some common enumerations for us: for\n"
"instance, `Bool` and `Ordering`. As with `Weekday`,\n"
"we can use pattern matching when implementing functions\n"
"on these types:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:152
#, no-wrap
msgid ""
"-- this is how `not` is implemented in the *Prelude*\n"
"total\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:162
#, no-wrap
msgid ""
"The `Ordering` data type describes an ordering relation\n"
"between two values. For instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:163
#, no-wrap
msgid ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:176
#, no-wrap
msgid ""
"Here, `LT` means that the first argument is *less than*\n"
"the second, `EQ` means that the two arguments are *equal*\n"
"and `GT` means, that the first argument is *greater than*\n"
"the second.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:177
#, no-wrap
msgid "Case Expressions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:183
#, no-wrap
msgid ""
"Sometimes we need to perform a computation with one\n"
"of the arguments and want to pattern match on the result\n"
"of this computation. We can use *case expressions* in this\n"
"situation:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:184
#, no-wrap
msgid ""
"-- returns the larger of the two arguments\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:202
#, no-wrap
msgid ""
"The first line of the case expression (`case compare x y of`)\n"
"will invoke function `compare` with arguments `x` and `y`. On\n"
"the following (indented) lines, we pattern match on the result\n"
"of this computation. This is of type `Ordering`, so we expect\n"
"one of the three constructors `LT`, `EQ`, or `GT` as the result.\n"
"On the first line, we handle the `LT` case explicitly, while\n"
"the other two cases are handled with an underscore as a catch-all\n"
"pattern.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:206
#, no-wrap
msgid ""
"Note that indentation matters here: The case block as a whole\n"
"must be indented (if it starts on a new line), and the different\n"
"cases must also be indented by the same amount of whitespace.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:209
#, no-wrap
msgid ""
"Function `compare` is overloaded for many data types. We will\n"
"learn how this works when we talk about interfaces.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/DataTypes.md:210
#, no-wrap
msgid "If Then Else"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:214
#, no-wrap
msgid ""
"When working with `Bool`, there is an alternative to pattern matching\n"
"common to most programming languages:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:215
#, no-wrap
msgid ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:225
#, no-wrap
msgid ""
"Note that the `if then else` expression always returns a value\n"
"and, therefore, the `else` branch cannot be dropped. This is different\n"
"from the behavior in typical imperative languages, where `if` is\n"
"a statement with possible side effects.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:226
#, no-wrap
msgid "Naming Conventions: Identifiers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:233
#, no-wrap
msgid ""
"While we are free to use lower-case and upper-case identifiers for\n"
"function names, type- and data constructors must be given upper-case\n"
"identifiers in order not to confuse Idris (operators are also fine).\n"
"For instance, the following data definition is not valid, and Idris\n"
"will complain that it expected upper-case identifiers:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:234
#, no-wrap
msgid "data foo = bar | baz\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:240
#, no-wrap
msgid ""
"The same goes for similar data definitions like records and sum types\n"
"(both will be explained below):\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:241
#, no-wrap
msgid ""
"-- not valid Idris\n"
"record Foo where\n"
"  constructor mkfoo\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:252
#, no-wrap
msgid ""
"On the other hand, we typically use lower-case identifiers for function\n"
"names, unless we plan to use them mostly during type checking (more on this\n"
"later). This is not enforced by Idris, however, so if you are working in\n"
"a domain where upper-case identifiers are preferable, feel free to use\n"
"those:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:253
#, no-wrap
msgid ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:267
#, no-wrap
msgid ""
"Use pattern matching to implement your own\n"
"versions of boolean operators\n"
"`(&&)` and `(||)` calling them `and` and `or`\n"
"respectively.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:274
#, no-wrap
msgid ""
"   Note: One way to go about this is to enumerate\n"
"   all four possible combinations of two boolean\n"
"   values and give the result for each. However, there\n"
"   is a shorter, more clever way,\n"
"   requiring only two pattern matches for each of the\n"
"   two functions.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:282
#, no-wrap
msgid ""
"Define your own data type representing different\n"
"units of time (seconds, minutes,\n"
"hours, days, weeks), and implement the following\n"
"functions for converting between time spans using\n"
"different units. Hint: Use integer division (`div`)\n"
"when going from seconds to some larger unit like\n"
"hours).\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:283
#, no-wrap
msgid ""
"   data UnitOfTime = Second -- add additional values\n"
"\n"
"   -- calculate the number of seconds from a\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- Given a number of seconds, calculate the\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- convert the number of steps in a given unit of time\n"
"   -- to the number of steps in another unit of time.\n"
"   -- use `fromSeconds` and `toSeconds` in your implementation\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:306
#, no-wrap
msgid ""
"Define a data type for representing a subset of the\n"
"chemical elements: Hydrogen (H), Carbon (C), Nitrogen (N),\n"
"Oxygen (O), and Fluorine (F).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:309
#, no-wrap
msgid ""
"   Declare and implement function `atomicMass`, which for each element\n"
"   returns its atomic mass in dalton:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:310
#, no-wrap
msgid ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:318
#, no-wrap
msgid "Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:326
#, no-wrap
msgid ""
"Assume we'd like to write some web form, where users of our\n"
"web application can decide how they like to be addressed.\n"
"We give them a choice between two common predefined\n"
"forms of address (Mr and Mrs), but also allow them to\n"
"decide on a customized form. The possible\n"
"choices can be encapsulated in an Idris data type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:327
#, no-wrap
msgid "data Title = Mr | Mrs | Other String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:336
#, no-wrap
msgid ""
"This looks almost like an enumeration type, with the exception\n"
"that there is a new thing, called a *data constructor*,\n"
"which accepts a `String` argument (actually, the values\n"
"in an enumeration are also called (nullary) data constructors).\n"
"If we inspect the types at the REPL, we learn the following:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:337
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:347
#, no-wrap
msgid ""
"So, `Other` is a *function* from `String` to `Title`. This\n"
"means, that we can pass `Other` a `String` argument and get\n"
"a `Title` as the result:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:348
#, no-wrap
msgid ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:358
#, no-wrap
msgid ""
"Again, a value of type `Title` can only consist of one\n"
"of the three choices listed above, and again,\n"
"we can use pattern matching to implement functions\n"
"on the `Title` data type in a provably total way:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:359
#, no-wrap
msgid ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:372
#, no-wrap
msgid ""
"Note, how in the last pattern match, the string value stored\n"
"in the `Other` data constructor is *bound* to local variable `x`.\n"
"Also, the `Other x` pattern has to be wrapped in parentheses,\n"
"as otherwise Idris would think `Other` and `x` were to\n"
"distinct function arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:377
#, no-wrap
msgid ""
"This is a very common way to extract the values from\n"
"data constructors.\n"
"We can use `showTitle` to implement a function for creating\n"
"a courteous greeting:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:378
#, no-wrap
msgid ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:387
#, no-wrap
msgid ""
"In the implementation of `greet`, we use string literals\n"
"and the string concatenation operator `(++)` to\n"
"assemble the greeting from its parts.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:389
#, no-wrap
msgid "At the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:390
#, no-wrap
msgid ""
"Tutorial.DataTypes> greet dr \"Höck\"\n"
"\"Hello, Dr. Höck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:400
#, no-wrap
msgid ""
"Data types like `Title` are called *sum types* as they consist\n"
"of the sum of their different parts: A value of type `Title`\n"
"is either a `Mr`, a `Mrs`, or a `String` wrapped up in `Other`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:407
#, no-wrap
msgid ""
"Here's another (drastically simplified) example of a sum type.\n"
"Assume we allow two forms of authentication in our web application:\n"
"Either by entering a username plus a password (for which we'll use\n"
"an unsigned 64 bit integer here), or by providing user name\n"
"plus a (very complex) secret key.\n"
"Here's a data type to encapsulate this use case:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:408
#, no-wrap
msgid "data Credentials = Password String Bits64 | Key String String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:414
#, no-wrap
msgid ""
"As an example of a very primitive login function, we can\n"
"hard-code some known credentials:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:415
#, no-wrap
msgid ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:426
#, no-wrap
msgid ""
"As can be seen in the example above, we can also pattern\n"
"match against primitive values by using integer and\n"
"string literals. Give `login` a go at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:427
#, no-wrap
msgid ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:440
#, no-wrap
msgid ""
"Implement an equality test for `Title` (you can use the\n"
"equality operator `(==)` for comparing two `String`s):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:441
#, no-wrap
msgid ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:448
#, no-wrap
msgid ""
"For `Title`, implement a simple test to check, whether\n"
"a custom title is being used:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:449
#, no-wrap
msgid ""
"   total\n"
"   isOther : Title -> Bool\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:456
#, no-wrap
msgid ""
"Given our simple `Credentials` type, there are three\n"
"ways for authentication to fail:\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, no-wrap
msgid "An unknown username was used.\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, no-wrap
msgid ""
"The password given does not match the one associated with\n"
"the username.\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, no-wrap
msgid "An invalid key was used.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:467
#, no-wrap
msgid ""
"   Encapsulate these three possibilities in a sum type\n"
"   called `LoginError`,\n"
"   but make sure not to disclose any confidential information:\n"
"   An invalid username should be stored in the corresponding\n"
"   error value, but an invalid password or key should not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:471
#, no-wrap
msgid ""
"Implement function `showError : LoginError -> String`, which\n"
"can be used to display an error message to the user who\n"
"unsuccessfully tried to login into our web application.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:472
#, no-wrap
msgid "Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:481
#, no-wrap
msgid ""
"It is often useful to group together several values\n"
"as a logical unit. For instance, in our web application\n"
"we might want to group information about a user\n"
"in a single data type. Such data types are often called\n"
"*product types* (see below for an explanation).\n"
"The most common and convenient way to\n"
"define them is the `record` construct:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:482
#, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:493
#, no-wrap
msgid ""
"The declaration above creates a new *type* called `User`,\n"
"and a new *data constructor* called `MkUser`. As usual,\n"
"have a look at their types in the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:494
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:504
#, no-wrap
msgid ""
"We can use `MkUser` (which is a function from\n"
"`String` to `Title` to `Bits8` to `User`)\n"
"to create values of type `User`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:505
#, no-wrap
msgid ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:517
#, no-wrap
msgid ""
"We can also use pattern matching to extract the fields from\n"
"a `User` value (they can again be bound to local variables):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:518
#, no-wrap
msgid ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:530
#, no-wrap
msgid ""
"In the example above, the `name` and `title` field\n"
"are bound to two new local variables (`n` and `t` respectively),\n"
"which can then be used on the right hand side of `greetUser`'s\n"
"implementation. For the `age` field, which is not used\n"
"on the right hand side, we can use an underscore as a catch-all\n"
"pattern.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:545
#, no-wrap
msgid ""
"Note, how Idris will prevent us from making\n"
"a common mistake: If we confuse the order of arguments, the\n"
"implementation will no longer type check. We can verify this\n"
"by putting the erroneous code in a `failing` block: This\n"
"is an indented code block, which will lead to an error\n"
"during elaboration (type checking). We can give part\n"
"of the expected error message as an optional string argument to\n"
"a failing block. If this does not match part of\n"
"the error message (or the whole code block does not fail\n"
"to type check) the `failing` block itself fails to type\n"
"check. This is a useful tool to demonstrate that type\n"
"safety works in two directions: We can show that valid\n"
"code type checks but also that invalid code is rejected\n"
"by the Idris elaborator:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:546
#, no-wrap
msgid ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:558
#, no-wrap
msgid ""
"In addition, for every record field, Idris creates an\n"
"extractor function of the same name. This can either\n"
"be used as a regular function, or it can be used in\n"
"postfix notation by appending it to a variable of\n"
"the record type separated by a dot. Here are two examples\n"
"for extracting the age from a user:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:559
#, no-wrap
msgid ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:567
#, no-wrap
msgid "Syntactic Sugar for Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:581
#, no-wrap
msgid ""
"As was already mentioned in the [intro](Intro.md), Idris\n"
"is a *pure* functional programming language. In pure functions,\n"
"we are not allowed to modify global mutable state. As such,\n"
"if we want to modify a record value, we will always\n"
"create a *new* value with the original value remaining\n"
"unchanged: Records and other Idris values are *immutable*.\n"
"While this *can* have a slight impact on performance, it has\n"
"the benefit that we can freely pass a record value to\n"
"different functions, without fear of the functions modifying\n"
"the value by in-place mutation. These are, again, very strong\n"
"guarantees, which makes it drastically easier to reason\n"
"about our code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:586
#, no-wrap
msgid ""
"There are several ways to modify a record, the most\n"
"general being to pattern match on the record and\n"
"adjust each field as desired. If, for instance, we'd like\n"
"to increase the age of a `User` by one, we could do the following:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:587
#, no-wrap
msgid ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:597
#, no-wrap
msgid ""
"That's a lot of code for such a simple thing, so Idris offers\n"
"several syntactic conveniences for this. For instance,\n"
"using *record* syntax, we can just access and update the `age`\n"
"field of a value:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:598
#, no-wrap
msgid ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:607
#, no-wrap
msgid ""
"Assignment operator `:=` assigns a new value to the `age` field\n"
"in `u`. Remember, that this will create a new `User` value. The original\n"
"value `u` remains unaffected by this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:613
#, no-wrap
msgid ""
"We can access a record field, either by using the field name\n"
"as a projection function (`age u`; also have a look at `:t age`\n"
"in the REPL), or by using dot syntax: `u.age`. This is special\n"
"syntax and *not* related to the dot operator for function\n"
"composition (`(.)`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:616
#, no-wrap
msgid ""
"The use case of modifying a record field is so common\n"
"that Idris provides special syntax for this as well:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:617
#, no-wrap
msgid ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:627
#, no-wrap
msgid ""
"Here, I used an *operator section* (`(+ 1)`) to make\n"
"the code more concise.\n"
"As an alternative to an operator section,\n"
"we could have used an anonymous function like so:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:628
#, no-wrap
msgid ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:637
#, no-wrap
msgid ""
"Finally, since our function's argument `u` is only used\n"
"once at the very end, we can drop it altogether,\n"
"to get the following, highly concise version:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:638
#, no-wrap
msgid ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:645
#, no-wrap
msgid "As usual, we should have a look at the result at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:646
#, no-wrap
msgid ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:653
#, no-wrap
msgid ""
"It is possible to use this syntax to set and/or update\n"
"several record fields at once:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:654
#, no-wrap
msgid ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:660
#, no-wrap
msgid "Tuples"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:666
#, no-wrap
msgid ""
"I wrote above that a record is also called a *product type*.\n"
"This is quite obvious when we consider the number\n"
"of possible values inhabiting a given type. For instance, consider\n"
"the following custom record:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:667
#, no-wrap
msgid ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:678
#, no-wrap
msgid ""
"How many possible values of type `Foo` are there? The answer is `7 * 2 = 14`,\n"
"as we can pair every possible `Weekday` (seven in total) with every possible\n"
"`Bool` (two in total). So, the number of possible values of a record type\n"
"is the *product* of the number of possible values for each field.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:680
#, no-wrap
msgid "The canonical product type is the `Pair`, which is available from the *Prelude*:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:681
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:692
#, no-wrap
msgid ""
"Since it is quite common to return several values from a function\n"
"wrapped in a `Pair` or larger tuple, Idris provides some syntactic\n"
"sugar for working with these. Instead of `Pair Weekday Bool`, we\n"
"can just write `(Weekday, Bool)`. Likewise, instead of `MkPair wd b`,\n"
"we can just write `(wd, b)` (the space is optional):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:693
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:700
#, no-wrap
msgid "This works also for nested tuples:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:701
#, no-wrap
msgid ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:713
#, no-wrap
msgid ""
"In the example above, `triple2` is converted to the form\n"
"used in `triple` by the Idris compiler.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:715
#, no-wrap
msgid "We can even use tuple syntax in pattern matches:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:716
#, no-wrap
msgid ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:723
#, no-wrap
msgid "As Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:728
#, no-wrap
msgid ""
"Sometimes, we'd like to take apart a value by pattern matching\n"
"on it but still retain the value as a whole for using it\n"
"in further computations:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:729
#, no-wrap
msgid ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:741
#, no-wrap
msgid ""
"In `baz`, variable `t` is *bound* to the triple as a whole, which\n"
"is then reused to construct the resulting quadruple. Remember,\n"
"that `(Nat,Bool,Weekday,String)` is just sugar for\n"
"`Pair Nat (Bool,Weekday,String)`, and `(length s, t)` is just\n"
"sugar for `MkPair (length s) t`. Hence, the implementation above\n"
"is correct as is confirmed by the type checker.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:748
#, no-wrap
msgid ""
"1. Define a record type for time spans by pairing a `UnitOfTime`\n"
"with an integer representing the duration of the time span in\n"
"the given unit of time. Define also a function for converting\n"
"a time span to an `Integer` representing the duration in seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:752
#, no-wrap
msgid ""
"2. Implement an equality check for time spans: Two time spans\n"
"should be considered equal, if and only if they correspond to\n"
"the same number of seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:757
#, no-wrap
msgid ""
"3. Implement a function for pretty printing time spans:\n"
"The resulting string should display the time span in its\n"
"given unit, plus show the number of seconds in parentheses,\n"
"if the unit is not already seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:761
#, no-wrap
msgid ""
"4. Implement a function for adding two time spans. If the\n"
"two time spans use different units of time, use the smaller\n"
"unit of time to ensure a lossless conversion.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:762
#, no-wrap
msgid "Generic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:772
#, no-wrap
msgid ""
"Sometimes, a concept is general enough that we'd like\n"
"to apply it not only to a single type, but to all\n"
"kinds of types. For instance, we might not want to define\n"
"data types for lists of integers, lists of strings, and lists\n"
"of booleans, as this would lead to a lot of code duplication.\n"
"Instead, we'd like to have a single generic list type *parameterized*\n"
"by the type of values it stores. This section explains how\n"
"to define and use generic types.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:773
#, no-wrap
msgid "Maybe"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:786
#, no-wrap
msgid ""
"Consider the case of parsing\n"
"a `Weekday` from user input. Surely, such\n"
"a function should return `Saturday`, if the\n"
"string input was `\"Saturday\"`, but what if the\n"
"input was `\"sdfkl332\"`? We have several options here.\n"
"For instance, we could just return a default result\n"
"(`Sunday` perhaps?). But is this the behavior\n"
"programmers expect when using our library? Maybe not. To silently\n"
"continue with a default value in the face of invalid user input\n"
"is hardly ever the best choice and may lead to a lot of\n"
"confusion.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:792
#, no-wrap
msgid ""
"In an imperative language, our function would probably\n"
"throw an exception. We could do this in Idris as\n"
"well (there is function `idris_crash` in the *Prelude* for\n"
"this), but doing so, we would abandon totality! A high\n"
"price to pay for such a common thing as a parsing error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:803
#, no-wrap
msgid ""
"In languages like Java, our function might also return some\n"
"kind of `null` value (leading to the dreaded `NullPointerException`s if\n"
"not handled properly in client code). Our solution will\n"
"be similar, but instead of silently returning `null`,\n"
"we will make the possibility of failure visible in the types!\n"
"We define a custom data type, which encapsulates the possibility\n"
"of failure. Defining new data types in Idris is very cheap\n"
"(in terms of the amount of code needed), therefore this is\n"
"often the way to go in order to increase type safety.\n"
"Here's an example how to do this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:804
#, no-wrap
msgid ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:823
#, no-wrap
msgid ""
"But assume now, we'd also like to read `Bool` values from\n"
"user input. We'd now have to write a custom data type\n"
"`MaybeBool` and so on for all types we'd like to read\n"
"from `String`, and the conversion of which might fail.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:827
#, no-wrap
msgid ""
"Idris, like many other programming languages, allows us\n"
"to generalize this behavior by using *generic data\n"
"types*. Here's an example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:828
#, no-wrap
msgid ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:839
#, no-wrap
msgid "It is important to go to the REPL and look at the types:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:840
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Option a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:857
#, no-wrap
msgid ""
"We need to introduce some jargon here. `Option` is what we call\n"
"a *type constructor*. It is not yet a saturated type: It is\n"
"a function from `Type` to `Type`.\n"
"However, `Option Bool` is a type, as is `Option Weekday`.\n"
"Even `Option (Option Bool)` is a valid type. `Option` is\n"
"a type constructor *parameterized* over a *parameter* of type `Type`.\n"
"`Some` and `None` are `Option`s *data constructors*: The functions\n"
"used to create values of type `Option a` for a type `a`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:860
#, no-wrap
msgid ""
"Let's see some other use cases for `Option`. Below is a safe\n"
"division operation:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:861
#, no-wrap
msgid ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:872
#, no-wrap
msgid ""
"The possibility of returning some kind of *null* value in the\n"
"face of invalid input is so common, that there is a data type\n"
"like `Option` already in the *Prelude*: `Maybe`, with\n"
"data constructors `Just` and `Nothing`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:884
#, no-wrap
msgid ""
"It is important to understand the difference between returning `Maybe Integer`\n"
"in a function, which might fail, and returning\n"
"`null` in languages like Java: In the former case, the\n"
"possibility of failure is visible in the types. The type checker\n"
"will force us to treat `Maybe Integer` differently than\n"
"`Integer`: Idris will *not* allow us to forget to\n"
"eventually handle the failure case.\n"
"Not so, if `null` is silently returned without adjusting the\n"
"types. Programmers may (and often *will*) forget to handle the\n"
"`null` case, leading to unexpected and sometimes\n"
"hard to debug runtime exceptions.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:885
#, no-wrap
msgid "Either"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:896
#, no-wrap
msgid ""
"While `Maybe` is very useful to quickly provide a default\n"
"value to signal some kind of failure, this value (`Nothing`) is\n"
"not very informative. It will not tell us *what exactly*\n"
"went wrong. For instance, in case of our `Weekday`\n"
"reading function, it might be interesting later on to know\n"
"the value of the invalid input string. And just like with\n"
"`Maybe` and `Option` above, this concept is general enough\n"
"that we might encounter other types of invalid values.\n"
"Here's a data type to encapsulate this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:897
#, no-wrap
msgid "data Validated e a = Invalid e | Valid a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:907
#, no-wrap
msgid ""
"`Validated` is a type constructor parameterized over two\n"
"type parameters `e` and `a`. It's data constructors\n"
"are `Invalid` and `Valid`,\n"
"the former holding a value describing some error condition,\n"
"the latter the result in case of a successful computation.\n"
"Let's see this in action:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:908
#, no-wrap
msgid ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:929
#, no-wrap
msgid ""
"Again, this is such a general concept that a data type\n"
"similar to `Validated` is already available from the\n"
"*Prelude*: `Either` with data constructors `Left` and `Right`.\n"
"It is very common for functions to encapsulate the possibility\n"
"of failure by returning an `Either err val`, where `err`\n"
"is the error type and `val` is the desired return type. This\n"
"is the type safe (and total!) alternative to throwing a catchable\n"
"exception in an imperative language.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:934
#, no-wrap
msgid ""
"Note, however, that the semantics of `Either` are not always \"`Left` is\n"
"an error and `Right` a success\". A function returning an `Either` just\n"
"means that it can have to different types of results, each of which\n"
"are *tagged* with the corresponding data constructor.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:935
#, no-wrap
msgid "List"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:941
#, no-wrap
msgid ""
"One of the most important data structures in pure functional\n"
"programming is the singly linked list. Here is its definition\n"
"(called `Seq` in order for it not to collide with `List`,\n"
"which is of course already available from the Prelude):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:942
#, no-wrap
msgid "data Seq a = Nil | (::) a (Seq a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:953
#, no-wrap
msgid ""
"This calls for some explanations. `Seq` consists of two *data constructors*:\n"
"`Nil` (representing an empty sequence of values) and `(::)` (also\n"
"called the *cons operator*), which prepends a new value of type `a` to\n"
"an already existing list of values of the same type. As you can see,\n"
"we can also use operators as data constructors, but please do not overuse\n"
"this. Use clear names for your functions and data constructors and only\n"
"introduce new operators when it truly helps readability!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:956
#, no-wrap
msgid ""
"Here is an example of how to use the `List` constructors\n"
"(I use `List` here, as this is what you should use in your own code):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:957
#, no-wrap
msgid ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:966
#, no-wrap
msgid ""
"However, there is a more concise way of writing the above. Idris\n"
"accepts special syntax for constructing data types consisting\n"
"exactly of the two constructors `Nil` and `(::)`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:967
#, no-wrap
msgid ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:980
#, no-wrap
msgid ""
"The two definitions `ints` and `ints2`\n"
"are treated identically by the compiler.\n"
"Note, that list syntax can also be used in pattern matches.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:991
#, no-wrap
msgid ""
"There is another thing that's special about\n"
"`Seq` and `List`: Each of them is defined\n"
"in terms of itself (the cons operator accepts a value\n"
"and another `Seq` as arguments). We call such data types\n"
"*recursive* data types, and their recursive nature means, that in order to\n"
"decompose or consume them, we typically require recursive\n"
"functions. In an imperative language, we might use a for loop or\n"
"similar construct to iterate over the values of a `List` or a `Seq`,\n"
"but these things do not exist in a language without in-place\n"
"mutation. Here's how to sum a list of integers:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:992
#, no-wrap
msgid ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1004
#, no-wrap
msgid ""
"Recursive functions can be hard to grasp at first, so I'll break\n"
"this down a bit. If we invoke `intSum` with the empty list,\n"
"the first pattern matches and the function returns zero immediately.\n"
"If, however, we invoke `intSum` with a non-empty list - `[7,5,9]`\n"
"for instance - the following happens:\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1008
#, no-wrap
msgid ""
"The second pattern matches and splits the list into two\n"
"parts: Its head (`7`) is bound to variable `n` and its tail\n"
"(`[5,9]`) is bound to `ns`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1009
#, no-wrap
msgid "   7 + intSum [5,9]\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1015
#, no-wrap
msgid ""
"In a second invocation, `intSum` is called with a new list: `[5,9]`.\n"
"The second pattern matches and `n` is bound to `5` and `ns` is bound\n"
"to `[9]`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1016
#, no-wrap
msgid "   7 + (5 + intSum [9])\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1023
#, no-wrap
msgid ""
"In a third invocation `intSum` is called with list `[9]`.\n"
"The second pattern matches and `n` is bound to `9` and `ns` is bound\n"
"to `[]`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1024
#, no-wrap
msgid "   7 + (5 + (9 + intSum [])\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1030
#, no-wrap
msgid ""
"In a fourth invocation, `intSum` is called with list `[]` and\n"
"returns `0` immediately:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1031
#, no-wrap
msgid "   7 + (5 + (9 + 0)\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1037
#, no-wrap
msgid ""
"In the third invocation, `9` and `0` are added and `9` is\n"
"returned:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1038
#, no-wrap
msgid "   7 + (5 + 9)\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DataTypes.md:1044
#, no-wrap
msgid ""
"In the second invocation, `5` and `9` are added and `14` is\n"
"returned:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1045
#, no-wrap
msgid "   7 + 14\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DataTypes.md:1051
#, no-wrap
msgid ""
"Finally, our initial invocation of `intSum` adds `7` and `14`\n"
"and returns `21`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1055
#, no-wrap
msgid ""
"Thus, the recursive implementation of `intSum` leads to a sequence of\n"
"nested calls to `intSum`, which terminates once the argument is the\n"
"empty list.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1056
#, no-wrap
msgid "Generic Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1062
#, no-wrap
msgid ""
"In order to fully appreciate the versatility that comes with\n"
"generic data types, we also need to talk about generic functions.\n"
"Like generic types, these are parameterized over one or more\n"
"type parameters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1068
#, no-wrap
msgid ""
"Consider for instance the case of breaking out of the\n"
"`Option` data type. In case of a `Some`, we'd like to return\n"
"the stored value, while for the `None` case we provide\n"
"a default value. Here's how to do this, specialized to\n"
"`Integer`s:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1069
#, no-wrap
msgid ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1080
#, no-wrap
msgid ""
"It's pretty obvious that this, again, is not general enough.\n"
"Surely, we'd also like to break out of `Option Bool` or\n"
"`Option String` in a similar fashion. That's exactly\n"
"what the generic function `fromOption` does:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1081
#, no-wrap
msgid ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1095
#, no-wrap
msgid ""
"The lower-case `a` is again a *type parameter*. You can read\n"
"the type signature as follows: \"For any type `a`, given a *value*\n"
"of type `a`, and an `Option a`, we can return a value of\n"
"type `a`.\" Note, that `fromOption` knows nothing else about\n"
"`a`, other than it being a type. It is therefore not possible,\n"
"to conjure a value of type `a` out of thin air. We *must* have\n"
"a value available to deal with the `None` case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1098
#, no-wrap
msgid ""
"The pendant to `fromOption` for `Maybe` is called `fromMaybe`\n"
"and is available from module `Data.Maybe` from the *base* library.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1104
#, no-wrap
msgid ""
"Sometimes, `fromOption` is not general enough. Assume we'd like to\n"
"print the value of a freshly parsed `Bool`, giving some generic\n"
"error message in case of a `None`. We can't use `fromOption`\n"
"for this, as we have an `Option Bool` and we'd like to\n"
"return a `String`. Here's how to do this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1105
#, no-wrap
msgid ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1121
#, no-wrap
msgid ""
"Function `option` is parameterized over *two* type parameters:\n"
"`a` represents the type of values stored in the `Option`,\n"
"while `b` is the return type. In case of a `Just`, we need\n"
"a way to convert the stored `a` to a `b`, an that's done\n"
"using the function argument of type `a -> b`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1126
#, no-wrap
msgid ""
"In Idris, lower-case identifiers in function types are\n"
"treated as *type parameters*, while upper-case identifiers\n"
"are treated as types or type constructors that must\n"
"be in scope.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, no-wrap
msgid "Exercises part 4"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1137
#, no-wrap
msgid ""
"If this is your first time programming in a purely\n"
"functional language, the exercises below are *very*\n"
"important. Do not skip any of them! Take your time and\n"
"work through them all. In most cases,\n"
"the types should be enough to explain what's going\n"
"on, even though they might appear cryptic in the\n"
"beginning. Otherwise, have a look at the comments (if any)\n"
"of each exercise.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1140
#, no-wrap
msgid ""
"Remember, that lower-case identifiers in a function\n"
"signature are treated as type parameters.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1142
#, no-wrap
msgid "Implement the following generic functions for `Maybe`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1143
#, no-wrap
msgid ""
"   -- make sure to map a `Just` to a `Just`.\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- keep the value in a `Just` only if the given predicate holds\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the first value that is not a `Nothing` (if any)\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the last value that is not a `Nothing` (if any)\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- this is another general way to extract a value from a `Maybe`.\n"
"   -- Make sure the following holds:\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1177
#, no-wrap
msgid "Implement the following generic functions for `Either`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1178
#, no-wrap
msgid ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- In case of both `Either`s being `Left`s, keep the\n"
"   -- value stored in the first `Left`.\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- Keep the first value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- Keep the last value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1207
#, no-wrap
msgid "Implement the following generic functions for `List`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1208
#, no-wrap
msgid ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- return the first value of a list, if it is non-empty\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the first value of a list, if it is non-empty\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- return the last value of a list, if it is non-empty\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the last value of a list,\n"
"   -- if it is non-empty\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- accumulate the values in a list using the given\n"
"   -- accumulator function and initial value\n"
"   --\n"
"   -- Examples:\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1245
#, no-wrap
msgid ""
"Assume we store user data for our web application in\n"
"the following record:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1246
#, no-wrap
msgid ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1260
#, no-wrap
msgid ""
"   Using `LoginError` from an earlier exercise,\n"
"   implement function `login`, which, given a list of `Client`s\n"
"   plus a value of type `Credentials` will return either a `LoginError`\n"
"   in case no valid credentials where provided, or the first `Client`\n"
"   for whom the credentials match.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1264
#, no-wrap
msgid ""
"Using your data type for chemical elements from an\n"
"earlier exercise, implement a function for calculating\n"
"the molar mass of a molecular formula.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1268
#, no-wrap
msgid ""
"   Use a list of elements each paired with its count\n"
"   (a natural number) for representing formulae. For\n"
"   instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1269
#, no-wrap
msgid ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1276
#, no-wrap
msgid ""
"   Hint: You can use function `cast` to convert a natural\n"
"   number to a `Double`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1277
#, no-wrap
msgid "Alternative Syntax for Data Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1285
#, no-wrap
msgid ""
"While the examples in the section about parameterized\n"
"data types are short and concise, there is a slightly\n"
"more verbose but much more general form for writing such\n"
"definitions, which makes it much clearer what's going on.\n"
"In my opinion, this more general form should be preferred\n"
"in all but the most simple data definitions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1290
#, no-wrap
msgid ""
"Here are the definitions of `Option`, `Validated`, and `Seq` again,\n"
"using this more general form (I put them in their own *namespace*,\n"
"so Idris will not complain about identical names in\n"
"the same source file):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1291
#, no-wrap
msgid ""
"-- GADT is an acronym for \"generalized algebraic data type\"\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1318
#, no-wrap
msgid ""
"Here, `Option` is clearly declared as a type constructor\n"
"(a function of type `Type -> Type`), while `Some`\n"
"is a generic function of type `a -> Option a` (where `a` is\n"
"a *type parameter*)\n"
"and `None` is a nullary generic function of type `Option a`\n"
"(`a` again being a type parameter).\n"
"Likewise for `Validated` and `Seq`. Note, that in case\n"
"of `Seq` we had to disambiguate between the different\n"
"`Seq` definitions in the recursive case. Since we will\n"
"usually not define several data types with the same name in\n"
"a source file, this is not necessary most of the time.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1323
#, no-wrap
msgid ""
"We covered a lot of ground in this chapter,\n"
"so I'll summarize the most important points below:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1326
#, no-wrap
msgid ""
"* Enumerations are data types consisting of a finite\n"
"number of possible *values*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1330
#, no-wrap
msgid ""
"* Sum types are data types with more than one data\n"
"constructor, where each constructor describes a\n"
"*choice* that can be made.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1333
#, no-wrap
msgid ""
"* Product types are data types with a single constructor\n"
"used to group several values of possibly different types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1337
#, no-wrap
msgid ""
"* We use pattern matching to deconstruct immutable\n"
"values in Idris. The possible patterns correspond to\n"
"a data type's data constructors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1341
#, no-wrap
msgid ""
"* We can *bind* variables to values in a pattern or\n"
"use an underscore as a placeholder for a value that's\n"
"not needed on the right hand side of an implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1344
#, no-wrap
msgid ""
"* We can pattern match on an intermediary result by introducing\n"
"a *case block*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1349
#, no-wrap
msgid ""
"* The preferred way to define new product types is\n"
"to define them as *records*, since these come with\n"
"additional syntactic conveniences for setting and\n"
"modifying individual *record fields*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1354
#, no-wrap
msgid ""
"* Generic types and functions allow us generalize\n"
"certain concepts and make them available for many\n"
"types by using *type parameters* instead of\n"
"concrete types in function and type signatures.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1361
#, no-wrap
msgid ""
"* Common concepts like *nullary values* (`Maybe`),\n"
"computations that might fail with some error\n"
"condition (`Either`), and handling collections\n"
"of values of the same type at once (`List`) are\n"
"example use cases of generic types and functions\n"
"already provided by the *Prelude*.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1366
#, no-wrap
msgid ""
"In the [next section](Interfaces.md), we will introduce\n"
"*interfaces*, another approach to *function overloading*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
