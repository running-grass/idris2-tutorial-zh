# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "练习第 1 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "练习第 2 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "练习第 3 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, no-wrap
msgid "Exercises part 4"
msgstr "练习第 4 部分"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, fuzzy, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"

#. type: Title #
#: ../src/Tutorial/Eq.md:1
#, no-wrap
msgid "Propositional Equality"
msgstr "命题等式"

#. type: Plain text
#: ../src/Tutorial/Eq.md:9
#, no-wrap
msgid ""
"In the [last chapter](DPair.md) we learned, how dependent pairs\n"
"and records can be used to calculate *types* from values only known\n"
"at runtime by pattern matching on these values. We will now look\n"
"at how we can describe relations - or *contracts* - between\n"
"values as types, and how we can use values of these types as\n"
"proofs that the contracts hold.\n"
msgstr "在 [上一章](DPair.md) 中，我们了解了如何使用依赖对和记录来计算 *类型*，这些值仅在运行时通过对这些值进行模式匹配而已知。现在，我们将研究如何将值之间的关系或 *契约* 描述为类型，以及如何使用这些类型的值作为契约持有的证明。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:10
#, no-wrap
msgid ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:21
#, no-wrap
msgid "Equality as a Type"
msgstr "等式作为一种类型"

#. type: Plain text
#: ../src/Tutorial/Eq.md:26
#, no-wrap
msgid ""
"Imagine, we'd like to concatenate the contents of two CSV files,\n"
"both of which we stored on disk as tables together with their schemata\n"
"as shown in our discussion about dependent pairs:\n"
msgstr "想象一下，我们想要连接两个 CSV 文件的内容，我们将这两个文件作为表连同它们的模式一起存储在磁盘上，如我们关于依赖对的讨论中所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:27
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"
msgstr ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:55
#, fuzzy, no-wrap
msgid ""
"We will not be able to implement `concatTables1` by appending the\n"
"two row vectors, unless we can somehow verify that the two schemata\n"
"are identical. \"Well,\" I hear you say, \"that shouldn't be a big issue!\n"
"Just implement `Eq` for `ColType`\". Let's give this a try:\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:56
#, no-wrap
msgid ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"
msgstr ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:73
#, no-wrap
msgid ""
"Somehow, this doesn't seem to work. If we inspect the context of hole\n"
"`what_now`, Idris still thinks that `s1` and `s2` are different, and\n"
"if we go ahead and invoke `Vect.(++)` anyway in the `True` case,\n"
"Idris will respond with a type error.\n"
msgstr "不知何故，这似乎不起作用。如果我们检查孔 `what_now` 的上下文，Idris 仍然认为 `s1` 和 `s2` 是不同的，如果我们继续调用 `Vect.( ++)` ，在 `True` 的情况下，Idris 将响应类型错误。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:74
#, no-wrap
msgid ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"
msgstr ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:92
#, no-wrap
msgid ""
"The problem is, that there is no reason for Idris to unify the two\n"
"values, even though `(==)` returned `True` because the result of `(==)`\n"
"holds no other information than the type being a `Bool`. *We* think,\n"
"if this is `True` the two values should be identical, but Idris is not\n"
"convinced. In fact, the following implementation of `Eq ColType`\n"
"would be perfectly fine as far as the type checker is concerned:\n"
msgstr "问题是，Idris 没有理由统一这两个值，即使 `(==)` 返回 `True` 因为 `(==)` 的结果除了类型为 `Bool` 之外没有其他信息。 *我们* 认为，如果这是 `True` 那么两个值应该是相同的，但 Idris 不相信。事实上，就类型检查器而言，以下 `Eq ColType` 的实现会非常好：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:93
#, no-wrap
msgid ""
"Eq ColType where\n"
"  _       == _       = True\n"
msgstr ""
"Eq ColType where\n"
"  _       == _       = True\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:106
#, no-wrap
msgid ""
"So Idris is right in not trusting us. You might expect it to inspect the\n"
"implementation of `(==)` and figure out on its own, what the `True` result\n"
"means, but this is not how these things work in general, because most of the\n"
"time the number of computational paths to check would be far too large.\n"
"As a consequence, Idris is able to evaluate functions during\n"
"unification, but it will not trace back information about function\n"
"arguments from a function's result for us. We can do so manually, however,\n"
"as we will see later.\n"
msgstr "所以伊德里斯不信任我们是对的。您可能希望它检查 `(==)` 的实现并自行弄清楚 `True` 结果的含义，但这并不是这些事情通常的工作方式，因为大多数时候，要检查的计算路径的数量会太大。因此，Idris 能够在统一期间求值函数，但它不会为我们从函数结果中追溯有关函数参数的信息。但是，我们可以手动执行此操作，稍后我们将看到。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:107
#, no-wrap
msgid "A Type for equal Schemata"
msgstr "相等 schemata 的类型"

#. type: Plain text
#: ../src/Tutorial/Eq.md:114
#, no-wrap
msgid ""
"The problem described above is similar to what we saw when\n"
"we talked about the benefit of [singleton types](DPair.md#erased-existentials):\n"
"The types are not precise enough. What we are going to do now,\n"
"is something we'll repeat time again for different use cases:\n"
"We encode a contract between values in an indexed data type:\n"
msgstr "上面描述的问题类似于我们在谈到[singleton types](DPair.md#erased-existentials)的好处时看到的：类型不够精确。我们现在要做的是，我们将针对不同的用例再次重复：我们对索引数据类型中的值之间的契约进行编码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:115
#, no-wrap
msgid ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"
msgstr ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:124
#, no-wrap
msgid ""
"First, note how `SameSchema` is a family of types indexed over two\n"
"values of type `Schema`. But note also that the sole constructor\n"
"restricts the values we allow for `s1` and `s2`: The two indices\n"
"*must* be identical.\n"
msgstr "首先，请注意 `SameSchema` 是通过两个 `Schema` 类型的值索引的类型族。但还要注意，唯一的构造函数限制了我们允许 `s1` 和 `s2` 的值：两个索引 *必须* 相同。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:128
#, no-wrap
msgid ""
"Why is this useful? Well, imagine we had a function for checking\n"
"the equality of two schemata, which would try and return a value\n"
"of type `SameSchema s1 s2`:\n"
msgstr "为什么这很有用？好吧，假设我们有一个检查两个 schemata 是否相等的函数，它会尝试返回一个类型为 `SameSchema s1 s2` 的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:129
#, no-wrap
msgid "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"
msgstr "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:134
#, no-wrap
msgid "We could then use this function to implement `concatTables`:\n"
msgstr "然后我们可以使用这个函数来实现 `concatTables`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:135
#, no-wrap
msgid ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:143
#, no-wrap
msgid "It worked! What's going on here? Well, let's inspect the types involved:\n"
msgstr "有效！这里发生了什么？好吧，让我们检查一下所涉及的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:144
#, no-wrap
msgid ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"
msgstr ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:152
#, no-wrap
msgid "At the REPL, we get the following context for `almost_there`:\n"
msgstr "在 REPL 中，我们得到 `almost_there` 的以下上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:153
#, no-wrap
msgid ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"
msgstr ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:168
#, no-wrap
msgid ""
"See, how the types of `rs1` and `rs2` unify? Value `Same`, coming as the\n"
"result of `sameSchema s1 s2`, is a *witness* that `s1` and `s2` are actually\n"
"identical, because this is what we specified in the definition of `Same`.\n"
msgstr "看看，`rs1` 和 `rs2` 的类型是怎么统一的？值 `Same`，作为 `sameSchema s1 s2` 的结果， `s1` 和 `s2` 是实际上相同的 *见证*，因为这是我们在 `Same` 的定义中指定的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:172
#, no-wrap
msgid ""
"All that remains to do is to implement `sameSchema`. For this, we will write\n"
"another data type for specifying when two values of type `ColType` are\n"
"identical:\n"
msgstr "剩下要做的就是实现`sameSchema`。为此，我们将编写另一种数据类型，用于指定 `ColType` 类型的两个值何时相同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:173
#, no-wrap
msgid ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"
msgstr ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:180
#, no-wrap
msgid ""
"We can now define several utility functions. First, one for figuring out\n"
"if two column types are identical:\n"
msgstr "我们现在可以定义几个工具函数。首先，用于确定两个列类型是否相同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:181
#, no-wrap
msgid ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"
msgstr ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:195
#, no-wrap
msgid ""
"This will convince Idris, because in each pattern match, the return\n"
"type will be adjusted according to the values we matched on. For instance,\n"
"on the first line, the output type is `Maybe (SameColType I64 I64)` as\n"
"you can easily verify yourself by inserting a hole and checking its\n"
"type at the REPL.\n"
msgstr "这将说服 Idris，因为在每个模式匹配中，返回类型将根据我们匹配的值进行调整。例如，在第一行，输出类型是 `Maybe (SameColType I64 I64)`，因为您可以自己通过插入一个孔并在 REPL 中检查其类型来轻松验证。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:203
#, no-wrap
msgid ""
"We will need two additional utilities: Functions for creating values\n"
"of type `SameSchema` for the nil and cons cases. Please note, how\n"
"the implementations are trivial. Still, we often have to quickly\n"
"write such small proofs (I'll explain in the next section, why I\n"
"call them *proofs*), which will then be used to convince the\n"
"type checker about some fact we already take for granted but Idris\n"
"does not.\n"
msgstr "我们将需要两个额外的实用程序： 用于为 nil 和 cons 情况创建 `SameSchema` 类型值的函数。请注意，实现是多么微不足道。尽管如此，我们还是经常不得不快速写出这么小的证明（我将在下一节解释，为什么我称它们为 *证明*），然后用来让类型检查器相信我们已经采取的一些事实是理所当然但 Idris 不知道的。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:204
#, no-wrap
msgid ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"
msgstr ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:221
#, no-wrap
msgid ""
"As usual, it can help understanding what's going on by replacing\n"
"the right hand side of `sameCons` with a hole an check out its\n"
"type and context at the REPL. The presence of values `SameCT`\n"
"and `Same` on the left hand side forces Idris to unify `c1` and `c2`\n"
"as well as `s1` and `s2`, from which the unification of\n"
"`c1 :: s1` and `c2 :: s2` immediately follows.\n"
"With these, we can finally implement `sameSchema`:\n"
msgstr "像往常一样，它可以通过将 `sameCons` 的右侧替换为一个孔并在 REPL 中检查其类型和上下文来帮助理解发生了什么。左侧存在值 `SameCT` 和 `Same` 迫使 Idris 统一 `c1` 和 `c2` 以及 `s1 ` 和 `s2`，紧接着是 `c1 :: s1` 和 `c2 :: s2` 的统一。有了这些，我们终于可以实现`sameSchema`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:222
#, no-wrap
msgid ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"
msgstr ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:238
#, no-wrap
msgid ""
"What we described here is a far stronger form of equality\n"
"than what is provided by interface `Eq` and the `(==)`\n"
"operator: Equality of values that is accepted by the\n"
"type checker when trying to unify type level indices.\n"
"This is also called *propositional equality*: We will see\n"
"below, that we can view types as mathematical *propositions*,\n"
"and values of these types a *proofs* that these propositions\n"
"hold.\n"
msgstr "我们在这里描述的是一种比接口 `Eq` 和 `(==)` 运算符提供的更强大的相等形式：类型检查器在尝试时接受的值相等统一类型级索引。这也称为 *命题等式*：我们将在下面看到，我们可以将类型视为数学 *命题*，这些类型的值是这些命题所持有的 *证明* .\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:239
#, no-wrap
msgid "Type `Equal`"
msgstr "`Equal` 类型"

#. type: Plain text
#: ../src/Tutorial/Eq.md:251
#, no-wrap
msgid ""
"Propositional equality is such a fundamental concept, that the *Prelude*\n"
"exports a general data type for this already: `Equal`, with its only\n"
"data constructor `Refl`. In addition, there is a built-in operator\n"
"for expressing propositional equality, which gets desugared to `Equal`:\n"
"`(=)`. This can sometimes lead to some confusion, because the equals\n"
"symbol is also used for *definitional equality*: Describing in function\n"
"implementations that the left-hand side and right-hand side are\n"
"defined to be equal. If you want to disambiguate propositional from\n"
"definitional equality, you can also use operator `(===)` for the\n"
"former.\n"
msgstr "命题等式是一个基本概念，以至于 *Prelude* 已经为此导出了一个通用数据类型：`Equal`，以及它唯一的数据构造函数 `Refl`。此外，还有一个用于表达命题相等的内置运算符，它被脱糖为 `Equal`：`(=)`。这有时会导致一些混淆，因为等号也用于*相等定义*：在函数实现中描述左侧和右侧被定义为相等。如果您想从定义相等中消除命题的歧义，您还可以使用运算符 `(===)` 来表示前者。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:253
#, no-wrap
msgid "Here is another implementation of `concatTables`:\n"
msgstr "这是 `concatTables` 的另一个实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:254
#, no-wrap
msgid ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) |]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) |]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:285
#, no-wrap
msgid ""
"In the following exercises, you are going to implement\n"
"some very basic properties of equality proofs. You'll\n"
"have to come up with the types of the functions yourself,\n"
"as the implementations will be incredibly simple.\n"
msgstr "在接下来的练习中，您将实现等式证明的一些非常基本的属性。您必须自己提出函数的类型，因为实现将非常简单。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:289
#, no-wrap
msgid ""
"Note: If you can't remember what the terms \"reflexive\",\n"
"\"symmetric\", and \"transitive\" mean, quickly read about\n"
"equivalence relations [here](https://en.wikipedia.org/wiki/Equivalence_relation).\n"
msgstr "注意：如果您不记得术语“自反”、“对称”和“传递”的含义，请快速阅读关于等价关系的内容 [此处](https://en.wikipedia.org/wiki/Equivalence_relation)。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:291
#, no-wrap
msgid "Show that `SameColType` is a reflexive relation.\n"
msgstr "证明 `SameColType` 是自反关系。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:293
#, no-wrap
msgid "Show that `SameColType` is a symmetric relation.\n"
msgstr "证明 `SameColType` 是一个对称关系。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:295
#, no-wrap
msgid "Show that `SameColType` is a transitive relation.\n"
msgstr "证明 `SameColType` 是传递关系。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:299
#, no-wrap
msgid ""
"Let `f` be a function of type `ColType -> a` for an\n"
"arbitrary type `a`. Show that from a value of type\n"
"`SameColType c1 c2` follows that `f c1` and `f c2` are equal.\n"
msgstr "对于任意类型 `a`，令 `f` 为 `ColType -> a` 类型的函数。证明从 `SameColType c1 c2` 类型的值得出 `f c1` 和 `f c2` 相等。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:303
#, no-wrap
msgid ""
"For `(=)` the above properties are available from the *Prelude*\n"
"as functions `sym`, `trans`, and `cong`. Reflexivity comes\n"
"from the data constructor `Refl` itself.\n"
msgstr "对于 `(=)`，上述属性可从 *Prelude* 作为函数 `sym`、`trans` 和 `cong` 获得.自反性来自数据构造函数 `Refl` 本身。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:307
#, no-wrap
msgid ""
"Implement a function for verifying that two natural\n"
"numbers are identical. Try using `cong` in your\n"
"implementation.\n"
msgstr "实现一个函数来验证两个自然数是否相同。尝试在您的实现中使用 `cong`。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:310
#, no-wrap
msgid ""
"Use the function from exercise 5 for zipping two\n"
"`Table`s if they have the same number of rows.\n"
msgstr "如果两个 `Table` 的行数相同，请使用练习 5 中的函数压缩它们。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:315
#, no-wrap
msgid ""
"   Hint: Use `Vect.zipWith`. You will need to implement\n"
"   custom function `appRows` for this, since Idris will\n"
"   not automatically figure out that the types unify when\n"
"   using `HList.(++)`:\n"
msgstr ""
"   提示：使用 `Vect.zipWith`。您将需要为此实现\n"
"   自定义函数 `appRows`，因为使用 `HList.(++)` 时 Idris 将\n"
"   不会自动确定类型何时统一 ：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:316
#, no-wrap
msgid "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"
msgstr "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:323
#, no-wrap
msgid ""
"We will later learn how to use *rewrite rules* to circumvent\n"
"the need of writing custom functions like `appRows` and use\n"
"`(++)` in `zipWith` directly.\n"
msgstr "稍后我们将学习如何使用 *重写规则* 来规避编写自定义函数的需要，例如 `appRows` ，并在 `zipWith` 中直接使用 `(++)` 。\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:324
#, no-wrap
msgid "Programs as Proofs"
msgstr "程序作为证明"

#. type: Plain text
#: ../src/Tutorial/Eq.md:333
#, no-wrap
msgid ""
"A famous observation by mathematician *Haskell Curry* and\n"
"logician *William Alvin Howard* leads to the conclusion,\n"
"that we can view a *type* in a programming language with\n"
"a sufficiently rich type system as a mathematical proposition\n"
"and a total program calculating a *value* of this type as a\n"
"proof that the proposition holds. This is also known as the\n"
"[Curry-Howard isomorphism](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence).\n"
msgstr "数学家 *Haskell Curry* 和逻辑学家 *William Alvin Howard* 的著名观察得出的结论是，我们可以在具有足够丰富类型的编程语言中查看 *类型*系统作为一个数学命题和一个计算这种类型的*值*的完全程序作为命题成立的证明。这也称为 [Curry-Howard 同构](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:336
#, no-wrap
msgid ""
"For instance, here is a simple proof that one plus one\n"
"equals two:\n"
msgstr "例如，这里有一个简单的证明，证明一加一等于二：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:337
#, no-wrap
msgid ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"
msgstr ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:346
#, no-wrap
msgid ""
"The above proof is trivial, as Idris solves this by unification.\n"
"But we already stated some more interesting things in the\n"
"exercises. For instance, the symmetry and transitivity of\n"
"`SameColType`:\n"
msgstr "上面的证明是微不足道的，因为 Idris 通过统一解决了这个问题。但是我们已经在练习中陈述了一些更有趣的事情。例如 `SameColType` 的对称性和传递性：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:347
#, no-wrap
msgid ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 c3\n"
"sctTransitive SameCT SameCT = SameCT\n"
msgstr ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 c3\n"
"sctTransitive SameCT SameCT = SameCT\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:357
#, no-wrap
msgid ""
"Note, that a type alone is not a proof. For instance, we are free\n"
"to state that one plus one equals three:\n"
msgstr "请注意，单独的类型不是证明。例如，我们可以自由地说一加一等于三：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:358
#, no-wrap
msgid "onePlusOneWrong : the Nat 1 + 1 = 3\n"
msgstr "onePlusOneWrong : the Nat 1 + 1 = 3\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:365
#, no-wrap
msgid ""
"We will, however, have a hard time implementing this in a provably\n"
"total way. We say: \"The type `the Nat 1 + 1 = 3` is *uninhabited*\",\n"
"meaning, that there is no value of this type.\n"
msgstr "然而，我们将很难以可证明的整体方式实现这一点。我们说：“类型 `the Nat 1 + 1 = 3` 是 *uninhabited*”，意思是这个类型没有值。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:366
#, no-wrap
msgid "When Proofs replace Tests"
msgstr "当证明取代测试时"

#. type: Plain text
#: ../src/Tutorial/Eq.md:373
#, no-wrap
msgid ""
"We will see several different use cases for compile time proofs, a\n"
"very straight forward one being to show that our functions behave\n"
"as they should by proofing some properties about them. For instance,\n"
"here is a proposition that `map` on list does not change the number of\n"
"elements in the list:\n"
msgstr "我们将看到几个不同的编译时证明用例，一个非常直接的用例是通过证明我们的函数的一些属性来证明我们的函数行为应该如此。例如，这里有一个命题，列表上的 `map` 不会改变列表中元素的数量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:374
#, no-wrap
msgid "mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f as)\n"
msgstr "mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f as)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:381
#, no-wrap
msgid ""
"Read this as a universally quantified statement: For all functions `f`\n"
"from `a` to `b` and for all lists `as` holding values of type `a`,\n"
"the length of `map f as` is the same the as the length of the original list.\n"
msgstr "将此视为一个普遍量化的陈述：对于从 `a` 到 `b` 的所有函数 `f` 以及所有包含 `as` 类型值的列表 `a`，`map f as`的长度与原始列表的长度相同。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:387
#, no-wrap
msgid ""
"We can implement `mapListLength` by pattern matching on `as`. The `Nil` case\n"
"will be trivial: Idris solves this by unification. It knows the value of the\n"
"input list (`Nil`), and since `map` is implemented by pattern matching on\n"
"the input as well, it follows immediately that the result will be `Nil` as\n"
"well:\n"
msgstr "我们可以通过在 `as` 上进行模式匹配来实现 `mapListLength`。 `Nil` 的情况很简单：Idris 通过统一解决了这个问题。它知道输入列表的值 (`Nil`)，并且由于 `map` 也是通过对输入的模式匹配实现的，因此立即得出结果将为 `Nil ` ，所以：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:388
#, no-wrap
msgid "mapListLength f []        = Refl\n"
msgstr "mapListLength f []        = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:395
#, no-wrap
msgid ""
"The `cons` case is more involved, and we will do this stepwise.\n"
"First, note that we can proof that the length of a map over the\n"
"tail will stay the same by means of recursion:\n"
msgstr "`cons` 的情况比较复杂，我们将逐步进行。首先，请注意，我们可以通过递归证明映射在尾部的长度将保持不变：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:397
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"
msgstr ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:403
#, no-wrap
msgid "Let's inspect the types and context we have here:\n"
msgstr "让我们检查一下我们在这里拥有的类型和上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:404
#, no-wrap
msgid ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"
msgstr ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:422
#, no-wrap
msgid ""
"So, we have a proof of type `length xs = length (map f xs)`,\n"
"and from the implementation of `map` Idris concludes that what\n"
"we are actually looking for is a result of type\n"
"`S (length xs) = S (length (map f xs))`. This is exactly what\n"
"function `cong` from the *Prelude* is for (\"cong\" is an abbreviation\n"
"for *congruence*). We can thus implement the *cons* case\n"
"concisely like so:\n"
msgstr "所以，我们有一个类型 `length xs = length (map f xs)` 的证明，并且从 `map` 的实现 Idris 得出结论，我们真正要寻找的是类型的结果`S (length xs) = S (length (map f xs))`。这正是 *Prelude* 中的函数 `cong` 的用途（“cong”是 *congruence* 的缩写）。因此，我们可以像这样简洁地实现 *cons* 案例：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:423
#, no-wrap
msgid "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"
msgstr "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:431
#, no-wrap
msgid ""
"Please take a moment to appreciate what we achieved here:\n"
"A *proof* in the mathematical sense that our function will not\n"
"affect the length of our list. We no longer need a unit test\n"
"or similar program to verify this.\n"
msgstr "请花点时间欣赏一下我们在这里取得的成就：数学意义上的 *证明*，我们的函数不会影响列表的长度。我们不再需要单元测试或类似程序来验证这一点。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:435
#, no-wrap
msgid ""
"Before we continue, please note an important thing: In our\n"
"case expression, we used a *variable* for the result from the\n"
"recursive call:\n"
msgstr "在我们继续之前，请注意一件重要的事情：在我们的 case 表达式中，我们使用 *变量* 来表示递归调用的结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:436
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"
msgstr ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:448
#, no-wrap
msgid ""
"Here, we did not want the two lengths to unify, because we\n"
"needed the distinction in our call to `cong`. Therefore: If\n"
"you need a proof of type `x = y` in order for two variables\n"
"to unify, use the `Refl` data constructor in the pattern match.\n"
"If, on the other hand, you need to run further computations on\n"
"such a proof, use a variable and the left and right-hand sides\n"
"will remain distinct.\n"
msgstr "在这里，我们不希望这两个长度统一，因为我们需要在调用 `cong` 时加以区分。因此：如果您需要 `x = y` 类型的证明来统一两个变量，请在模式匹配中使用 `Refl` 数据构造函数。另一方面，如果您需要对这样的证明进行进一步的计算，请使用变量，并且左侧和右侧将保持不同。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:453
#, no-wrap
msgid ""
"Here is another example from the last chapter: We want to show\n"
"that parsing and printing column types behaves correctly.\n"
"Writing proofs about parsers can be very hard in general, but\n"
"here it can be done with a mere pattern match:\n"
msgstr "这是上一章的另一个例子：我们想证明解析和打印列类型的行为是正确的。一般来说，编写关于解析器的证明可能非常困难，但在这里可以仅通过模式匹配来完成：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:454
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"
msgstr ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:477
#, no-wrap
msgid ""
"Such simple proofs give us quick but strong guarantees\n"
"that we did not make any stupid mistakes.\n"
msgstr "这样简单的证明给了我们快速但有力的保证，我们没有犯任何愚蠢的错误。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:485
#, no-wrap
msgid ""
"The examples we saw so far were very easy to implement. In general,\n"
"this is not the case, and we will have to learn about several\n"
"additional techniques in order to proof interesting things about\n"
"our programs. However, when we use Idris as a general purpose\n"
"programming language and not as a proof assistant, we are free\n"
"to choose whether some aspect of our code needs such strong\n"
"guarantees or not.\n"
msgstr "到目前为止，我们看到的示例非常容易实现。一般来说，情况并非如此，我们将不得不学习一些额外的技术来证明我们程序的有趣之处。但是，当我们将 Idris 用作通用编程语言而不是用作证明助手时，我们可以自由选择代码的某些方面是否需要这种强有力的保证。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:486
#, no-wrap
msgid "A Note of Caution: Lowercase Identifiers in Function Types"
msgstr "注意事项：函数类型中的小写标识符"

#. type: Plain text
#: ../src/Tutorial/Eq.md:494
#, no-wrap
msgid ""
"When writing down the types of proofs as we did above, one\n"
"has to be very careful not to fall into the following trap:\n"
"In general, Idris will treat lowercase identifiers in\n"
"function types as type parameters (erased implicit arguments).\n"
"For instance, here is a try at proofing the identity functor\n"
"law for `Maybe`:\n"
msgstr "在写下我们上面所做的证明类型时，必须非常小心不要落入以下陷阱：通常，Idris 会将函数类型中的小写标识符视为类型参数（已删除的隐式参数）。例如，这里尝试证明 `Maybe` 的恒等函子定律：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:495
#, fuzzy, no-wrap
msgid ""
"mapMaybeId1 : (ma : Maybe a) -> map id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:504
#, no-wrap
msgid ""
"You will not be able to implement the `Just` case, because\n"
"Idris treats `id` as an implicit argument as can easily be\n"
"seen when inspecting the context of `mapMaybeId1_rhs`:\n"
msgstr "您将无法实现 `Just` 案例，因为 Idris 将 `id` 视为隐式参数，这在检查 `mapMaybeId1_rhs` 的上下文时很容易看出：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:505
#, no-wrap
msgid ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"
msgstr ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:517
#, no-wrap
msgid ""
"As you can see, `id` is an erased argument of type `a -> a`. And in\n"
"fact, when type-checking this module, Idris will issue a warning that\n"
"parameter `id` is shadowing an existing function:\n"
msgstr "如您所见，`id` 是 `a -> a` 类型的已擦除参数。事实上，在对该模块进行类型检查时，Idris 会发出警告，指出参数 `id` 正在隐藏现有函数：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:518
#, no-wrap
msgid ""
"Warning: We are about to implicitly bind the following lowercase names.\n"
"You may be unintentionally shadowing the associated global definitions:\n"
"  id is shadowing Prelude.Basics.id\n"
msgstr ""
"警告：我们即将隐式绑定以下小写名称。\n"
"您可能无意中隐藏了相关的全局定义：\n"
"  id 正在影响 Prelude.Basics.id\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:527
#, no-wrap
msgid ""
"The same is not true for `map`: Since we explicitly pass arguments\n"
"to `map`, Idris treats this as a function name and not as an\n"
"implicit argument.\n"
msgstr "`map` 的情况并非如此：由于我们将参数显式传递给 `map`，Idris 将其视为函数名而不是隐式参数。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:530
#, no-wrap
msgid ""
"You have several options here. For instance, you could use an uppercase\n"
"identifier, as these will never be treated as implicit arguments:\n"
msgstr "您在这里有几个选择。例如，您可以使用大写标识符，因为这些标识符永远不会被视为隐式参数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:531
#, no-wrap
msgid ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"
msgstr ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:543
#, no-wrap
msgid ""
"As an alternative - and this is the preferred way to handle this case -\n"
"you can prefix `id` with part of its namespace, which will immediately\n"
"resolve the issue:\n"
msgstr "作为替代方案 - 这是处理这种情况的首选方式 - 您可以在 `id` 前加上其命名空间的一部分，这将立即解决问题：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:544
#, no-wrap
msgid ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"
msgstr ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:554
#, no-wrap
msgid ""
"Note: If you have semantic highlighting turned on in your editor\n"
"(for instance, by using the [idris2-lsp plugin](https://github.com/idris-community/idris2-lsp)),\n"
"you will note that `map` and `id` in `mapMaybeId1` get\n"
"highlighted differently: `map` as a function name, `id` as a bound variable.\n"
msgstr "注意：如果您在编辑器中打开了语义突出显示（例如，通过使用 [idris2-lsp 插件](https://github.com/idris-community/idris2-lsp)），您会注意到 `mapMaybeId1` 中的 `map` 和 `id` 以不同的方式突出显示：`map` 作为函数名称，`id` 作为绑定变量。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:562
#, no-wrap
msgid ""
"In these exercises, you are going to proof several simple properties\n"
"of small functions. When writing proofs, it is even more important\n"
"to use holes to figure out what Idris expects from you next. Use\n"
"the tools given to you, instead of trying to find your way in the\n"
"dark!\n"
msgstr "在这些练习中，您将证明小函数的几个简单属性。在编写证明时，更重要的是利用漏洞来弄清楚 Idris 下一步对你的期望。使用提供给您的工具，而不是试图在黑暗中找到自己的方式！\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:564
#, no-wrap
msgid "Proof that `map id` on an `Either e` returns the value unmodified.\n"
msgstr "证明 `Either e` 上的 `map id` 返回未修改的值。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:566
#, no-wrap
msgid "Proof that `map id` on a list returns the list unmodified.\n"
msgstr "证明列表上的 `map id` 返回未修改的列表。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:570
#, no-wrap
msgid ""
"Proof that complementing a strand of a nucleobase\n"
"(see the [previous chapter](DPair.md#use-case-nucleic-acids))\n"
"twice leads to the original strand.\n"
msgstr "证明补充一条核碱基链（参见 [上一章](DPair.md#use-case-nucleic-acids)）两次 leads 为原来的链。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:574
#, no-wrap
msgid ""
"   Hint: Proof this for single bases first, and use `cong2`\n"
"   from the *Prelude* in your implementation for sequences\n"
"   of nucleic acids.\n"
msgstr "   提示：首先对单碱基进行证明，然后在核酸序列的实现中使用 *Prelude* 中的`cong2`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:576
#, no-wrap
msgid "Implement function `replaceVect`:\n"
msgstr "实现函数 `replaceVect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:577
#, no-wrap
msgid "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"
msgstr "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:584
#, no-wrap
msgid ""
"   Now proof, that after replacing an element in a vector\n"
"   using `replaceAt` accessing the same element using\n"
"   `index` will return the value we just added.\n"
msgstr ""
"   现在证明，在替换向量中的元素之后\n"
"   使用 `replaceAt` 访问相同的元素\n"
"   `index` 将返回我们刚刚添加的值。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:586
#, no-wrap
msgid "Implement function `insertVect`:\n"
msgstr "实现函数 `insertVect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:587
#, no-wrap
msgid "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"
msgstr "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:593
#, no-wrap
msgid ""
"   Use a similar proof as in exercise 4 to show that this\n"
"   behaves correctly.\n"
msgstr ""
"   使用与练习 4 中类似的证明来证明\n"
"   行为正确。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:596
#, no-wrap
msgid ""
"Note: Functions `replaceVect` and `insertVect` are available\n"
"from `Data.Vect` as `replaceAt` and `insertAt`.\n"
msgstr "注意：函数 `replaceVect` 和 `insertVect` 可从 `Data.Vect` 作为 `replaceAt` 和 `insertAt` 获得。\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:597
#, no-wrap
msgid "Into the Void"
msgstr "进入虚空"

#. type: Plain text
#: ../src/Tutorial/Eq.md:612
#, no-wrap
msgid ""
"Remember function `onePlusOneWrong` from above? This was definitely\n"
"a wrong statement: One plus one does not equal three. Sometimes,\n"
"we want to express exactly this: That a certain statement is false\n"
"and does not hold. Consider for a moment what it means to proof\n"
"a statement in Idris: Such a statement (or proposition) is a\n"
"type, and a proof of the statement is a value or expression of\n"
"this type: The type is said to be *inhabited*.\n"
"If a statement is not true, there can be no value\n"
"of the given type. We say, the given type is *uninhabited*.\n"
"If we still manage to get our hands on a value of an uninhabited\n"
"type, that is a logical contradiction and from this, anything\n"
"follows (remember\n"
"[ex falso quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion)).\n"
msgstr "还记得上面的函数 `onePlusOneWrong` 吗？这绝对是一个错误的说法：一加一不等于三。有时，我们想准确地表达这一点：某个陈述是错误的并且不成立。考虑一下在 Idris 中证明一个陈述意味着什么：这样一个陈述（或命题）是一种类型，并且该陈述的证明是这种类型的一个值或表达式：该类型被称为 *有人居住的*。如果陈述不正确，则不能有给定类型的值。我们说，给定的类型是 *无人居住的*。如果我们仍然设法获得一个无人居住类型的值，这是一个逻辑矛盾，因此，任何事情都会随之而来（记住 [ex falso quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion)） .\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:617
#, no-wrap
msgid ""
"So this is how to express that a proposition does not hold: We\n"
"state that if it *would* hold, this would lead to a contradiction.\n"
"The most natural way to express a contradiction in Idris is\n"
"to return a value of type `Void`:\n"
msgstr "所以这就是如何表达一个命题不成立：我们声明如果它 *会* 成立，这将导致矛盾。在 Idris 中表达矛盾最自然的方式是返回一个 `Void` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:618
#, no-wrap
msgid ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"
msgstr ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:628
#, no-wrap
msgid ""
"See how this is a provably total implementation of the\n"
"given type: A function from `1 + 1 = 3` to `Void`. We\n"
"implement this by pattern matching, and there is only\n"
"one constructor to match on, which leads to an impossible\n"
"case.\n"
msgstr "看看这是如何证明给定类型的完整实现：从 `1 + 1 = 3` 到 `Void` 的函数。我们通过模式匹配来实现这一点，并且只有一个构造函数可以匹配，这导致了一种不可能的情况。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:633
#, no-wrap
msgid ""
"We can also use contradictory statements to proof other such\n"
"statements. For instance, here is a proof that if the lengths\n"
"of two lists are not the same, then the two list can't be\n"
"the same either:\n"
msgstr "我们还可以使用相互矛盾的陈述来证明其他此类陈述。例如，这是一个证明，如果两个列表的长度不同，那么这两个列表也不可能相同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:634
#, no-wrap
msgid ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"
msgstr ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:642
#, no-wrap
msgid ""
"This is cumbersome to write and pretty hard to read, so there\n"
"is function `Not` in the prelude to express the same thing\n"
"more naturally:\n"
msgstr "这写起来很麻烦，读起来也很难，所以 prelude 中有函数`Not` 可以更自然地表达同样的事情：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:643
#, no-wrap
msgid ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"
msgstr ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:651
#, no-wrap
msgid ""
"Actually, this is just a specialized version of the contraposition of\n"
"`cong`: If from `a = b` follows `f a = f b`, then from\n"
"`not (f a = f b)` follows `not (a = b)`:\n"
msgstr "实际上，这只是 `cong` 对偶的一个特殊版本：如果从 `a = b` 遵循 `f a = f b`，那么从 `not (f a = f b)` 遵循 `not (a = b)`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:652
#, fuzzy, no-wrap
msgid ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun x = fun $ cong f x\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:657
#, no-wrap
msgid "Interface `Uninhabited`"
msgstr "`Uninhabited` 接口"

#. type: Plain text
#: ../src/Tutorial/Eq.md:664
#, no-wrap
msgid ""
"There is an interface in the *Prelude* for uninhabited types: `Uninhabited`\n"
"with its sole function `uninhabited`. Have a look at its documentation at\n"
"the REPL. You will see, that there is already an impressive number\n"
"of implementations available, many of which involve data type\n"
"`Equal`.\n"
msgstr "*Prelude* 中有一个接口用于无人居住类型：`Uninhabited`，其唯一函数是`uninhabited`。在 REPL 中查看它的文档。您会看到，已经有大量可用的实现，其中许多涉及数据类型 `Equal`。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:667
#, no-wrap
msgid ""
"We can use `Uninhabited`, to for instance express that\n"
"the empty schema is not equal to a non-empty schema:\n"
msgstr "我们可以使用 `Uninhabited`，例如表示空模式不等于非空模式：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:668
#, no-wrap
msgid ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"
msgstr ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:678
#, no-wrap
msgid ""
"There is a related function you need to know about: `absurd`, which\n"
"combines `uninhabited` with `void`:\n"
msgstr "有一个相关的函数你需要知道：`absurd`，它结合了`uninhabited`和`void`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:679
#, no-wrap
msgid ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"
msgstr ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:685
#, no-wrap
msgid "Decidable Equality"
msgstr "可判定等式"

#. type: Plain text
#: ../src/Tutorial/Eq.md:703
#, no-wrap
msgid ""
"When we implemented `sameColType`, we got a proof that two\n"
"column types are indeed the same, from which we could figure out,\n"
"whether two schemata are identical. The types guarantee\n"
"we do not generate any false positives: If we generate a value\n"
"of type `SameSchema s1 s2`, we have a proof that `s1` and `s2`\n"
"are indeed identical.\n"
"However, `sameColType` and thus `sameSchema` could theoretically\n"
"still produce false negatives by returning `Nothing`\n"
"although the two values are identical. For instance,\n"
"we could implement `sameColType` in such a way that it\n"
"always returns `Nothing`. This would be in agreement with\n"
"the types, but definitely not what we want. So, here is\n"
"what we'd like to do in order to get yet stronger guarantees:\n"
"We'd either want to return a proof that the two schemata\n"
"are the same, or return a proof that the two schemata\n"
"are not the same. (Remember that `Not a` is an alias for `a -> Void`).\n"
msgstr "当我们实现 `sameColType` 时，我们得到了两个列类型确实相同的证据，由此我们可以确定两个模式是否相同。这些类型保证我们不会产生任何误报：如果我们产生一个类型为 `SameSchema s1 s2` 的值，我们就有证据证明 `s1` 和 `s2` 确实是完全相同的。但是，`sameColType` 和 `sameSchema` 理论上仍然可以通过返回 `Nothing` 来产生假阴性，尽管这两个值是相同的。例如，我们可以实现 `sameColType`，使其始终返回 `Nothing`。这将与类型一致，但绝对不是我们想要的。因此，为了获得更强有力的保证，我们想要做以下事情：我们要么想要返回两个模式相同的证明，要么返回两个模式不同的证明。 （记住 `Not a` 是 `a -> Void` 的别名）。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:708
#, no-wrap
msgid ""
"We call a property, which either holds or leads to a\n"
"contradiction a *decidable property*, and the *Prelude*\n"
"exports data type `Dec prop`, which encapsulates this\n"
"distinction.\n"
msgstr "我们将持有或导致矛盾的属性称为 *可判定属性*，而 *Prelude* 导出数据类型 `Dec prop`，它封装了这种区别。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:710
#, no-wrap
msgid "Here is a way to encode this for `ColType`:\n"
msgstr "这是为 `ColType` 编码的一种方法：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:711
#, no-wrap
msgid ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"
msgstr ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:741
#, no-wrap
msgid ""
"First, note how we could use a pattern match in a single\n"
"argument lambda directly. This is sometimes called the\n"
"*lambda case* style, named after an extension of the Haskell\n"
"programming language. If we use the `SameCT` constructor\n"
"in the pattern match, Idris is forced to try and unify for instance\n"
"`Float` with `I64`. This is not possible, so the case as\n"
"a whole is impossible.\n"
msgstr "首先，请注意我们如何直接在单个参数 lambda 中使用模式匹配。这有时被称为 *lambda case* 风格，以 Haskell 编程语言的扩展命名。如果我们在模式匹配中使用 `SameCT` 构造函数，Idris 将被迫尝试将 `Float` 与 `I64` 统一起来。这是不可能的，所以整个案例是不可能的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:749
#, no-wrap
msgid ""
"Yet, this was pretty cumbersome to implement. In order to\n"
"convince Idris we did not miss a case,\n"
"there is no way around treating every possible pairing\n"
"of constructors explicitly.\n"
"However, we get *much* stronger guarantees out of this: We\n"
"can no longer create false positives *or* false negatives, and\n"
"therefore, `decSameColType` is provably correct.\n"
msgstr "然而，这实现起来相当麻烦。为了让 Idris 相信我们没有遗漏任何一个案例，没有办法明确地处理每个可能的构造函数配对。然而，我们 *必须* 得到更强的保证：我们不能再创建误报 *或* 误报，因此 `decSameColType` 可证明是正确的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:752
#, no-wrap
msgid ""
"Doing the same thing for schemata requires some utility functions,\n"
"the types of which we can figure out by placing some holes:\n"
msgstr "对模式做同样的事情需要一些实用函数，我们可以通过放置一些孔来找出它们的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:753
#, no-wrap
msgid ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"
msgstr ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:770
#, no-wrap
msgid ""
"The first two cases are not too hard. The type of `decss1` is\n"
"`SameSchema [] (y :: ys) -> Void`, which you can easily verify\n"
"at the REPL. But that's just `uninhabited`, specialized to\n"
"`SameSchema [] (y :: ys)`, and this we already implemented\n"
"further above. The same goes for `decss2`.\n"
msgstr "前两种情况并不难。 `decss1` 的类型是 `SameSchema [] (y :: ys) -> Void`，您可以在 REPL 轻松验证。但这只是 `uninhabited`，专门用于 `SameSchema [] (y :: ys)`，我们已经在上面进一步实现了这一点。 `decss2` 也是如此。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:777
#, no-wrap
msgid ""
"The other two cases are harder, so I already filled in as much stuff\n"
"as possible. We know that we want to return a `No`, if either the\n"
"heads or tails are provably distinct. The `No` holds a\n"
"function, so I already added a lambda, leaving a hole only for\n"
"the return value. Here are the type and - more important -\n"
"context of `decss3`:\n"
msgstr "其他两种情况比较难，所以我已经尽可能多地填写了。我们知道我们想要返回一个 `No`，如果可以证明正面或反面是不同的。 `No` 包含一个函数，所以我已经添加了一个 lambda，只为返回值留了一个洞。以下是 `decss3` 的类型和更重要的上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:778
#, no-wrap
msgid ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"
msgstr ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:797
#, no-wrap
msgid ""
"The types of `contra` and `prf` are what we need here:\n"
"If `xs` and `ys` are distinct, then `y :: xs` and `y :: ys`\n"
"must be distinct as well. This is the contraposition of the\n"
"following statement: If `x :: xs` is the same as `y :: ys`,\n"
"then `xs` and `ys` are the same as well. We must therefore\n"
"implement a lemma, which proves that the *cons* constructor\n"
"is [*injective*](https://en.wikipedia.org/wiki/Injective_function):\n"
msgstr "`contra` 和 `prf` 的类型是我们这里需要的：如果 `xs` 和 `ys` 是不同的，那么 `y :: xs` 和 `y :: ys` 也必须不同。这是以下语句的对置：如果 `x :: xs` 与 `y :: ys` 相同，则 `xs` 和 `ys` 也一样。因此，我们必须实现一个引理，证明 *cons* 构造函数是 [*injective*](https://en.wikipedia.org/wiki/Injective_function)：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:798
#, no-wrap
msgid ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"
msgstr ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:809
#, no-wrap
msgid ""
"We can now pass `prf` to `consInjective` to extract a value of\n"
"type `SameSchema xs ys`, which we then pass to `contra` in\n"
"order to get the desired value of type `Void`.\n"
"With these observations and utilities, we can now implement\n"
"`decSameSchema`:\n"
msgstr "我们现在可以将 `prf` 传递给 `consInjective` 以提取 `SameSchema xs ys` 类型的值，然后我们将其传递给 `contra` 以便获取类型 `Void` 的所需值。有了这些观察和实用程序，我们现在可以实现 `decSameSchema`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:810
#, no-wrap
msgid ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"
msgstr ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:825
#, no-wrap
msgid ""
"There is an interface called `DecEq` exported by module `Decidable.Equality`\n"
"for types for which we can implement a decision procedure for propositional\n"
"equality. We can implement this to figure out if two values are equal or not.\n"
msgstr "有一个名为 `DecEq` 的接口由模块 `Decidable.Equality` 导出，用于我们可以为命题相等性实现决策过程的类型。我们可以实现它来确定两个值是否相等。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:830
#, no-wrap
msgid ""
"Show that there can be no non-empty vector of `Void`\n"
"by writing a corresponding implementation of uninhabited\n"
msgstr "通过编写 uninhabited 的对应实现，证明 `Void` 不存在非空向量\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:832
#, no-wrap
msgid "Generalize exercise 1 for all uninhabited element types.\n"
msgstr "将练习 1 推广到所有无人居住的元素类型。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:835
#, no-wrap
msgid ""
"Show that if `a = b` cannot hold, then `b = a` cannot hold\n"
"either.\n"
msgstr "证明如果 `a = b` 不能成立，那么 `b = a` 也不能成立。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:838
#, no-wrap
msgid ""
"Show that if `a = b` holds, and `b = c` cannot hold, then\n"
"`a = c` cannot hold either.\n"
msgstr "证明如果 `a = b` 成立，而 `b = c` 不能成立，那么 `a = c` 也不能成立。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:841
#, no-wrap
msgid ""
"Implement `Uninhabited` for `Crud i a`. Try to be\n"
"as general as possible.\n"
msgstr "为 `Crud i a` 实现 `Uninhabited`。尽量笼统。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:851
#, no-wrap
msgid "Implement `DecEq` for `ColType`.\n"
msgstr "为 `ColType` 实现 `DecEq`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:856
#, no-wrap
msgid ""
"Implementations such as the one from exercise 6 are cumbersome\n"
"to write as they require a quadratic number of pattern matches\n"
"with relation to the number of data constructors. Here is a\n"
"trick how to make this more bearable.\n"
msgstr "练习 6 中的实现这样的实现写起来很麻烦，因为它们需要与数据构造函数的数量相关的二次模式匹配。这是一个技巧，如何使它更容易忍受。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Eq.md:859
#, no-wrap
msgid ""
"Implement a function `ctNat`, which assigns every value\n"
"of type `ColType` a unique natural number.\n"
msgstr "实现一个函数 `ctNat`，它为每个 `ColType` 类型的值分配一个唯一的自然数。\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Eq.md:864
#, no-wrap
msgid ""
"Proof that `ctNat` is injective.\n"
"Hint: You will need to pattern match on the `ColType`\n"
"values, but four matches should be enough to satisfy the\n"
"coverage checker.\n"
msgstr "证明 `ctNat` 是单射的。提示：您将需要对 `ColType` 值进行模式匹配，但四个匹配应该足以满足覆盖检查器的要求。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Eq.md:869
#, no-wrap
msgid ""
"In your implementation of `DecEq` for `ColType`,\n"
"use `decEq` on the result of applying both column\n"
"types to `ctNat`, thus reducing it to only two lines of\n"
"code.\n"
msgstr "在为 `ColType` 实现 `DecEq` 时，在将两种列类型应用于 `ctNat` 的结果上使用 `decEq`，从而将其减少到仅两行代码。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:877
#, no-wrap
msgid ""
"   We will later talk about `with` rules: Special forms of\n"
"   dependent pattern matches, that allow us to learn something\n"
"   about the shape of function arguments by performing\n"
"   computations on them. These will allow us to use\n"
"   a similar technique as shown here to implement `DecEq`\n"
"   requiring only `n` pattern matches\n"
"   for arbitrary sum types with `n` data constructors.\n"
msgstr ""
"   我们稍后会讨论 `with` 规则：\n"
"   依赖模式匹配，让我们学习一些东西\n"
"   通过执行关于函数参数的形状\n"
"   对它们进行计算。这些将允许我们使用\n"
"   与此处所示类似的技术来实现 `DecEq`\n"
"   只需要 `n` 模式匹配\n"
"   对于具有 `n` 数据构造函数的任意和类型。\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:878
#, no-wrap
msgid "Rewrite Rules"
msgstr "重写规则"

#. type: Plain text
#: ../src/Tutorial/Eq.md:888
#, no-wrap
msgid ""
"One of the most important use cases of propositional equality\n"
"is to replace or *rewrite* existing types, which Idris can't\n"
"unify automatically otherwise. For instance,\n"
"the following is no problem:\n"
"Idris know that `0 + n` equals `n`, because `plus` on\n"
"natural numbers is implemented by pattern matching on the\n"
"first argument. The two vector lengths therefore unify\n"
"just fine.\n"
msgstr "命题等式的最重要用例之一是替换或 *重写* 现有类型，否则 Idris 无法自动统一这些类型。例如，以下是没有问题的： Idris 知道 `0 + n` 等于 `n`，因为自然数上的 `plus` 是通过第一个参数的模式匹配实现的.因此，这两个向量长度可以很好地统一。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:889
#, no-wrap
msgid ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"
msgstr ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:899
#, fuzzy, no-wrap
msgid ""
"However, the example below can't be implemented as easily\n"
"(try it!), because Idris can't figure out on its own\n"
"that the two lengths unify.\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:900
#, no-wrap
msgid ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"
msgstr ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:909
#, no-wrap
msgid ""
"Probably for the first time we realize, just how little\n"
"Idris knows about the laws of arithmetics. Idris is able\n"
"to unify values when\n"
msgstr "可能是我们第一次意识到，Idris 对算术定律知之甚少。Idris 能够统一值\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, no-wrap
msgid "all values in a computation are known at compile time\n"
msgstr "计算中的所有值在编译期都是已知的\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, no-wrap
msgid ""
"one expression follows directly from the other due\n"
"to the pattern matches used in a function's implementation.\n"
msgstr "由于函数实现中使用的模式匹配，一个表达式直接跟随另一个表达式。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:917
#, no-wrap
msgid ""
"In expression `n + 0`,  not all values are known (`n` is a variable),\n"
"and `(+)` is implemented by pattern matching on the first\n"
"argument, about which we know nothing here.\n"
msgstr "在表达式 `n + 0` 中，并非所有值都是已知的（`n` 是一个变量），并且 `(+)` 是通过第一个参数的模式匹配来实现的，我们在这里一无所知。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:923
#, no-wrap
msgid ""
"However, we can teach Idris. If we can proof that the two\n"
"expressions are equivalent, we can replace one expression\n"
"for the other, so that the two unify again. Here is a lemma\n"
"and its proof, that `n + 0` equals `n`, for all natural\n"
"numbers `n`.\n"
msgstr "但是，我们可以教 Idris 。如果我们可以证明这两个表达式是等价的，我们可以用一个表达式替换另一个表达式，从而使两者再次统一。这是一个引理及其证明，对于所有自然数 `n`，`n + 0` 等于 `n`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:924
#, no-wrap
msgid ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"
msgstr ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:935
#, no-wrap
msgid ""
"Note, how the base case is trivial: Since there are no\n"
"variables left, Idris can immediately figure out that\n"
"`0 + 0 = 0`. In the recursive case, it can be instructive\n"
"to replace `cong S` with a hole and look at its type\n"
"and context to figure out how to proceed.\n"
msgstr "请注意，基本情况是多么微不足道：由于没有剩余变量，Idris 可以立即计算出 `0 + 0 = 0`。在递归的情况下，将 `cong S` 替换为一个孔并查看其类型和上下文以确定如何进行可能是有益的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:940
#, no-wrap
msgid ""
"The *Prelude* exports function `replace` for substituting one\n"
"variable in a term by another, based on a proof of equality.\n"
"Make sure to inspect its type first before looking at the\n"
"example below:\n"
msgstr "*Prelude* 导出函数 `replace` 用于根据等式证明将一个变量中的一个变量替换为另一个变量。在查看下面的示例之前，请务必先检查其类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:941
#, no-wrap
msgid ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"
msgstr ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:952
#, no-wrap
msgid ""
"As you can see, we *replace* a value of type `p x` with a value\n"
"of type `p y` based on a proof that `x = y`,\n"
"where `p` is a function from some type `t` to\n"
"`Type`, and `x` and `y` are values of type `t`. In our\n"
"`replaceVect` example, `t` equals `Nat`, `x` equals `n + 0`,\n"
"`y` equals `n`, and `p` equals `\\k => Vect k a`.\n"
msgstr "如您所见，我们将 `p x` 类型的值 *替换* 为 `p y` 类型的值，基于 `x = y` 的证明, 其中 `p` 是从某种类型 `t` 到 `Type` 的函数，而 `x` 和 `y` 是类型 `t` 的值。在我们的 `replaceVect` 示例中，`t` 等于 `Nat`，`x` 等于 `n + 0`，`y` 等于 `n`，`p` 等于 `\\k => Vect k a`。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:960
#, no-wrap
msgid ""
"Using `replace` directly is not very convenient, because Idris\n"
"can often not infer the value of `p` on its own. Indeed, we\n"
"had to give its type explicitly in `replaceVect`.\n"
"Idris therefore provides special syntax for such *rewrite rules*,\n"
"which will get desugared to calls to `replace` with all the\n"
"details filled in for us. Here is an implementation\n"
"of `replaceVect` with a rewrite rule:\n"
msgstr "直接使用 `replace` 不是很方便，因为 Idris 往往无法自行推断出 `p` 的值。实际上，我们必须在 `replaceVect` 中明确给出它的类型。因此，Idris 为此类 *重写规则* 提供了特殊语法，这将减少对 `replace` 的调用，并为我们填写所有详细信息。这是 `replaceVect` 的实现，带有重写规则：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:961
#, no-wrap
msgid ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"
msgstr ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:970
#, no-wrap
msgid ""
"One source of confusion is that *rewrite* uses proofs\n"
"of equality the other way round: Given an `y = x`\n"
"it replaces `p x` with `p y`. Hence the need to call `sym`\n"
"in our implementation above.\n"
msgstr "混淆的一个来源是 *rewrite* 使用相反的相等性证明：给定 `y = x` 它将 `p x` 替换为 `p y` .因此需要在我们上面的实现中调用 `sym`。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:971
#, no-wrap
msgid "Use Case: Reversing Vectors"
msgstr "用例：反转向量"

#. type: Plain text
#: ../src/Tutorial/Eq.md:982
#, no-wrap
msgid ""
"Rewrite rules are often required when we perform interesting\n"
"type-level computations. For instance,\n"
"we have already seen many interesting examples of functions\n"
"operating on `Vect`, which allowed us to keep track of the\n"
"exact lengths of the vectors involved, but one key\n"
"functionality has been missing from our discussions so far,\n"
"and for good reasons: Function `reverse`. Here is a possible\n"
"implementation, which is how `reverse` is implemented for\n"
"lists:\n"
msgstr "当我们执行有趣的类型级计算时，通常需要重写规则。例如，我们已经看到了许多在 `Vect` 上运行的函数的有趣示例，这使我们能够跟踪所涉及向量的确切长度，但是到目前为止我们的讨论中缺少一个关键函数，并且有充分的理由：函数 `reverse`。这是一个可能的实现，这就是 `reverse` 对列表的实现方式：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:984
#, no-wrap
msgid ""
"revOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto' xs []        = xs\n"
"revOnto' xs (x :: ys) = revOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = revOnto' []\n"
msgstr ""
"revOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto' xs []        = xs\n"
"revOnto' xs (x :: ys) = revOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = revOnto' []\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:997
#, no-wrap
msgid ""
"As you might have guessed, this will not compile as the\n"
"length indices in the two clauses of `revOnto'` do\n"
"not unify.\n"
msgstr "正如您可能已经猜到的那样，这不会通过编译，因为 `revOnto'` 的两个子句中的长度索引不统一。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1001
#, no-wrap
msgid ""
"The *nil* case is a case we've already seen above:\n"
"Here `n` is zero, because the second vector is empty,\n"
"so we have to convince Idris once again that `m + 0 = m`:\n"
msgstr "*nil* 情况是我们在上面已经看到的情况：这里 `n` 为零，因为第二个向量是空的，所以我们必须再次说服 Idris `m + 0 = m`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1002
#, no-wrap
msgid ""
"revOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto xs [] = rewrite addZeroRight m in xs\n"
msgstr ""
"revOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto xs [] = rewrite addZeroRight m in xs\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1013
#, no-wrap
msgid ""
"The second case is more complex. Here, Idris fails to unify\n"
"`S (m + len)` with `m + S len`, where `len` is the length of\n"
"`ys`, the tail of the second vector. Module `Data.Nat`\n"
"provides many proofs about arithmetic operations on natural\n"
"numbers, one of which is `plusSuccRightSucc`. Here's its\n"
"type:\n"
msgstr "第二种情况更复杂。这里，Idris 无法统一 `S (m + len)` 和 `m + S len`，其中 `len` 是 `ys` 的长度，第二个向量的尾部。模块 `Data.Nat` 提供了许多关于自然数算术运算的证明，其中之一是 `plusSuccRightSucc`。这是它的类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:1014
#, no-wrap
msgid ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"
msgstr ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1032
#, no-wrap
msgid ""
"In our case, we want to replace `S (m + len)` with `m + S len`,\n"
"so we will need the version with arguments flipped. However, there\n"
"is one more obstacle: We need to invoke `plusSuccRightSucc`\n"
"with the length of `ys`, which is not given as an implicit\n"
"function argument of `revOnto`. We therefore need to pattern\n"
"match on `n` (the length of the second vector), in order to\n"
"bind the length of the tail to a variable. Remember, that we\n"
"are allowed to pattern match on an erased argument only if\n"
"the constructor used follows from a match on another, unerased,\n"
"argument (`ys` in this case). Here's the implementation of the\n"
"second case:\n"
msgstr "在我们的例子中，我们想用 `m + S len` 替换 `S (m + len)`，所以我们需要参数翻转的版本。但是，还有一个障碍：我们需要调用长度为 `ys` 的 `plusSuccRightSucc`，它没有作为 `revOnto` 的隐式函数参数给出。因此，我们需要对 `n`（第二个向量的长度）进行模式匹配，以便将尾部的长度绑定到一个变量。请记住，只有当使用的构造函数遵循另一个未擦除参数（在本例中为 `ys`）的匹配时，我们才允许对已擦除参数进行模式匹配。下面是第二种情况的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1033
#, no-wrap
msgid ""
"revOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in revOnto (x :: xs) ys\n"
msgstr ""
"revOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in revOnto (x :: xs) ys\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1043
#, no-wrap
msgid ""
"I know from my own experience that this can be highly confusing\n"
"at first. If you use Idris as a general purpose programming language\n"
"and not as a proof assistant, you probably will not have to use\n"
"rewrite rules too often. Still, it is important to know that they\n"
"exist, as they allow us to teach complex equivalences to Idris.\n"
msgstr "我从我自己的经验中知道，起初这可能会让人非常困惑。如果您将 Idris 用作通用编程语言而不是证明助手，您可能不必经常使用重写规则。尽管如此，重要的是要知道它们的存在，因为它们允许我们向 Idris 教授复杂的等价性。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:1044
#, no-wrap
msgid "A Note on Erasure"
msgstr "关于擦除的说明"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1055
#, no-wrap
msgid ""
"Single value data types like `Unit`, `Equal`, or `SameSchema` have\n"
"not runtime relevance, as values of these types are always identical.\n"
"We can therefore always use them as erased function arguments while\n"
"still being able to pattern match on these values.\n"
"For instance, when you look at the type of `replace`, you will see\n"
"that the equality proof is an erased argument.\n"
"This allows us to run arbitrarily complex computations to produce\n"
"such values without fear of these computations slowing down\n"
"the compiled Idris program.\n"
msgstr "`Unit`、`Equal` 或 `SameSchema` 等单值数据类型没有运行时相关性，因为这些类型的值始终相同。因此，我们始终可以将它们用作已擦除的函数参数，同时仍然能够对这些值进行模式匹配。例如，当您查看 `replace` 的类型时，您会看到等式证明是一个已删除的参数。这允许我们运行任意复杂的计算来生成这样的值，而不必担心这些计算会减慢编译的 Idris 程序。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:1059
#, no-wrap
msgid "Implement `plusSuccRightSucc` yourself.\n"
msgstr "自己实现 `plusSuccRightSucc`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:1061
#, no-wrap
msgid "Proof that `minus n n` equals zero for all natural numbers `n`.\n"
msgstr "证明 `minus n n` 对于所有自然数 `n` 等于 0。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:1063
#, no-wrap
msgid "Proof that `minus n 0` equals n for all natural numbers `n`\n"
msgstr "证明 `minus n 0` 等于 n 对于所有自然数 `n`\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:1066
#, no-wrap
msgid ""
"Proof that `n * 1 = n` and `1 * n = n`\n"
"for all natural numbers `n`.\n"
msgstr "证明对于所有自然数 `n`，都有 `n * 1 = n` 和 `1 * n = n` 。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:1069
#, no-wrap
msgid ""
"Proof that addition of natural numbers is\n"
"commutative.\n"
msgstr "证明自然数的加法是可交换的。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:1071
#, no-wrap
msgid "Implement a tail-recursive version of `map` for vectors.\n"
msgstr "为向量实现 `map` 的尾递归版本。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:1073
#, no-wrap
msgid "Proof the following proposition:\n"
msgstr "证明以下命题：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1074
#, no-wrap
msgid ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"
msgstr ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Eq.md:1084
#, no-wrap
msgid ""
"Use the proof from exercise 7 to implement again a function\n"
"for  zipping two `Table`s, this time using a rewrite rule\n"
"plus `Data.HList.(++)` instead of custom function `appRows`.\n"
msgstr "使用练习 7 中的证明再次实现压缩两个 `Table` 的函数，这次使用重写规则加上 `Data.HList.(++)` 而不是自定义函数 `appRows`。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1096
#, no-wrap
msgid ""
"The concept of *types as propositions, values as proofs* is\n"
"a very powerful tool for writing provably correct programs. We\n"
"will therefore spend some more time defining data types\n"
"for describing contracts between values, and values of these\n"
"types as proofs that the contracts hold. This will allow\n"
"us to describe necessary pre- and postconditions for our functions,\n"
"thus reducing the need to return a `Maybe` or other failure type,\n"
"because due to the restricted input, our functions can no longer\n"
"fail.\n"
msgstr "*类型作为命题，值作为证明* 的概念是编写可证明正确的程序的非常强大的工具。因此，我们将花更多时间定义数据类型来描述值之间的协议，并将这些类型的值作为合约持有的证据。这将允许我们为我们的函数描述必要的前置条件和后置条件，从而减少返回 `Maybe` 或其他故障类型的需要，因为由于输入受限，我们的函数不能再失败。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1098
#, no-wrap
msgid "[Next chapter](./Predicates.md)\n"
msgstr ""
