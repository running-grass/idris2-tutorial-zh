# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, no-wrap
msgid "Functions Part 1"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
#, no-wrap
msgid ""
"Idris is a *functional* programming language. This means,\n"
"that functions are its main form of abstraction (unlike for\n"
"instance in an object oriented language like Java, where\n"
"*objects* and *classes* are the main form of abstraction). It also\n"
"means that we expect Idris to make it very easy for\n"
"us to compose and combine functions to create new\n"
"functions. In fact, in Idris functions are *first class*:\n"
"Functions can take other functions as arguments and\n"
"can return functions as their results.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
#, no-wrap
msgid ""
"We already learned about the basic shape of top level\n"
"function declarations in Idris in the [introduction](Intro.md),\n"
"so we will continue from what we learned there.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, no-wrap
msgid "Functions with more than one Argument"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
#, no-wrap
msgid ""
"Let's implement a function, which checks if its three\n"
"`Integer` arguments form a\n"
"[Pythagorean triple](https://en.wikipedia.org/wiki/Pythagorean_triple).\n"
"We get to use a new operator for this: `==`, the equality\n"
"operator.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
#, no-wrap
msgid ""
"Let's give this a spin at the REPL before we talk a bit\n"
"about the types:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
#, no-wrap
msgid ""
"The implementation looks a bit like a mathematical equation:\n"
"We list the arguments on the left hand side of `=` and describe the\n"
"computation(s) to perform with them on the right hand\n"
"side. Function implementations in functional programming\n"
"languages often have this more mathematical look compared\n"
"to implementations in imperative  languages, which often\n"
"describe not *what* to compute, but *how* to\n"
"compute it by describing an algorithm as a sequence of\n"
"imperative statements. We will later see that this\n"
"imperative style is also available in Idris, but whenever\n"
"possible we prefer the declarative style.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
#, no-wrap
msgid ""
"As can be seen in the REPL example, functions can be invoked\n"
"by passing the arguments separated by whitespace. No parentheses\n"
"are necessary unless one of the expressions we pass as the\n"
"function's arguments contains itself additional whitespace.\n"
"This comes in very handy when we apply functions\n"
"only partially (see later in this chapter).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
#, no-wrap
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive\n"
"data type built into the Idris language but just a custom\n"
"data type that you could have written yourself. We will\n"
"learn more about declaring new data types in the\n"
"next chapter.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, no-wrap
msgid "Function Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
#, no-wrap
msgid ""
"Functions can be combined in several ways, the most direct\n"
"probably being the dot operator:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
#, no-wrap
msgid "Give this a try at the REPL! Does it do what you'd expect?\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
#, no-wrap
msgid ""
"We could have implemented `squareTimes2` without using\n"
"the dot operator as follows:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
#, no-wrap
msgid ""
"We can conveniently chain several functions using the\n"
"dot operator to write more complex functions:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
#, no-wrap
msgid ""
"This will first multiply the argument by four, then square\n"
"it twice before converting it to a string (`show`) and\n"
"reversing the resulting `String` (functions `show` and\n"
"`reverse` are part of the Idris *Prelude* and as such are\n"
"available in every Idris program).\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, no-wrap
msgid "Higher-order Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
#, no-wrap
msgid ""
"Functions can take other functions as arguments. This is\n"
"an incredibly powerful concept and we can go crazy with\n"
"this very easily. But for sanity's sake, we'll start\n"
"slowly:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
#, no-wrap
msgid ""
"First `isEven` uses the `mod` function to check, whether\n"
"an integer is divisible by two. But the interesting function\n"
"is `testSquare`. It takes two arguments: The first argument\n"
"is of type *function from `Integer` to `Bool`*, and the second\n"
"of type `Integer`. This second argument is squared before\n"
"being passed to the first argument. Again, give this a go\n"
"at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
#, no-wrap
msgid ""
"Take your time to understand what's going on here. We pass\n"
"function `isEven` as an argument to `testSquare`. The\n"
"second argument is an integer, which will first be squared\n"
"and then passed to `isEven`. While this is not very interesting,\n"
"we will see lots of use cases for passing functions as\n"
"arguments to other functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
#, no-wrap
msgid ""
"I said above, we could go crazy pretty easily.\n"
"Consider for instance the following example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:645
#, no-wrap
msgid "And at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
#, no-wrap
msgid ""
"You might be surprised about this behavior, so we'll try\n"
"and break it down. The following two expressions are identical\n"
"in their behavior:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
#, no-wrap
msgid ""
"So, `square` raises its argument to the 2nd power,\n"
"`twice square` raises it to its 4th power (by invoking\n"
"`square` twice in succession),\n"
"`twice (twice square)` raises it to its 16th power\n"
"(by invoking `twice square` twice in succession),\n"
"and so on, until `twice (twice (twice (twice square)))`\n"
"raises it to its 65536th power resulting in an impressively\n"
"huge result.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, no-wrap
msgid "Currying"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
#, no-wrap
msgid ""
"Once we start using higher-order functions, the concept\n"
"of partial function application (also called *currying*\n"
"after mathematician and logician Haskell Curry) becomes\n"
"very important.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
#, no-wrap
msgid "Load this file in a REPL session and try the following:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
#, no-wrap
msgid ""
"We already used partial function application in our `twice`\n"
"examples above to get some impressive results with very\n"
"little code.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, no-wrap
msgid "Anonymous Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
#, no-wrap
msgid ""
"Sometimes we'd like to pass a small custom function to\n"
"a higher-order function without bothering to write a\n"
"top level definition. For instance, in the following example,\n"
"function `someTest` is very specific and probably not\n"
"very useful in general, but we'd still like to pass it\n"
"to higher-order function `testSquare`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
#, no-wrap
msgid "Here's, how to pass it to `testSquare`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
#, no-wrap
msgid ""
"Instead of defining and using `someTest`, we can use an\n"
"anonymous function:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
#, no-wrap
msgid ""
"Note that, in a lambda, arguments are not annotated with types,\n"
"so Idris has to be able to infer them from the current context.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, no-wrap
msgid "Operators"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
#, no-wrap
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into\n"
"the language, but are just regular Idris function with\n"
"some special support for using them in infix notation.\n"
"When we don't use operators in infix notation, we have\n"
"to wrap them in parentheses.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
#, no-wrap
msgid ""
"When you mix infix operators in an expression, those with\n"
"a higher priority bind more tightly. For instance, `(+)`\n"
"is left associated with a priority of 8, while `(*)`\n"
"is left associated with a priority of 9. Hence,\n"
"`a * b + c` is the same as `(a * b) + c` instead of `a * (b + c)`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, no-wrap
msgid "Operator Sections"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
#, no-wrap
msgid ""
"Operators can be partially applied just like regular\n"
"functions. In this case, the whole expression has to\n"
"be wrapped in parentheses and is called an *operator\n"
"section*. Here are two examples:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
#, no-wrap
msgid ""
"One exception where operator sections will not work is\n"
"with the *minus* operator `(-)`. Here is an example to\n"
"demonstrate this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
#, no-wrap
msgid ""
"This is just a higher-order function applying the number ten\n"
"to its function argument. This works very well in the following\n"
"example:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (* 2)\n"
"20\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
#, no-wrap
msgid ""
"However, if we want to subtract five from ten, the following\n"
"will fail:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
#, no-wrap
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal\n"
"instead of an operator section. In this special case, we therefore\n"
"have to use an anonymous function instead:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
#, no-wrap
msgid ""
"In Idris, it is possible to use infix notation for\n"
"regular binary functions, by wrapping them in backticks.\n"
"It is even possible to define a precedence (fixity) for\n"
"these and use them in operator sections, just like regular\n"
"operators:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
#, no-wrap
msgid ""
"Here is a list of important operators exported by the *Prelude*.\n"
"Most of these are *constrained*, that is they work only\n"
"for types implementing a certain *interface*. Don't worry\n"
"about this right now. We will learn about interfaces in due\n"
"time, and the operators behave as they intuitively should.\n"
"For instance, addition and multiplication work for all\n"
"numeric types, comparison operators work for almost all\n"
"types in the *Prelude* with the exception of functions.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(.)`: Function composition\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(+)`: Addition\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(*)`: Multiplication\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(-)`: Subtraction\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(/)`: Division\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(==)` : True, if two values are equal\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(/=)` : True, if two values are not equal\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`($)`: Function application\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
#, no-wrap
msgid ""
"The most special of the above is the last one. It has a\n"
"priority of 0, so all other operators bind more tightly.\n"
"In addition, function application binds more tightly, so\n"
"this can be used to reduce the number of parentheses\n"
"required. For instance, instead of writing\n"
"`isTriple 3 4 (2 + 3 * 1)` we can write\n"
"`isTriple 3 4 $ 2 + 3 * 1`,\n"
"which is exactly the same. Sometimes, this helps readability,\n"
"sometimes, it doesn't. The important thing to remember is\n"
"that `fun $ x y` is just the same as `fun (x y)`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
#, no-wrap
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot\n"
"operator and dropping the second arguments (have a look at the\n"
"implementation of `squareTimes2` to get an idea where this should\n"
"lead you). This highly concise\n"
"way of writing function implementations is sometimes called\n"
"*point-free style* and is often the preferred way of writing\n"
"small utility functions.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
#, no-wrap
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven`\n"
"from above and `not` (from the Idris *Prelude*). Use point-free style.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
#, no-wrap
msgid ""
"Declare and implement function `isSquareOf`, which checks whether\n"
"its first `Integer` argument is the square of the second argument.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
#, no-wrap
msgid ""
"Declare and implement function `isSmall`, which checks whether\n"
"its `Integer` argument is less than or equal to 100. Use one of the\n"
"comparison operators `<=` or `>=` in your implementation.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
#, no-wrap
msgid ""
"Declare and implement function `absIsSmall`, which checks whether\n"
"the absolute value of its `Integer` argument is less than or equal to 100.\n"
"Use functions `isSmall` and `abs` (from the Idris *Prelude*) in your implementation,\n"
"which should be in point-free style.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
#, no-wrap
msgid ""
"In this slightly extended exercise we are going to implement\n"
"some utilities for working with `Integer` predicates (functions\n"
"from `Integer` to `Bool`). Implement the following higher-order\n"
"functions (use boolean operators `&&`, `||`, and function `not` in\n"
"your implementations):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
#, no-wrap
msgid ""
"As explained above, Idris allows us to define our own infix operators.\n"
"Even better, Idris supports *overloading* of function names,\n"
"that is, two functions or operators can have the same\n"
"name, but different types and implementations.\n"
"Idris will make use of the\n"
"types to distinguish between equally named operators and\n"
"functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
#, no-wrap
msgid "What we learned in this chapter:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
#, no-wrap
msgid ""
"Please note, that function and operator names in a module\n"
"must be unique. In order to define two functions with the same\n"
"name, they have to be declared in distinct modules. If Idris\n"
"is not able to decide, which of the two functions to use, we\n"
"can help name resolution by prefixing a function with\n"
"(a part of) its *namespace*:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
#, no-wrap
msgid ""
"In the [next section](DataTypes.md), we will learn how to define\n"
"our own data types and how to construct and deconstruct\n"
"values of these new types. We will also learn about\n"
"generic types and functions.\n"
msgstr ""
