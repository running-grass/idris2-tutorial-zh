# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 20:00+0800\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "练习第 1 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "练习第 2 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "练习第 3 部分"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429
#: ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1040 ../src/Tutorial/Traverse.md:308
#, no-wrap
msgid ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"
msgstr ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:803 ../src/Tutorial/Traverse.md:122
msgid "Let's give this a go at the REPL:"
msgstr "让我们在 REPL 上试一试："

#. type: Title #
#: ../src/Tutorial/Traverse.md:1
#, no-wrap
msgid "Effectful Traversals"
msgstr "遍历副作用"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:11
msgid ""
"In this chapter, we are going to bring our treatment of the higher-kinded "
"interfaces in the *Prelude* to an end. In order to do so, we will continue "
"developing the CSV reader we started implementing in chapter [Functor and "
"Friends](Functor.md). I moved some of the data types and interfaces from "
"that chapter to their own modules, so we can import them here without the "
"need to start from scratch."
msgstr ""
"在本章中，我们将带来 *Prelude* 中更高种类的接口。为此，我们将继续开发\n"
"我们在 [函子和朋友](Functor.md) 章节中开始实现的 CSV 阅读器。我移动了一些\n"
"该章的数据类型和接口到他们自己的模块，所以我们可以在这里导入它们而无需从头开"
"始。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:16
msgid ""
"Note that unlike in our original CSV reader, we will use `Validated` instead "
"of `Either` for handling exceptions, since this will allow us to accumulate "
"all errors when reading a CSV file."
msgstr ""
"请注意，与我们原来的 CSV 阅读器不同，我们将使用 `Validated` 而不是 `Either` "
"处理异常，\n"
"因为这将使我们能够累积读取 CSV 文件时的所有错误。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:17
#, no-wrap
msgid ""
"module Tutorial.Traverse\n"
"\n"
"import Data.HList\n"
"import Data.IORef\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Validated\n"
"import Data.Vect\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Traverse\n"
"\n"
"import Data.HList\n"
"import Data.IORef\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Validated\n"
"import Data.Vect\n"
"import Text.CSV\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Traverse.md:31
#, no-wrap
msgid "Reading CSV Tables"
msgstr "读取 CSV 表"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:37
msgid ""
"We stopped developing our CSV reader with function `hdecode`, which allows "
"us to read a single line in a CSV file and decode it to a heterogeneous "
"list.  As a reminder, here is how to use `hdecode` at the REPL:"
msgstr ""
"我们停止开发具有 `hdecode` 函数—的 CSV 阅读器，它允许我们在 CSV 文件中读取单"
"行并将其解码为异构列表。\n"
"提醒一下，这里是如何在 REPL 中使用 `hdecode` ："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:38
#, no-wrap
msgid ""
"Tutorial.Traverse> hdecode [Bool,String,Bits8] 1 \"f,foo,12\"\n"
"Valid [False, \"foo\", 12]\n"
msgstr ""
"Tutorial.Traverse> hdecode [Bool,String,Bits8] 1 \"f,foo,12\"\n"
"Valid [False, \"foo\", 12]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:51
msgid ""
"The next step will be to parse a whole CSV table, represented as a list of "
"strings, where each string corresponds to one of the table's rows.  We will "
"go about this stepwise as there are several aspects about doing this "
"properly. What we are looking for - eventually - is a function of the "
"following type (we are going to implement several versions of this function, "
"hence the numbering):"
msgstr ""
"下一步将解析整个 CSV 表作为字符串列表，其中每个字符串对应一个\n"
"表的一行。\n"
"我们将逐步进行，因为有几个方面可以正确地做到这一点。我们正在寻找的——最终—— 是"
"以下类型的函数（我们将实现这个函数的几个版本，因此我们给它了编号）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:52
#, no-wrap
msgid ""
"hreadTable1 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
msgstr ""
"hreadTable1 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:61
msgid ""
"In our first implementation, we are not going to care about line numbers:"
msgstr ""
"在我们的第一个实现中，我们不会关心\n"
"关于行号的事情："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:62
#, no-wrap
msgid ""
"hreadTable1 _  []        = pure []\n"
"hreadTable1 ts (s :: ss) = [| hdecode ts 0 s :: hreadTable1 ts ss |]\n"
msgstr ""
"hreadTable1 _  []        = pure []\n"
"hreadTable1 ts (s :: ss) = [| hdecode ts 0 s :: hreadTable1 ts ss |]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:72
msgid ""
"Note, how we can just use applicative syntax in the implementation of "
"`hreadTable1`. To make this clearer, I used `pure []` on the first line "
"instead of the more specific `Valid []`. In fact, if we used `Either` or "
"`Maybe` instead of `Validated` for error handling, the implementation of "
"`hreadTable1` would look exactly the same."
msgstr ""
"注意，我们如何在 `hreadTable1` 的实现中使用应用函子语法。为了更清楚，我优先使"
"用 `pure []` 而不是更具体的 `Valid []`。事实上，如果我们使用\n"
"`Either` 或 `Maybe` 而不是 `Validated` 用于错误处理，\n"
"`hreadTable1` 的实现看起来完全一样。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:81
#, no-wrap
msgid ""
"The question is: Can we extract a pattern to abstract over\n"
"from this observation? What we do in `hreadTable1` is running\n"
"an effectful computation of type `String -> Validated CSVError (HList ts)`\n"
"over a list of strings, so that the result is a list of `HList ts`\n"
"wrapped in a `Validated CSVError`. The first step of abstraction\n"
"should be to use type parameters for the input and output:\n"
"Run a computation of type `a -> Validated CSVError b` over a\n"
"list `List a`:\n"
msgstr ""
"问题是：我们从这个观察中可以提取一个模式来抽象吗？我们在 `hreadTable1` 中运行字符串列表上的副作用计算，类型为 `String -> Validated CSVError (HList ts)`，因此结果是 `HList ts` 的列表\n"
"且包裹在 `Validated CSVError` 中。抽象的第一步\n"
"应该是对输入和输出使用类型参数：\n"
"在列表 `List a` 上运行 `a -> Validated CSVError b` 类型的计算：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:82
#, no-wrap
msgid ""
"traverseValidatedList :  (a -> Validated CSVError b)\n"
"                      -> List a\n"
"                      -> Validated CSVError (List b)\n"
"traverseValidatedList _ []        = pure []\n"
"traverseValidatedList f (x :: xs) = [| f x :: traverseValidatedList f xs |]\n"
"\n"
"hreadTable2 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable2 ts = traverseValidatedList (hdecode ts 0)\n"
msgstr ""
"traverseValidatedList :  (a -> Validated CSVError b)\n"
"                      -> List a\n"
"                      -> Validated CSVError (List b)\n"
"traverseValidatedList _ []        = pure []\n"
"traverseValidatedList f (x :: xs) = [| f x :: traverseValidatedList f xs |]\n"
"\n"
"hreadTable2 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable2 ts = traverseValidatedList (hdecode ts 0)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:104
msgid ""
"But our observation was, that the implementation of `hreadTable1` would be "
"exactly the same if we used `Either CSVError` or `Maybe` as our effect types "
"instead of `Validated CSVError`.  So, the next step should be to abstract "
"over the *effect type*.  We note, that we used applicative syntax (idiom "
"brackets and `pure`) in our implementation, so we will need to write a "
"function with an `Applicative` constraint on the effect type:"
msgstr ""
"但我们的观察是，如果我们使用 `Either CSVError` 或 `Maybe` 代替 `Validated "
"CSVError`作为我们的副作用类型，`hreadTable1` 的实现将完全相同。\n"
"所以，下一步应该是对*副作用类型*进行抽象。\n"
"我们注意到，我们使用了应用函子语法（习语括号和\n"
"`pure`) 在我们的实现中，所以我们需要编写\n"
"关于副作用类型具有 `Applicative` 约束的函数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:105
#, no-wrap
msgid ""
"traverseList :  Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverseList _ []        = pure []\n"
"traverseList f (x :: xs) = [| f x :: traverseList f xs |]\n"
"\n"
"hreadTable3 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable3 ts = traverseList (hdecode ts 0)\n"
msgstr ""
"traverseList :  Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverseList _ []        = pure []\n"
"traverseList f (x :: xs) = [| f x :: traverseList f xs |]\n"
"\n"
"hreadTable3 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable3 ts = traverseList (hdecode ts 0)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:120
msgid ""
"Note, how the implementation of `traverseList` is exactly the same as the "
"one of `traverseValidatedList`, but the types are more general and "
"therefore, `traverseList` is much more powerful."
msgstr ""
"注意，`traverseList`的实现和 `traverseValidatedList` 完全一样的，但类型更通"
"用\n"
"因此，`traverseList` 更强大。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:123
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,0\"]\n"
"Valid [[False, 12], [True, 0]]\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,1000\"]\n"
"Invalid (FieldError 0 2 \"1000\")\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"1,12\",\"t,1000\"]\n"
"Invalid (Append (FieldError 0 1 \"1\") (FieldError 0 2 \"1000\"))\n"
msgstr ""
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,0\"]\n"
"Valid [[False, 12], [True, 0]]\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,1000\"]\n"
"Invalid (FieldError 0 2 \"1000\")\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"1,12\",\"t,1000\"]\n"
"Invalid (Append (FieldError 0 1 \"1\") (FieldError 0 2 \"1000\"))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:139
msgid ""
"This works very well already, but note how our error messages do not yet "
"print the correct line numbers. That's not surprising, as we are using a "
"dummy constant in our call to `hdecode`.  We will look at how we can come up "
"with the line numbers on the fly when we talk about stateful computations "
"later in this chapter.  For now, we could just manually annotate the lines "
"with their numbers and pass a list of pairs to `hreadTable`:"
msgstr ""
"这已经很好用了，但请注意我们的错误消息是如何做的，\n"
"尚未打印正确的行号。这并不奇怪，\n"
"因为我们在调用 `hdecode` 时使用了一个虚拟常量。\n"
"我们将研究如何得出行号\n"
"当我们在本章后面讨论有状态计算时会飞起来。\n"
"现在，我们可以手动注释这些行号并将一对列表传递给 `hreadTable`："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:140
#, no-wrap
msgid ""
"hreadTable4 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List (Nat, String)\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable4 ts = traverseList (uncurry $ hdecode ts)\n"
msgstr ""
"hreadTable4 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List (Nat, String)\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable4 ts = traverseList (uncurry $ hdecode ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:154
msgid ""
"If this is the first time you came across function `uncurry`, make sure you "
"have a look at its type and try to figure out why it is used here. There are "
"several utility functions like this in the *Prelude*, such as `curry`, "
"`uncurry`, `flip`, or even `id`, all of which can be very useful when "
"working with higher-order functions."
msgstr ""
"如果这是你第一次遇到函数 `uncurry`，\n"
"确保您查看了它的类型并尝试找出它在这里被使用的原因。在 *Prelude* 中有几个这样"
"的实用函数，如`curry`、`uncurry`、`flip`，还有 `id`，所有这些在处理高阶函数时"
"都非常有用。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:157
msgid ""
"While not perfect, this version at least allows us to verify at the REPL "
"that the line numbers are passed to the error messages correctly:"
msgstr ""
"虽然不完美，但这个版本至少允许我们在 REPL 进行验证行号正确传递的错误消息："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:158
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable4 [Bool,Bits8] [(1,\"t,1000\"),(2,\"1,100\")]\n"
"Invalid (Append (FieldError 1 2 \"1000\") (FieldError 2 1 \"1\"))\n"
msgstr ""
"Tutorial.Traverse> hreadTable4 [Bool,Bits8] [(1,\"t,1000\"),(2,\"1,100\")]\n"
"Invalid (Append (FieldError 1 2 \"1000\") (FieldError 2 1 \"1\"))\n"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:163
#, no-wrap
msgid "Interface Traversable"
msgstr "Traversable 接口"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:172
msgid ""
"Now, here is an interesting observation: We can implement a function like "
"`traverseList` for other container types as well. You might think that's "
"obvious, given that we can convert container types to lists via function "
"`toList` from interface `Foldable`. However, while going via `List` might be "
"feasible in some occasions, it is undesirable in general, as we loose typing "
"information. For instance, here is such a function for `Vect`:"
msgstr ""
"现在，这里有一个有趣的现象：我们可以实现一个函数，\n"
"像其他容器类型的 `traverseList` 那样。你可能认为那是很简单的，鉴于我们可以通"
"过以下方式将容器类型转换为列表\n"
"来自接口 `Foldable` 的函数 `toList`。然而，通过 `List` 来处理在某些情况下可能"
"是可行的，一般来说，我们会丢失了类型信息。例如，这里 `Vect` 的函数是这样的："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:173
#, no-wrap
msgid ""
"traverseVect' : Applicative f => (a -> f b) -> Vect n a -> f (List b)\n"
"traverseVect' fun = traverseList fun . toList\n"
msgstr ""
"traverseVect' : Applicative f => (a -> f b) -> Vect n a -> f (List b)\n"
"traverseVect' fun = traverseList fun . toList\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:182
msgid ""
"Note how we lost all information about the structure of the original "
"container type. What we are looking for is a function like `traverseVect'`, "
"which keeps this type level information: The result should be a vector of "
"the same length as the input."
msgstr ""
"注意我们是如何丢失了所有关于原始容器类型结构的信息的。我们要找的是像"
"`traverseVect'` 的一个函数，它保留了这个类型级别的信息：结果应该是与输入长度"
"相同的向量。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:183
#, no-wrap
msgid ""
"traverseVect : Applicative f => (a -> f b) -> Vect n a -> f (Vect n b)\n"
"traverseVect _   []        = pure []\n"
"traverseVect fun (x :: xs) = [| fun x :: traverseVect fun xs |]\n"
msgstr ""
"traverseVect : Applicative f => (a -> f b) -> Vect n a -> f (Vect n b)\n"
"traverseVect _   []        = pure []\n"
"traverseVect fun (x :: xs) = [| fun x :: traverseVect fun xs |]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:193
msgid ""
"That's much better! And as I wrote above, we can easily get the same for "
"other container types like `List1`, `SnocList`, `Maybe`, and so on.  As "
"usual, some derived functions will follow immediately from `traverseXY`.  "
"For instance:"
msgstr ""
"那好多了！正如我上面写的，我们可以很容易地得到相同的对于其他容器类型，如 "
"`List1`、`SnocList`、`Maybe` 等。\n"
"像往常一样，一些派生函数将紧跟在 `traverseXY` 之后。例如："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:194
#, no-wrap
msgid ""
"sequenceList : Applicative f => List (f a) -> f (List a)\n"
"sequenceList = traverseList id\n"
msgstr ""
"sequenceList : Applicative f => List (f a) -> f (List a)\n"
"sequenceList = traverseList id\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:202
msgid ""
"All of this calls for a new interface, which is called `Traversable` and is "
"exported from the *Prelude*. Here is its definition (with primes for "
"disambiguation):"
msgstr ""
"所有这些都需要一个新的接口，它被称为\n"
"`Traversable` 并从 *Prelude* 导出。这是\n"
"它的定义（用单引号来消除歧义）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:203
#, no-wrap
msgid ""
"interface Functor t => Foldable t => Traversable' t where\n"
"  traverse' : Applicative f => (a -> f b) -> t a -> f (t b)\n"
msgstr ""
"interface Functor t => Foldable t => Traversable' t where\n"
"  traverse' : Applicative f => (a -> f b) -> t a -> f (t b)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:214
msgid ""
"Function `traverse` is one of the most abstract and versatile functions "
"available from the *Prelude*. Just how powerful it is will only become clear "
"once you start using it over and over again in your code. However, it will "
"be the goal of the remainder of this chapter to show you several diverse and "
"interesting use cases."
msgstr ""
"函数 `traverse` 是*Prelude* 提供的函数中最抽象和通用的函数之一。到底有多强"
"大\n"
"只有在你的代码中一遍又一遍开始使用它才会变得清晰。然而，这将是本章剩余部分的"
"目标，会向您展示几个多样而有趣的用例。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:229
msgid ""
"For now, we will quickly focus on the degree of abstraction.  Function "
"`traverse` is parameterized over no less than four parameters: The container "
"type `t` (`List`, `Vect n`, `Maybe`, to just name a few), the effect type "
"(`Validated e`, `IO`, `Maybe`, and so on), the input element type `a`, and "
"the output element type `b`. Considering that the libraries bundled with the "
"Idris project export more than 30 data types with an implementation of "
"`Applicative` and more than ten traversable container types, there are "
"literally hundreds of combinations for traversing a container with an "
"effectful computation. This number gets even larger once we realize that "
"traversable containers - like applicative functors - are closed under "
"composition (see the exercises and the final section in this chapter)."
msgstr ""
"现在，我们将快速关注抽象程度。\n"
"函数 `traverse` 参数化不小于四个参数：容器类型 `t` (`List`, `Vect n`,\n"
"`Maybe`，仅举几例），副作用类型（`Validated e`，\n"
"`IO`、`Maybe` 等），输入元素类型 `a` 和输出元素类型 `b`。考虑到库\n"
"与 Idris 基础库导出 30 多种数据类型\n"
"具有 `Applicative` 的实现和十多个\n"
"可遍历的容器类型，实际上有数百个\n"
"副作用遍历容器的组合计算。一旦我们意识到可遍历的容器——比如应用函子——\n"
"可以在组合下闭合，这个数字会变得更大\n"
"（见练习和\n"
"本章的最后一节）。"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:230
#, no-wrap
msgid "Traversable Laws"
msgstr "Traversable 定律"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:233
msgid "There are two laws function `traverse` must obey:"
msgstr "函数 `traverse` 必须遵守两个定律："

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
msgid ""
"`traverse (Id . f) = Id . map f`: Traversing over the `Identity` monad is "
"just functor `map`."
msgstr ""
"`traverse (Id . f) = Id . map f`: 遍历 `Identity` 单子等同于使用 `map`."

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
msgid ""
"`traverse (MkComp . map f . g) = MkComp . map (traverse f) . traverse g`: "
"Traversing with a composition of effects must be the same when being done in "
"a single traversal (left hand side) or a sequence of two traversals (right "
"hand side)."
msgstr ""
"`traverse (MkComp . map f . g) = MkComp . map (traverse f) . traverse g`：在"
"单个遍历（左侧）或两个遍历序列（右侧）中完成时，具有副作用组合的遍历必须相"
"同。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:246
msgid ""
"Since `map id = id` (functor's identity law), we can derive from the first "
"law that `traverse Id = Id`. This means, that `traverse` must not change the "
"size or shape of the container type, nor is it allowed to change the order "
"of elements."
msgstr ""
"由于`map id = id`（函子恒等律），我们可以从第一定律推导出\n"
"`traverse Id = Id`。这意味着\n"
"`traverse`不得改变容器的大小或形状\n"
"类型，也不允许改变元素的顺序。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:253
msgid ""
"It is interesting that `Traversable` has a `Functor` constraint. Proof that "
"every `Traversable` is automatically a `Functor` by implementing `map` in "
"terms of `traverse`."
msgstr ""
"有趣的是 `Traversable` 有一个 `Functor` 约束。通过根据 `traverse` 实现 "
"`map`，证明每个 `Traversable` 自动成为 `Functor`。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:255
#, no-wrap
msgid "   Hint: Remember `Control.Monad.Identity`.\n"
msgstr "   提示：记住 `Control.Monad.Identity`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:259
msgid ""
"Likewise, proof that every `Traversable` is a `Foldable` by implementing "
"`foldMap` in terms of `Traverse`."
msgstr ""
"同样，通过根据 `Traverse` 实现 `foldMap` 来证明每个 `Traversable` 都是 "
"`Foldable`。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:261
#, no-wrap
msgid "   Hint: Remember `Control.Applicative.Const`.\n"
msgstr "   提示：记住 `Control.Applicative.Const`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:264
msgid ""
"To gain some routine, implement `Traversable'` for `List1`, `Either e`, and "
"`Maybe`."
msgstr "开始一些例行程序，请为 `List1`、`Ei` 和 `Maybe` 实现 `Traversable'`。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:266
msgid "Implement `Traversable` for `List01 ne`:"
msgstr "为 `List01 ne` 实现 `Traversable`："

#. type: Bullet: '5. '
#: ../src/Tutorial/Traverse.md:275
msgid ""
"Implement `Traversable` for rose trees. Try to satisfy the totality checker "
"without cheating."
msgstr "为玫瑰树实现 `Traversable`。尝试在不作弊的情况下满足完全性检查器。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:276
#, no-wrap
msgid ""
"   record Tree a where\n"
"     constructor Node\n"
"     value  : a\n"
"     forest : List (Tree a)\n"
msgstr ""
"   record Tree a where\n"
"     constructor Node\n"
"     value  : a\n"
"     forest : List (Tree a)\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Traverse.md:284
msgid "Implement `Traversable` for `Crud i`:"
msgstr "为 `Crud i` 实现 `Traversable`："

#. type: Bullet: '7. '
#: ../src/Tutorial/Traverse.md:294
msgid "Implement `Traversable` for `Response e i`:"
msgstr "为 `Response e i` 实现 `Traversable`："

#. type: Bullet: '8. '
#: ../src/Tutorial/Traverse.md:307
msgid ""
"Like `Functor`, `Applicative` and `Foldable`, `Traversable` is closed under "
"composition. Proof this by implementing `Traversable` for `Comp` and "
"`Product`:"
msgstr ""
"与 `Functor`、`Applicative` 和 `Foldable` 一样，`Traversable` 在组合下是封闭"
"的。通过为 `Comp` 和 `Product` 实现 `Traversable` 来证明这一点："

#. type: Title ##
#: ../src/Tutorial/Traverse.md:319
#, no-wrap
msgid "Programming with State"
msgstr "用状态编程"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:324
msgid ""
"Let's go back to our CSV reader. In order to get reasonable error messages, "
"we'd like to tag each line with its index:"
msgstr ""
"让我们回到我们的 CSV 阅读器。为了合理\n"
"错误消息，我们想用索引来标记每一行："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:325
#, no-wrap
msgid "zipWithIndex : List a -> List (Nat, a)\n"
msgstr "zipWithIndex : List a -> List (Nat, a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:331
msgid ""
"It is, of course, very easy to come up with an ad hoc implementation for "
"this:"
msgstr "当然，很容易想出一个临时的实现："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:332
#, no-wrap
msgid ""
"zipWithIndex = go 1\n"
"  where go : Nat -> List a -> List (Nat,a)\n"
"        go _ []        = []\n"
"        go n (x :: xs) = (n,x) :: go (S n) xs\n"
msgstr ""
"zipWithIndex = go 1\n"
"  where go : Nat -> List a -> List (Nat,a)\n"
"        go _ []        = []\n"
"        go n (x :: xs) = (n,x) :: go (S n) xs\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:344
msgid ""
"While this is perfectly fine, we should still note that we might want to do "
"the same thing with the elements of trees, vectors, non-empty lists and so "
"on.  And again, we are interested in whether there is some form of "
"abstraction we can use to describe such computations."
msgstr ""
"虽然这很好，但我们仍然应该注意到\n"
"我们可能想对树、向量、非空列表等的元素做同样的事情。\n"
"再一次，我们感兴趣的是是否有一些\n"
"我们可以使用抽象形式来描述此类计算。"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:345
#, no-wrap
msgid "Mutable References in Idris"
msgstr "Idris 中的可变引用"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:352
msgid ""
"Let us for a moment think about how we'd do such a thing in an imperative "
"language. There, we'd probably define a local (mutable) variable to keep "
"track of the current index, which would then be increased while iterating "
"over the list in a `for`- or `while`-loop."
msgstr ""
"让我们考虑一下我们会如何做这样的事情\n"
"在命令式语言中。在那里，我们可能会定义\n"
"一个局部（可变）变量，用于跟踪当前\n"
"索引，然后在遍历列表时增加\n"
"在 `for`- 或 `while`-循环中。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:363
msgid ""
"In Idris, there is no such thing as mutable state.  Or is there? Remember, "
"how we used a mutable reference to simulate a data base connection in an "
"earlier exercise. There, we actually used some truly mutable state. However, "
"since accessing or modifying a mutable variable is not a referential "
"transparent operation, such actions have to be performed within `IO`.  Other "
"than that, nothing keeps us from using mutable variables in our code. The "
"necessary functionality is available from module `Data.IORef` from the "
"*base* library."
msgstr ""
"在 Idris 中，没有可变状态之类的东西。\n"
"或者有吗？请记住，我们如何在早期模拟数据库连接练习中使用可变引用。在那里，我"
"们实际上使用了一些真正可变的\n"
"状态。但是，由于访问或修改一个可变\n"
"变量不是引用透明操作，\n"
"此类操作必须在 `IO` 内执行。\n"
"除此之外，没有什么能阻止我们在我们代码中使用可变变量。必要的函数可从 *base* "
"库中的模块 `Data.IORef` 获得。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:367
msgid ""
"As a quick exercise, try to implement a function, which - given an `IORef "
"Nat` - pairs a value with the current index and increases the index "
"afterwards."
msgstr ""
"作为一个快速练习，尝试实现一个函数，它 - 给定 `IORef Nat` - 将值与当前值配"
"对\n"
"索引并在之后增加索引。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:369
msgid "Here's how I would do this:"
msgstr "下面看我将如何做到这一点："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:370
#, no-wrap
msgid ""
"pairWithIndexIO : IORef Nat -> a -> IO (Nat,a)\n"
"pairWithIndexIO ref va = do\n"
"  ix <- readIORef ref\n"
"  writeIORef ref (S ix)\n"
"  pure (ix,va)\n"
msgstr ""
"pairWithIndexIO : IORef Nat -> a -> IO (Nat,a)\n"
"pairWithIndexIO ref va = do\n"
"  ix <- readIORef ref\n"
"  writeIORef ref (S ix)\n"
"  pure (ix,va)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:387
#, no-wrap
msgid ""
"Note, that every time we *run* `pairWithIndexIO ref`, the\n"
"natural number stored in `ref` is incremented by one.\n"
"Also, look at the type of `pairWithIndexIO ref`: `a -> IO (Nat,a)`.\n"
"We want to apply this effectful computation to each element\n"
"in a list, which should lead to a new list wrapped in `IO`,\n"
"since all of this describes a single computation with side\n"
"effects. But this is *exactly* what function `traverse` does: Our\n"
"input type is `a`, our output type is `(Nat,a)`, our\n"
"container type is `List`, and the effect type is `IO`!\n"
msgstr ""
"注意，每次我们 *运行* `pairWithIndexIO ref`，\n"
"`ref` 中存储的自然数加一。\n"
"另外，查看 `pairWithIndexIO ref` 的类型：`a -> IO (Nat,a)`。\n"
"我们希望将这种副作用的计算应用于在一个列表中每个元素，这应该会导致一个包含在 `IO` 中的新列表，\n"
"因为所有这些都描述了一个单一的计算\n"
"副作用。但这 *正是* `traverse` 的作用：我们的\n"
"输入类型是 `a`，我们的输出类型是 `(Nat,a)`，我们的\n"
"容器类型为`List`，副作用类型为`IO`！\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:388
#, no-wrap
msgid ""
"zipListWithIndexIO : IORef Nat -> List a -> IO (List (Nat,a))\n"
"zipListWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""
"zipListWithIndexIO : IORef Nat -> List a -> IO (List (Nat,a))\n"
"zipListWithIndexIO ref = traverse (pairWithIndexIO ref)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:397
msgid ""
"Now *this* is really powerful: We could apply the same function to *any* "
"traversable data structure. It therefore makes absolutely no sense to "
"specialize `zipListWithIndexIO` to lists only:"
msgstr ""
"现在 *这个* 真的很强大：我们可以应用相同的函数\n"
"到 *任意* 可遍历的数据结构。因此它使\n"
"将 `zipListWithIndexIO` 专门用于\n"
"仅列出："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:398
#, no-wrap
msgid ""
"zipWithIndexIO : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""
"zipWithIndexIO : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO ref = traverse (pairWithIndexIO ref)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:405
msgid ""
"To please our intellectual minds even more, here is the same function in "
"point-free style:"
msgstr ""
"为了更取悦我们的智力，这里是\n"
"无参风格的相同函数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:406
#, no-wrap
msgid ""
"zipWithIndexIO' : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO' = traverse . pairWithIndexIO\n"
msgstr ""
"zipWithIndexIO' : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO' = traverse . pairWithIndexIO\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:413
msgid ""
"All that's left to do now is to initialize a new mutable variable before "
"passing it to `zipWithIndexIO`:"
msgstr ""
"现在剩下要做的就是在将其传递给 `zipWithIndexIO` 之前初始化一个新的可变变量："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:414
#, no-wrap
msgid ""
"zipFromZeroIO : Traversable t => t a -> IO (t (Nat,a))\n"
"zipFromZeroIO ta = newIORef 0 >>= (`zipWithIndexIO` ta)\n"
msgstr ""
"zipFromZeroIO : Traversable t => t a -> IO (t (Nat,a))\n"
"zipFromZeroIO ta = newIORef 0 >>= (`zipWithIndexIO` ta)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:420
msgid "Quickly, let's give this a go at the REPL:"
msgstr "很快，让我们在 REPL 上试一试："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:421
#, no-wrap
msgid ""
"> :exec zipFromZeroIO {t = List} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
"> :exec zipFromZeroIO (Just 12) >>= printLn\n"
"Just (0, 12)\n"
"> :exec zipFromZeroIO {t = Vect 2} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
msgstr ""
"> :exec zipFromZeroIO {t = List} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
"> :exec zipFromZeroIO (Just 12) >>= printLn\n"
"Just (0, 12)\n"
"> :exec zipFromZeroIO {t = Vect 2} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:432
msgid ""
"Thus, we solved the problem of tagging each element with its index once and "
"for all for all traversable container types."
msgstr ""
"因此，对于所有可遍历的容器类型，我们解决了用索引一次性标记每个元素的问题。"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:433
#, no-wrap
msgid "The State Monad"
msgstr "状态单子"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:441
msgid ""
"Alas, while the solution presented above is elegant and performs very well, "
"it still carries its `IO` stain, which is fine if we are already in `IO` "
"land, but unacceptable otherwise. We do not want to make our otherwise pure "
"functions much harder to test and reason about just for a simple case of "
"stateful element tagging."
msgstr ""
"唉，虽然上面提出的解决方案很优雅，表现也非常好，但它仍然带有 `IO` 污渍，\n"
"如果我们已经在 `IO` 土地上就还好，否则这是不可接受的。我们不想让我们原本纯粹"
"的函数只是为了一个简单有状态元素标记的情况就让测试和推理变得困难。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:450
msgid ""
"Luckily, there is an alternative to using a mutable reference, which allows "
"us to keep our computations pure and untainted. However, it is not easy to "
"come upon this alternative on one's own, and it can be hard to figure out "
"what's going on here, so I'll try to introduce this slowly.  We first need "
"to ask ourselves what the essence of a \"stateful\" but otherwise pure "
"computation is. There are two essential ingredients:"
msgstr ""
"幸运的是，有一个使用可变引用的替代方法，\n"
"这使我们能够保持我们的计算纯粹和\n"
"不受污染。然而，自己的替代方案要做到这一点并不容易，而且很难弄清楚这是怎么回"
"事，所以我会尝试慢慢介绍。\n"
"我们首先需要问自己 “有状态” 的本质是什么，否则什么是纯计算。那是两个基本成"
"分："

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:458
msgid ""
"Access to the *current* state. In case of a pure function, this means that "
"the function should take the current state as one of its arguments."
msgstr "访问*当前*状态。对于纯函数，这意味着该函数应将当前状态作为其参数之一。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:458
msgid ""
"Ability to communicate the updated state to later stateful computations. In "
"case of a pure function this means, that the function will return a pair of "
"values: The computation's result plus the updated state."
msgstr ""
"能够将更新的状态传达给以后的有状态计算。在纯函数的情况下，这意味着该函数将返"
"回一对值：计算的结果加上更新的状态。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:462
msgid ""
"These two prerequisites lead to the following generic type for a pure, "
"stateful computation operating on state type `st` and producing values of "
"type `a`:"
msgstr ""
"这两个先决条件导致以泛型，\n"
"用于在状态上运行的纯的有状态计算的类型，输入 `st` 并生成 `a` 类型的值 ："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:463
#, no-wrap
msgid ""
"Stateful : (st : Type) -> (a : Type) -> Type\n"
"Stateful st a = st -> (st, a)\n"
msgstr ""
"Stateful : (st : Type) -> (a : Type) -> Type\n"
"Stateful st a = st -> (st, a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:470
msgid ""
"Our use case is pairing elements with indices, which can be implemented as a "
"pure, stateful computation like so:"
msgstr ""
"我们的用例是将元素与索引配对，\n"
"可以实现为纯粹的、有状态的计算，如下所示："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:471
#, no-wrap
msgid ""
"pairWithIndex' : a -> Stateful Nat (Nat,a)\n"
"pairWithIndex' v index = (S index, (index,v))\n"
msgstr ""
"pairWithIndex' : a -> Stateful Nat (Nat,a)\n"
"pairWithIndex' v index = (S index, (index,v))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:479
msgid ""
"Note, how we at the same time increment the index, returning the incremented "
"value as the new state, while pairing the first argument with the original "
"index."
msgstr ""
"注意，我们如何同时增加索引，返回\n"
"增加的值作为新状态，同时配对第一个参数与原始索引。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:488
msgid ""
"Now, here is an important thing to note: While `Stateful` is a useful type "
"alias, Idris in general does *not* resolve interface implementations for "
"function types. If we want to write a small library of utility functions "
"around such a type, it is therefore best to wrap it in a single-constructor "
"data type and use this as our building block for writing more complex "
"computations. We therefore introduce record `State` as a wrapper for pure, "
"stateful computations:"
msgstr ""
"现在，需要注意一件重要的事情：虽然 `Stateful` 是一个有用的类型别名，Idris 通"
"常 *不会* 解析函数类型的接口实现。如果我们想围绕这种类型编写一个小型实用函数"
"库，\n"
"因此，最好将其包装在单构造函数数据类型中，并且\n"
"使用它作为我们编写更复杂计算的构建块。因此，我们将记录 `State` 引入为\n"
"纯粹的有状态计算的包装器："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:489
#, no-wrap
msgid ""
"record State st a where\n"
"  constructor ST\n"
"  runST : st -> (st,a)\n"
msgstr ""
"record State st a where\n"
"  constructor ST\n"
"  runST : st -> (st,a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:496
msgid "We can now implement `pairWithIndex` in terms of `State` like so:"
msgstr "我们现在可以用 `State` 来实现 `pairWithIndex` ，如下所示："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:497
#, no-wrap
msgid ""
"pairWithIndex : a -> State Nat (Nat,a)\n"
"pairWithIndex v = ST $ \\index => (S index, (index, v))\n"
msgstr ""
"pairWithIndex : a -> State Nat (Nat,a)\n"
"pairWithIndex v = ST $ \\index => (S index, (index, v))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:505
msgid ""
"In addition, we can define some more utility functions. Here's one for "
"getting the current state without modifying it (this corresponds to "
"`readIORef`):"
msgstr ""
"此外，我们还可以定义更多的工具函数。这里是一个用于获取当前状态而不修改它的函"
"数（这对应于 `readIORef`）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:506
#, no-wrap
msgid ""
"get : State st st\n"
"get = ST $ \\s => (s,s)\n"
msgstr ""
"get : State st st\n"
"get = ST $ \\s => (s,s)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:513
msgid ""
"Here are two others, for overwriting the current state. These corresponds to "
"`writeIORef` and `modifyIORef`:"
msgstr ""
"这是另外两个，用于覆盖当前状态。这些\n"
"对应 `writeIORef` 和 `modifyIORef`："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:514
#, no-wrap
msgid ""
"put : st -> State st ()\n"
"put v = ST $ \\_ => (v,())\n"
"\n"
"modify : (st -> st) -> State st ()\n"
"modify f = ST $ \\v => (f v,())\n"
msgstr ""
"put : st -> State st ()\n"
"put v = ST $ \\_ => (v,())\n"
"\n"
"modify : (st -> st) -> State st ()\n"
"modify f = ST $ \\v => (f v,())\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:524
msgid ""
"Finally, we can define three functions in addition to `runST` for running "
"stateful computations"
msgstr "最后，我们可以定义除用于运行有状态计算 `runST` 之外的三个函数"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:525
#, no-wrap
msgid ""
"runState : st -> State st a -> (st, a)\n"
"runState = flip runST\n"
"\n"
"evalState : st -> State st a -> a\n"
"evalState s = snd . runState s\n"
"\n"
"execState : st -> State st a -> st\n"
"execState s = fst . runState s\n"
msgstr ""
"runState : st -> State st a -> (st, a)\n"
"runState = flip runST\n"
"\n"
"evalState : st -> State st a -> a\n"
"evalState s = snd . runState s\n"
"\n"
"execState : st -> State st a -> st\n"
"execState s = fst . runState s\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:542
msgid ""
"All of these are useful on their own, but the real power of `State s` comes "
"from the observation that it is a monad.  Before you go on, please spend "
"some time and try implementing `Functor`, `Applicative`, and `Monad` for "
"`State s` yourself.  Even if you don't succeed, you will have an easier time "
"understanding how the implementations below work."
msgstr ""
"所有这些都是单独有用的，但真正的力量\n"
"`State s` 来自观察它是一个单子。\n"
"在继续之前，请花一些时间尝试自己实现 `Functor`、`Applicative` 和 `Monad` 用"
"于 `State s`。\n"
"即使你没有成功，你也会过得更轻松了解下面的实现是如何工作的。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:543
#, no-wrap
msgid ""
"Functor (State st) where\n"
"  map f (ST run) = ST $ \\s => let (s2,va) = run s in (s2, f va)\n"
"\n"
"Applicative (State st) where\n"
"  pure v = ST $ \\s => (s,v)\n"
"\n"
"  ST fun <*> ST val = ST $ \\s =>\n"
"    let (s2, f)  = fun s\n"
"        (s3, va) = val s2\n"
"     in (s3, f va)\n"
"\n"
"Monad (State st) where\n"
"  ST val >>= f = ST $ \\s =>\n"
"    let (s2, va) = val s\n"
"     in runST (f va) s2\n"
msgstr ""
"Functor (State st) where\n"
"  map f (ST run) = ST $ \\s => let (s2,va) = run s in (s2, f va)\n"
"\n"
"Applicative (State st) where\n"
"  pure v = ST $ \\s => (s,v)\n"
"\n"
"  ST fun <*> ST val = ST $ \\s =>\n"
"    let (s2, f)  = fun s\n"
"        (s3, va) = val s2\n"
"     in (s3, f va)\n"
"\n"
"Monad (State st) where\n"
"  ST val >>= f = ST $ \\s =>\n"
"    let (s2, va) = val s\n"
"     in runST (f va) s2\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:573
msgid ""
"This may take some time to digest, so we come back to it in a slightly "
"advanced exercise. The most important thing to note is, that we use every "
"state value only ever once. We *must* make sure that the updated state is "
"passed to later computations, otherwise the information about state updates "
"is being lost. This can best be seen in the implementation of `Applicative`: "
"The initial state, `s`, is used in the computation of the function value, "
"which will also return an updated state, `s2`, which is then used in the "
"computation of the function argument. This will again return an updated "
"state, `s3`, which is passed on to later stateful computations together with "
"the result of applying `f` to `va`."
msgstr ""
"这可能需要一些时间来消化，所以我们稍后稍微高级的练习时会回顾它。最需要注意的"
"是，\n"
"我们每个状态值只使用一次。我们*必须*确保将更新后的状态传递给以后的计算，否则"
"有关状态更新的信息就会丢失。这个可以最好在 `Applicative` 的实现中看到：初始状"
"态 `s` 用于计算函数值，这也将返回一个更新的状态，`s2` 用于计算函数参数。这将"
"再次返回一个更新的状态，`s3`，它连同将 `f` 应用于 `va` 的结果被传递给以后的有"
"状态计算。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:583
msgid ""
"This sections consists of two extended exercise, the aim of which is to "
"increase your understanding of the state monad.  In the first exercise, we "
"will look at random value generation, a classical application of stateful "
"computations.  In the second exercise, we will look at an indexed version of "
"a state monad, which allows us to not only change the state's value but also "
"its *type* during computations."
msgstr ""
"本节包括两个扩展练习，目的是\n"
"其中是为了增加你对状态单子的理解。\n"
"在第一个练习中，我们将研究随机值生成，\n"
"有状态计算的经典应用。\n"
"在第二个练习中，我们将看基于状态单子的一个索引版本，它允许我们在计算过程中不"
"仅改变状态的值以及它的 *类型*。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:590
msgid ""
"Below is the implementation of a simple pseudo-random number generator. We "
"call this a *pseudo-random* number generator, because the numbers look "
"pretty random but are generated predictably. If we initialize a series of "
"such computations with a truly random seed, most users of our library will "
"not be able to predict the outcome of our computations."
msgstr ""
"下面是一个简单的伪随机数生成器的实现。我们称其为*伪随机*数字生成器，因为这些"
"数字看起来非常随机，但生成是可预测的。如果我们用真正的随机种子初始化一系列这"
"样的计算，我们库的大多数用户将无法预测我们的计算结果。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:591
#, no-wrap
msgid ""
"   rnd : Bits64 -> Bits64\n"
"   rnd seed = fromInteger\n"
"            $ (437799614237992725 * cast seed) `mod` 2305843009213693951\n"
msgstr ""
"   rnd : Bits64 -> Bits64\n"
"   rnd seed = fromInteger\n"
"            $ (437799614237992725 * cast seed) `mod` 2305843009213693951\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:604
#, no-wrap
msgid ""
"   The idea here is that the next pseudo-random number gets\n"
"   calculated from the previous one. But once we think about\n"
"   how we can use these numbers as seeds for computing\n"
"   random values of other types, we realize that these are\n"
"   just stateful computations. We can therefore write\n"
"   down an alias for random value generators as stateful\n"
"   computations:\n"
msgstr "   这里的意思是，下一个伪随机数是从上一个伪随机数计算出来的。但一旦我们考虑如何使用这些数字作为种子来计算其他类型的随机值，我们就会意识到这些只是有状态的计算。因此，我们可以将随机值生成器的别名写为有状态计算：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:605
#, no-wrap
msgid ""
"   Gen : Type -> Type\n"
"   Gen = State Bits64\n"
msgstr ""
"   Gen : Type -> Type\n"
"   Gen = State Bits64\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:617
#, no-wrap
msgid ""
"   Before we begin, please note that `rnd` is not a very strong\n"
"   pseudo-random number generator. It will not generate values in\n"
"   the full 64bit range, nor is it safe to use in cryptographic\n"
"   applications. It is sufficient for our purposes in this chapter,\n"
"   however. Note also, that we could replace `rnd` with a stronger\n"
"   generator without any changes to the functions you will implement\n"
"   as part of this exercise.\n"
msgstr ""
"   在开始之前，请注意 `rnd` 不是很强的\n"
"   伪随机数发生器。它不会在完整的 64 位区间生成值，在密码应用程序中使用也不安全 。然而对我们本章的目的来说足够了，\n"
"   。另请注意，我们可以将 `rnd` 替换为更强的\n"
"   生成器，无需对您将作为本练习的一部分实现的函数进行任何更改\n"
"   。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:622
msgid ""
"Implement `bits64` in terms of `rnd`. This should return the current state, "
"updating it afterwards by invoking function `rnd`. Make sure the state is "
"properly updated, otherwise this won't behave as expected."
msgstr ""
"根据 `rnd` 实现 `bits64`。这应该返回当前状态，然后通过调用函数 `rnd` 对其进行"
"更新。确保状态已正确更新，否则将无法按预期运行。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:626
#, no-wrap
msgid ""
"      ```idris\n"
"      bits64 : Gen Bits64\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      bits64 : Gen Bits64\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:631
#, no-wrap
msgid ""
"      This will be our *only* primitive generator, from which\n"
"      we will derived all the others. Therefore,\n"
"      before you continue, quickly test your implementation of\n"
"      `bits64` at the REPL:\n"
msgstr ""
"      这将是我们的 *仅限* 原语的生成器，从中\n"
"      我们将推导出所有其他的。所以，\n"
"      在你继续之前， 在 REPL 中快速测试你的 `bits64` 实现：\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:636
#, no-wrap
msgid ""
"      ```repl\n"
"      Solutions.Traverse> runState 100 bits64\n"
"      (2274787257952781382, 100)\n"
"      ```\n"
msgstr ""
"      ```repl\n"
"      Solutions.Traverse> runState 100 bits64\n"
"      (2274787257952781382, 100)\n"
"      ```\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:642
msgid ""
"Implement `range64` for generating random values in the range `[0,upper]`. "
"Hint: Use `bits64` and `mod` in your implementation but make sure to deal "
"with the fact that `mod x upper` produces values in the range `[0,upper)`."
msgstr ""
"实现 `range64` 以在 `[0,upper]` 范围内生成随机值。提示：在你的实现中使用 "
"`bits64` 和 `mod` 但确保处理 `mod x upper` 在 `[0,upper)` 区间生成。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:646
#, no-wrap
msgid ""
"      ```idris\n"
"      range64 : (upper : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      range64 : (upper : Bits64) -> Gen Bits64\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:649
#, no-wrap
msgid ""
"      Likewise, implement `interval64` for generating values\n"
"      in the range `[min a b, max a b]`:\n"
msgstr "      同样的, 实现 `interval64` 来生成区间为 `[min a b, max a b]` 的值:\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:653
#, no-wrap
msgid ""
"      ```idris\n"
"      interval64 : (a,b : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      interval64 : (a,b : Bits64) -> Gen Bits64\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:655
#, no-wrap
msgid "      Finally, implement `interval` for arbitrary integral types.\n"
msgstr "      最后，为任意整数类型实现 `interval`。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:659
#, no-wrap
msgid ""
"      ```idris\n"
"      interval : Num n => Cast n Bits64 => (a,b : n) -> Gen n\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      interval : Num n => Cast n Bits64 => (a,b : n) -> Gen n\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:663
#, no-wrap
msgid ""
"      Note, that `interval` will not generate all possible values in\n"
"      the given interval but only such values with a `Bits64`\n"
"      representation in the the range `[0,2305843009213693950]`.\n"
msgstr ""
"      请注意， `interval` 不会生成给定的间隔所有可能的值\n"
"      ，只会生成`[0,2305843009213693950]` 范围内 `Bits64` 的值。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:665
msgid "Implement a generator for random boolean values."
msgstr "实现随机布尔值的生成器。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:670
msgid ""
"Implement a generator for `Fin n`. You'll have to think carefully about "
"getting this one to typecheck and be accepted by the totality checker "
"without cheating.  Note: Have a look at function `Data.Fin.natToFin`."
msgstr ""
"为 `Fin n` 实现一个生成器。您必须仔细考虑如何让这个进行类型检查并在不作弊的情"
"况下被整体检查器接受。注意：查看函数 `Data.Fin.natToFin`。"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:674
msgid ""
"Implement a generator for selecting a random element from a vector of "
"values. Use the generator from exercise 4 in your implementation."
msgstr ""
"实现一个生成器，用于从值向量中选择一个随机元素。在您的实现中使用练习 4 中的生"
"成器。"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:678
msgid ""
"Implement `vect` and `list`. In case of `list`, the first argument should be "
"used to randomly determine the length of the list."
msgstr ""
"实现 `vect` 和 `list`。在 `list` 的情况下，第一个参数应该用于随机确定列表的长"
"度。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:681
#, no-wrap
msgid ""
"      ```idris\n"
"      vect : {n : _} -> Gen a -> Gen (Vect n a)\n"
msgstr ""
"      ```idris\n"
"      vect : {n : _} -> Gen a -> Gen (Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:684
#, no-wrap
msgid ""
"      list : Gen Nat -> Gen a -> Gen (List a)\n"
"      ```\n"
msgstr ""
"      list : Gen Nat -> Gen a -> Gen (List a)\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:687
#, no-wrap
msgid ""
"      Use `vect` to implement utility function `testGen` for\n"
"      testing your generators at the REPL:\n"
msgstr ""
"      使用`vect`实现工具函数`testGen` ，\n"
"      并在 REPL 测试你的生成器：\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:691
#, no-wrap
msgid ""
"      ```idris\n"
"      testGen : Bits64 -> Gen a -> Vect 10 a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      testGen : Bits64 -> Gen a -> Vect 10 a\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:693
msgid "Implement `choice`."
msgstr "实现 `choice`."

#. type: Plain text
#: ../src/Tutorial/Traverse.md:697
#, no-wrap
msgid ""
"      ```idris\n"
"      choice : {n : _} -> Vect (S n) (Gen a) -> Gen a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      choice : {n : _} -> Vect (S n) (Gen a) -> Gen a\n"
"      ```\n"

#. type: Bullet: '   8. '
#: ../src/Tutorial/Traverse.md:699
msgid "Implement `either`."
msgstr "实现 `either`."

#. type: Plain text
#: ../src/Tutorial/Traverse.md:703
#, no-wrap
msgid ""
"      ```idris\n"
"      either : Gen a -> Gen b -> Gen (Either a b)\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      either : Gen a -> Gen b -> Gen (Either a b)\n"
"      ```\n"

#. type: Bullet: '   9. '
#: ../src/Tutorial/Traverse.md:708
msgid ""
"Implement a generator for printable ASCII characters.  These are characters "
"with ASCII codes in the interval `[32,126]`. Hint: Function `chr` from the "
"*Prelude* will be useful here."
msgstr ""
"为可打印的 ASCII 字符实现生成器。这些是 ASCII 码在区间 `[32,126]` 中的字符。"
"提示：*Prelude* 中的函数 `chr` 在这里很有用。"

#. type: Bullet: '   10. '
#: ../src/Tutorial/Traverse.md:711
msgid ""
"Implement a generator for strings. Hint: Function `pack` from the *Prelude* "
"might be useful for this."
msgstr "实现一个字符串生成器。提示：*Prelude* 中的函数 `pack` 可能对此有用。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:715
#, no-wrap
msgid ""
"       ```idris\n"
"       string : Gen Nat -> Gen Char -> Gen String\n"
"       ```\n"
msgstr ""
"       ```idris\n"
"       string : Gen Nat -> Gen Char -> Gen String\n"
"       ```\n"

#. type: Bullet: '   11. '
#: ../src/Tutorial/Traverse.md:722
msgid ""
"We shouldn't forget about our ability to encode interesting things in the "
"types in Idris, so, for a challenge and without further ado, implement "
"`hlist` (note the distinction between `HListF` and `HList`). If you are "
"rather new to dependent types, this might take a moment to digest, so don't "
"forget to use holes."
msgstr ""
"我们不应该忘记我们在 Idris 的类型中编码有趣事物的能力，因此，为了挑战，事不宜"
"迟，实现 `hlist`（注意 `HListF` 和 `HList`）。如果您对依值类型比较陌生，这可"
"能需要一点时间来消化，所以不要忘记使用孔。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:727
#, no-wrap
msgid ""
"       ```idris\n"
"       data HListF : (f : Type -> Type) -> (ts : List Type) -> Type where\n"
"         Nil  : HListF f []\n"
"         (::) : (x : f t) -> (xs : HLift f ts) -> HListF f (t :: ts)\n"
msgstr ""
"       ```idris\n"
"       data HListF : (f : Type -> Type) -> (ts : List Type) -> Type where\n"
"         Nil  : HListF f []\n"
"         (::) : (x : f t) -> (xs : HLift f ts) -> HListF f (t :: ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:730
#, no-wrap
msgid ""
"       hlist : HListF Gen ts -> Gen (HList ts)\n"
"       ```\n"
msgstr ""
"       hlist : HListF Gen ts -> Gen (HList ts)\n"
"       ```\n"

#. type: Bullet: '   12. '
#: ../src/Tutorial/Traverse.md:732
msgid ""
"Generalize `hlist` to work with any applicative functor, not just `Gen`."
msgstr "泛化 `hlist` 以与任何应用函子一起工作，而不仅仅是 `Gen`."

#. type: Plain text
#: ../src/Tutorial/Traverse.md:736
#, no-wrap
msgid ""
"   If you arrived here, please realize how we can now generate pseudo-random\n"
"   values for most primitives, as well as regular sum- and product types.\n"
"   Here is an example REPL session:\n"
msgstr ""
"   如果你到了这里，请意识到我们现在如何生成大多数原语的伪随机值，以及常规的 sum- 和 product 类型。\n"
"   这是一个示例 REPL 会话：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:737
#, no-wrap
msgid ""
"   > testGen 100 $ hlist [bool, printableAscii, interval 0 127]\n"
"   [[True, ';', 5],\n"
"    [True, '^', 39],\n"
"    [False, 'o', 106],\n"
"    [True, 'k', 127],\n"
"    [False, ' ', 11],\n"
"    [False, '~', 76],\n"
"    [True, 'M', 11],\n"
"    [False, 'P', 107],\n"
"    [True, '5', 67],\n"
"    [False, '8', 9]]\n"
msgstr ""
"   > testGen 100 $ hlist [bool, printableAscii, interval 0 127]\n"
"   [[True, ';', 5],\n"
"    [True, '^', 39],\n"
"    [False, 'o', 106],\n"
"    [True, 'k', 127],\n"
"    [False, ' ', 11],\n"
"    [False, '~', 76],\n"
"    [True, 'M', 11],\n"
"    [False, 'P', 107],\n"
"    [True, '5', 67],\n"
"    [False, '8', 9]]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:764
#, no-wrap
msgid ""
"   Final remarks: Pseudo-random value generators play an important role\n"
"   in property based testing libraries like [QuickCheck](https://hackage.haskell.org/package/QuickCheck)\n"
"   or [Hedgehog](https://github.com/stefan-hoeck/idris2-hedgehog).\n"
"   The idea of property based testing is to test predefined *properties* of\n"
"   pure functions against a large number of randomly generated arguments,\n"
"   to get strong guarantees about these properties to hold for *all*\n"
"   possible arguments. One example would be a test for verifying\n"
"   that the result of reversing a list twice equals the original list.\n"
"   While it is possible to proof many of the simpler properties in Idris\n"
"   directly without the need for tests, this is no longer possible\n"
"   as soon as functions are involved, which don't reduce during unification\n"
"   such as foreign function calls or functions not publicly exported from\n"
"   other modules.\n"
msgstr ""
"   最后的评论：伪随机值生成器在基于属性的测试库中起着重要作用，如 [QuickCheck](https://hackage.haskell.org/package/QuickCheck)\n"
"   或 [Hedgehog](https://github.com/stefan-hoeck/idris2-hedgehog)。\n"
"   基于属性的测试的思想是针对大量随机生成的参数的纯函数测试预定义的*属性*，\n"
"   为 *所有* 可能的参数获得有关这些属性的有力保证。一个例子是验证\n"
"   将列表反转两次的结果等于原始列表的测试。\n"
"   虽然不需要测试可以直接证明 Idris 中的许多更简单的属性，一旦涉及函数这不再可能，因为在统一期间不会减少，\n"
"   例如外部函数调用或其他模块未公开导出的函数。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:770
msgid ""
"While `State s a` gives us a convenient way to talk about stateful "
"computations, it only allows us to mutate the state's *value* but not its "
"*type*. For instance, the following function cannot be encapsulated in "
"`State` because the type of the state changes:"
msgstr ""
"虽然 `State s a` 为我们提供了一种讨论有状态计算的便捷方式，但它只允许我们改变"
"状态的*值*而不是它的*类型*。例如，下面的函数不能封装在 `State` 中，因为状态的"
"类型发生了变化："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:771
#, no-wrap
msgid ""
"   uncons : Vect (S n) a -> (Vect n a, a)\n"
"   uncons (x :: xs) = (xs, x)\n"
msgstr ""
"   uncons : Vect (S n) a -> (Vect n a, a)\n"
"   uncons (x :: xs) = (xs, x)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:784
#, no-wrap
msgid ""
"   Your task is to come up with a new state type allowing for\n"
"   such changes (sometimes referred to as an *indexed* state data type).\n"
"   The goal of this exercise is to also sharpen your skills in\n"
"   expressing things at the type level including derived function\n"
"   types and interfaces. Therefore, I will give only little\n"
"   guidance on how to go about this. If you get stuck, feel free to\n"
"   peek at the solutions but make sure to only look at the types\n"
"   at first.\n"
msgstr ""
"   你的任务是提出一个新的状态类型，允许\n"
"   此类更改（有时称为 *索引* 状态数据类型）。\n"
"   这个练习的目的也是为了提高你的技能\n"
"   在类型级别表达事物，包括派生函数\n"
"   类型和接口。因此，我只会付出一点点\n"
"   指导如何去做。如果您遇到困难，请随时\n"
"   查看解决方案，但确保只查看类型\n"
"   首先。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:790
msgid ""
"Come up with a parameterized data type for encapsulating stateful "
"computations where the input and output state type can differ. It must be "
"possible to wrap `uncons` in a value of this type."
msgstr ""
"提出一种参数化数据类型，用于封装输入和输出状态类型可能不同的有状态计算。必须"
"可以将 `uncons` 包装在这种类型的值中。"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:792
msgid "Implement `Functor` for your indexed state type."
msgstr "为您的索引状态类型实现 `Functor`。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:797
msgid ""
"It is not possible to implement `Applicative` for this *indexed* state type "
"(but see also exercise 2.vii).  Still, implement the necessary functions to "
"use it with idom brackets."
msgstr ""
"对于这种*索引*状态类型，无法实现 `Applicative`（但另请参见练习 2.vii）。尽管"
"如此，实现必要的函数以将其与习语括号一起使用。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:801
msgid ""
"It is not possible to implement `Monad` for this indexed state type. Still, "
"implement the necessary functions to use it in do blocks."
msgstr ""
"无法为此索引状态类型实现 `Monad`。不过，实现必要的功能以在 do 块中使用它。"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:805
msgid ""
"Generalize the functions from exercises 3 and 4 with two new interfaces "
"`IxApplicative` and `IxMonad` and provide implementations of these for your "
"indexed state data type."
msgstr ""
"使用两个新接口 `IxApplicative` 和 `IxMonad` 概括练习 3 和 4 中的函数，并为您"
"的索引状态数据类型提供这些实现。"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:809
msgid ""
"Implement functions `get`, `put`, `modify`, `runState`, `evalState`, and "
"`execState` for the indexed state data type. Make sure to adjust the type "
"parameters where necessary."
msgstr ""
"实现函数 `get`、`put`、`modify`、`runState`、`evalState` 和 `execState`对于索"
"引状态数据类型。确保在必要时调整类型参数。"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:812
msgid ""
"Show that your indexed state type is strictly more powerful than `State` by "
"implementing `Applicative` and `Monad` for it."
msgstr ""
"通过为它实现 `Applicative` 和 `Monad` 来证明你的索引状态类型比 `State` 更强"
"大。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:816
#, no-wrap
msgid ""
"      Hint: Keep the input and output state identical. Note also,\n"
"      that you might need to implement `join` manually if Idris\n"
"      has trouble inferring the types correctly.\n"
msgstr ""
"      提示：保持输入和输出状态相同。另请注意，\n"
"      如果 Idris 无法正确推断类型，您可能需要手动实施 `join`。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:821
#, no-wrap
msgid ""
"   Indexed state types can be useful when we want to make sure that\n"
"   stateful computations are combined in the correct sequence, or\n"
"   that scarce resources get cleaned up properly. We might get back\n"
"   to such use cases in later examples.\n"
msgstr ""
"   当我们想要确保\n"
"   有状态的计算以正确的顺序组合，或者\n"
"   稀缺资源得到妥善清理。我们可能会在后面的示例中使用此类用例。\n"

#. type: Title ##
#: ../src/Tutorial/Traverse.md:822
#, no-wrap
msgid "The Power of Composition"
msgstr "组合的力量"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:830
msgid ""
"After our excursion into the realms of stateful computations, we will go "
"back and combine mutable state with error accumulation to tag and read CSV "
"lines in a single traversal. We already defined `pairWithIndex` for tagging "
"lines with their indices.  We also have `uncurry $ hdecode ts` for decoding "
"single tagged lines.  We can now combine the two effects in a single "
"computation:"
msgstr ""
"在进入有状态计算领域之后，我们\n"
"将返回并将可变状态与错误累积结合起来\n"
"在一次遍历中标记和读取 CSV 行。我们已经\n"
"定义 `pairWithIndex` 用于标记行及其索引。\n"
"我们还有 `uncurry $ hdecode ts` 用于解码单个标记行。\n"
"我们现在可以在一次计算中结合这两种效果："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:831
#, no-wrap
msgid ""
"tagAndDecode :  (0 ts : List Type)\n"
"             -> CSVLine (HList ts)\n"
"             => String\n"
"             -> State Nat (Validated CSVError (HList ts))\n"
"tagAndDecode ts s = uncurry (hdecode ts) <$> pairWithIndex s\n"
msgstr ""
"tagAndDecode :  (0 ts : List Type)\n"
"             -> CSVLine (HList ts)\n"
"             => String\n"
"             -> State Nat (Validated CSVError (HList ts))\n"
"tagAndDecode ts s = uncurry (hdecode ts) <$> pairWithIndex s\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:851
msgid ""
"Now, as we learned before, applicative functors are closed under "
"composition, and the result of `tagAndDecode` is a nesting of two "
"applicatives: `State Nat` and `Validated CSVError`.  The *Prelude* exports a "
"corresponding named interface implementation (`Prelude.Applicative."
"Compose`), which we can use for traversing a list of strings with "
"`tagAndDecode`.  Remember, that we have to provide named implementations "
"explicitly.  Since `traverse` has the applicative functor as its second "
"constraint, we also need to provide the first constraint (`Traversable`) "
"explicitly. But this is going to be the unnamed default implementation! To "
"get our hands on such a value, we can use the `%search` pragma:"
msgstr ""
"现在，正如我们之前所了解的，应用函子是封闭的\n"
"组合，`tagAndDecode` 的结果是嵌套\n"
"两个应用程序：`State Nat` 和 `Validated CSVError`。\n"
"*Prelude* 导出相应的命名接口实现\n"
"(`Prelude.Applicative.Compose`)，我们可以用来遍历\n"
"带有 `tagAndDecode` 的字符串列表。\n"
"请记住，我们必须明确提供命名实现。\n"
"由于 `traverse` 有应用函子作为它的\n"
"第二个约束，我们还需要提供第一个\n"
"显式约束 (`Traversable`)。但是这个\n"
"将是未命名的默认实现！为了得到这样的一个值，我们可以使用 `%search` pragma："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:852
#, no-wrap
msgid ""
"readTable :  (0 ts : List Type)\n"
"          -> CSVLine (HList ts)\n"
"          => List String\n"
"          -> Validated CSVError (List $ HList ts)\n"
"readTable ts = evalState 1 . traverse @{%search} @{Compose} (tagAndDecode ts)\n"
msgstr ""
"readTable :  (0 ts : List Type)\n"
"          -> CSVLine (HList ts)\n"
"          => List String\n"
"          -> Validated CSVError (List $ HList ts)\n"
"readTable ts = evalState 1 . traverse @{%search} @{Compose} (tagAndDecode ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:866
msgid ""
"This tells Idris to use the default implementation for the `Traversable` "
"constraint, and `Prelude.Applicatie.Compose` for the `Applicative` "
"constraint.  While this syntax is not very nice, it doesn't come up too "
"often, and if it does, we can improve things by providing custom functions "
"for better readability:"
msgstr ""
"这告诉 Idris 使用默认实现\n"
"`Traversable` 约束和 `Applicative` 约束的 `Prelude.Applicatie.Compose` 。\n"
"虽然这种语法不是很好，但它不会经常出现，并且\n"
"如果是这样，我们可以通过提供自定义函数来改进\n"
"为了更好的可读性："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:867
#, no-wrap
msgid ""
"traverseComp : Traversable t\n"
"             => Applicative f\n"
"             => Applicative g\n"
"             => (a -> f (g b))\n"
"             -> t a\n"
"             -> f (g (t b))\n"
"traverseComp = traverse @{%search} @{Compose}\n"
"\n"
"readTable' :  (0 ts : List Type)\n"
"           -> CSVLine (HList ts)\n"
"           => List String\n"
"           -> Validated CSVError (List $ HList ts)\n"
"readTable' ts = evalState 1 . traverseComp (tagAndDecode ts)\n"
msgstr ""
"traverseComp : Traversable t\n"
"             => Applicative f\n"
"             => Applicative g\n"
"             => (a -> f (g b))\n"
"             -> t a\n"
"             -> f (g (t b))\n"
"traverseComp = traverse @{%search} @{Compose}\n"
"\n"
"readTable' :  (0 ts : List Type)\n"
"           -> CSVLine (HList ts)\n"
"           => List String\n"
"           -> Validated CSVError (List $ HList ts)\n"
"readTable' ts = evalState 1 . traverseComp (tagAndDecode ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:885
msgid ""
"Note, how this allows us to combine two computational effects (mutable state "
"and error accumulation) in a single list traversal."
msgstr ""
"请注意，这如何让我们结合两种计算效果\n"
"（可变状态和错误累积）在单个列表遍历中。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:898
msgid ""
"But I am not yet done demonstrating the power of composition. As you showed "
"in one of the exercises, `Traversable` is also closed under composition, so "
"a nesting of traversables is again a traversable. Consider the following use "
"case: When reading a CSV file, we'd like to allow lines to be annotated with "
"additional information. Such annotations could be mere comments but also "
"some formatting instructions or other custom data tags might be feasible.  "
"Annotations are supposed to be separated from the rest of the content by a "
"single hash character (`#`).  We want to keep track of these optional "
"annotations so we come up with a custom data type encapsulating this "
"distinction:"
msgstr ""
"但我还没有完成展示组合的力量。正如你在其中一个练习中所展示的，`Traversable` "
"在组合下也是闭合的，\n"
"所以可遍历的嵌套又是可遍历的。考虑以下用例：读取 CSV 文件时，我们希望允许行附"
"有附加信息的注释。这样的注释可以仅仅是评论，还有一些格式说明或其他\n"
"可选的自定义数据标签。\n"
"注释应该与其他注释分开\n"
"单个哈希字符 (`#`) 的内容。\n"
"我们希望跟踪这些可选注释\n"
"所以我们想出了一个自定义数据类型封装\n"
"这种区别："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:899
#, no-wrap
msgid ""
"data Line : Type -> Type where\n"
"  Annotated : String -> a -> Line a\n"
"  Clean     : a -> Line a\n"
msgstr ""
"data Line : Type -> Type where\n"
"  Annotated : String -> a -> Line a\n"
"  Clean     : a -> Line a\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:908
msgid ""
"This is just another container type and we can easily implement "
"`Traversable` for `Line` (do this yourself as a quick exercise):"
msgstr ""
"这只是另一种容器类型，我们可以\n"
"为 `Line` 轻松实现 `Traversable` （自己做\n"
"快速练习）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:909
#, no-wrap
msgid ""
"Functor Line where\n"
"  map f (Annotated s x) = Annotated s $ f x\n"
"  map f (Clean x)       = Clean $ f x\n"
"\n"
"Foldable Line where\n"
"  foldr f acc (Annotated _ x) = f x acc\n"
"  foldr f acc (Clean x)       = f x acc\n"
"\n"
"Traversable Line where\n"
"  traverse f (Annotated s x) = Annotated s <$> f x\n"
"  traverse f (Clean x)       = Clean <$> f x\n"
msgstr ""
"Functor Line where\n"
"  map f (Annotated s x) = Annotated s $ f x\n"
"  map f (Clean x)       = Clean $ f x\n"
"\n"
"Foldable Line where\n"
"  foldr f acc (Annotated _ x) = f x acc\n"
"  foldr f acc (Clean x)       = f x acc\n"
"\n"
"Traversable Line where\n"
"  traverse f (Annotated s x) = Annotated s <$> f x\n"
"  traverse f (Clean x)       = Clean <$> f x\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:928
msgid ""
"Below is a function for parsing a line and putting it in its correct "
"category. For simplicity, we just split the line on hashes: If the result "
"consists of exactly two strings, we treat the second part as an annotation, "
"otherwise we treat the whole line as untagged CSV content."
msgstr ""
"下面是一个用于解析一行并将其放入其中的函数\n"
"正确的类别。为简单起见，我们只是将行拆分为散列：\n"
"如果结果正好由两个字符串组成，我们处理第二个\n"
"部分作为注释，否则我们将整行视为未标记\n"
"CSV 内容。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:929
#, no-wrap
msgid ""
"readLine : String -> Line String\n"
"readLine s = case split ('#' ==) s of\n"
"  h ::: [t] => Annotated t h\n"
"  _         => Clean s\n"
msgstr ""
"readLine : String -> Line String\n"
"readLine s = case split ('#' ==) s of\n"
"  h ::: [t] => Annotated t h\n"
"  _         => Clean s\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:938
msgid ""
"We are now going to implement a function for reading whole CSV tables, "
"keeping track of line annotations:"
msgstr ""
"我们现在要实现一个读取整个函数的函数\n"
"CSV 表，跟踪行注释："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:939
#, no-wrap
msgid ""
"readCSV :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => String\n"
"        -> Validated CSVError (List $ Line $ HList ts)\n"
"readCSV ts = evalState 1\n"
"           . traverse @{Compose} @{Compose} (tagAndDecode ts)\n"
"           . map readLine\n"
"           . lines\n"
msgstr ""
"readCSV :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => String\n"
"        -> Validated CSVError (List $ Line $ HList ts)\n"
"readCSV ts = evalState 1\n"
"           . traverse @{Compose} @{Compose} (tagAndDecode ts)\n"
"           . map readLine\n"
"           . lines\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:966
msgid ""
"Let's digest this monstrosity. This is written in point-free style, so we "
"have to read it from end to beginning. First, we split the whole string at "
"line breaks, getting a list of strings (function `Data.String.lines`). Next, "
"we analyze each line, keeping track of optional annotations (`map "
"readLine`).  This gives us a value of type `List (Line String)`. Since this "
"is a nesting of traversables, we invoke `traverse` with a named instance "
"from the *Prelude*: `Prelude.Traversable.Compose`.  Idris can disambiguate "
"this based on the types, so we can drop the namespace prefix. But the "
"effectful computation we run over the list of lines results in a composition "
"of applicative functors, so we also need the named implementation for "
"compositions of applicatives in the second constraint (again without need of "
"an explicit prefix, which would be `Prelude.Applicative` here).  Finally, we "
"evaluate the stateful computation with `evalState 1`."
msgstr ""
"让我们消化这个怪物。这是用无点的\n"
"风格写的，所以我们必须从头到尾阅读它。首先，我们\n"
"在换行符处拆分整个字符串，得到一个字符串列表\n"
"（函数 `Data.String.lines`）。接下来，我们分析每一行，\n"
"跟踪可选注释（`map readLine`）。\n"
"这给了我们一个 `List (Line String)` 类型的值。这是可遍历的嵌套，我们调用 "
"`traverse`\n"
"使用来自 *Prelude* 的命名实例：`Prelude.Traversable.Compose`。\n"
"Idris 可以根据类型消除歧义，因此我们可以\n"
"删除命名空间前缀。但我们在行列表上有效的计算会产生一个应用函子的组合，所以对"
"于第二个中的应用程序组合\n"
"约束我们还需要命名的实现（同样不需要明确的前缀，此处为 `Prelude."
"Applicative`）。\n"
"最后，我们使用 `evalState 1` 评估有状态计算。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:974
msgid ""
"Honestly, I wrote all of this without verifying if it works, so let's give "
"it a go at the REPL. I'll provide two example strings for this, a valid one "
"without errors, and an invalid one. I use *multiline string literals* here, "
"about which I'll talk in more detail in a later chapter. For the moment, "
"note that these allow us to conveniently enter string literals with line "
"breaks:"
msgstr ""
"老实说，我写了所有这些都没有验证它是否有效，\n"
"所以让我们在 REPL 上试一试吧。我会提供两个\n"
"示例字符串，一个没有错误的有效字符串，以及\n"
"一个无效的。我在这里使用 *多行字符串文字* ，关于\n"
"我将在后面的章节中更详细地讨论。暂时，\n"
"请注意，这些允许我们方便地输入字符串文字\n"
"带换行符："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:975
#, no-wrap
msgid ""
"validInput : String\n"
"validInput = \"\"\"\n"
"  f,12,-13.01#this is a comment\n"
"  t,100,0.0017\n"
"  t,1,100.8#color: red\n"
"  f,255,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
"\n"
"invalidInput : String\n"
"invalidInput = \"\"\"\n"
"  o,12,-13.01#another comment\n"
"  t,100,0.0017\n"
"  t,1,abc\n"
"  f,256,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
msgstr ""
"validInput : String\n"
"validInput = \"\"\"\n"
"  f,12,-13.01#this is a comment\n"
"  t,100,0.0017\n"
"  t,1,100.8#color: red\n"
"  f,255,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
"\n"
"invalidInput : String\n"
"invalidInput = \"\"\"\n"
"  o,12,-13.01#another comment\n"
"  t,100,0.0017\n"
"  t,1,abc\n"
"  f,256,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:996
msgid "And here's how it goes at the REPL:"
msgstr "以下是 REPL 的情况："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid ""
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] validInput\n"
"Valid [Annotated \"this is a comment\" [False, 12, -13.01],\n"
"       Clean [True, 100, 0.0017],\n"
"       Annotated \"color: red\" [True, 1, 100.8],\n"
"       Clean [False, 255, 0.0],\n"
"       Clean [False, 24, 1.12e17]]\n"
"\n"
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] invalidInput\n"
"Invalid (Append (FieldError 1 1 \"o\")\n"
"  (Append (FieldError 3 3 \"abc\") (FieldError 4 2 \"256\")))\n"
msgstr ""
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] validInput\n"
"Valid [Annotated \"this is a comment\" [False, 12, -13.01],\n"
"       Clean [True, 100, 0.0017],\n"
"       Annotated \"color: red\" [True, 1, 100.8],\n"
"       Clean [False, 255, 0.0],\n"
"       Clean [False, 24, 1.12e17]]\n"
"\n"
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] invalidInput\n"
"Invalid (Append (FieldError 1 1 \"o\")\n"
"  (Append (FieldError 3 3 \"abc\") (FieldError 4 2 \"256\")))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1015
msgid ""
"It is pretty amazing how we wrote dozens of lines of code, always being "
"guided by the type- and totality checkers, arriving eventually at a function "
"for parsing properly typed CSV tables with automatic line numbering and "
"error accumulation, all of which just worked on first try."
msgstr ""
"我们写了几十行代码，这真是太神奇了，始终遵循类型和完全性检查器，最终到达解析"
"函数\n"
"正确键入带有自动行编号的 CSV 表和\n"
"错误累积，所有这些都在第一次尝试时起作用。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1025
msgid ""
"The *Prelude* provides three additional interfaces for container types "
"parameterized over *two* type parameters such as `Either` or `Pair`: "
"`Bifunctor`, `Bifoldable`, and `Bitraversable`. In the following exercises "
"we get some hands-one experience working with these. You are supposed to "
"look up what functions they provide and how to implement and use them "
"yourself."
msgstr ""
"*Prelude* 提供三个附加接口\n"
"通过 *两个* 类型参数参数化的容器类型\n"
"比如`Either`或者`Pair`：`Bifunctor`，`Bifoldable`，\n"
"和 `Bitraversable`。在下面的练习中，我们得到\n"
"一些与这些一起工作的亲身体验。你是\n"
"应该查找它们提供的功能\n"
"以及如何自己实施和使用它们。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:1029
msgid ""
"Assume we'd like to not only interpret CSV content but also the optional "
"comment tags in our CSV files.  For this, we could use a data type such as "
"`Tagged`:"
msgstr ""
"假设我们不仅要解释 CSV 内容，还要解释 CSV 文件中的可选注释标签。为此，我们可"
"以使用诸如 `Tagged` 之类的数据类型："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1030
#, no-wrap
msgid ""
"   data Tagged : (tag, value : Type) -> Type where\n"
"     Tag  : tag -> value -> Tagged tag value\n"
"     Pure : value -> Tagged tag value\n"
msgstr ""
"   data Tagged : (tag, value : Type) -> Type where\n"
"     Tag  : tag -> value -> Tagged tag value\n"
"     Pure : value -> Tagged tag value\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1039
#, no-wrap
msgid ""
"   Implement interfaces `Functor`, `Foldable`, and `Traversable`\n"
"   but also `Bifunctor`, `Bifoldable`, and `Bitraversable`\n"
"   for `Tagged`.\n"
msgstr ""
"   为 `Tagged` 实现接口 `Functor`、`Foldable` 和 `Traversable`\n"
"   还有 `Bifunctor`、`Bifoldable` 和 `Bitraversable`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:1045
msgid ""
"Show that the composition of a bifunctor with two functors such as `Either "
"(List a) (Maybe b)` is again a bifunctor by defining a dedicated wrapper "
"type for such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and `Bitraversable`/"
"`Traversable`."
msgstr ""
"通过为此类组合定义专用包装器类型并编写 `Bifunctor` 的相应实现，证明具有两个函"
"子（例如 `Either (List a) (Maybe b)`）的二元函子的组合再次成为二元函子`。同样"
"适用于 `Bifoldable`/`Foldable` 和 `Bitraversable`/`Traversable`。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:1051
msgid ""
"Show that the composition of a functor with a bifunctor such as `List "
"(Either a b)` is again a bifunctor by defining a dedicated wrapper type for "
"such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and `Bitraversable`/"
"`Traversable`."
msgstr ""
"通过为此类组合定义专用包装器类型并编写 `Bifunctor` 的相应实现，证明具有二元函"
"子（如 `List (Either a b)`）的函子的组合再次是二元函子。同样适用于 "
"`Bifoldable`/`Foldable` 和 `Bitraversable`/`Traversable`。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:1055
msgid ""
"We are now going to adjust `readCSV` in such a way that it decodes comment "
"tags and CSV content in a single traversal.  We need a new error type to "
"include invalid tags for this:"
msgstr ""
"我们现在将调整 `readCSV` 使其在一次遍历中解码评论标签和 CSV 内容。我们需要一"
"个新的错误类型来包含无效的标签："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1056
#, no-wrap
msgid ""
"   data TagError : Type where\n"
"     CE         : CSVError -> TagError\n"
"     InvalidTag : (line : Nat) -> (tag : String) -> TagError\n"
"     Append     : TagError -> TagError -> TagError\n"
"\n"
"   Semigroup TagError where (<+>) = Append\n"
msgstr ""
"   data TagError : Type where\n"
"     CE         : CSVError -> TagError\n"
"     InvalidTag : (line : Nat) -> (tag : String) -> TagError\n"
"     Append     : TagError -> TagError -> TagError\n"
"\n"
"   Semigroup TagError where (<+>) = Append\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1066
#, no-wrap
msgid "   For testing, we also define a simple data type for color tags:\n"
msgstr "   为了测试，我们还为颜色标签定义了一个简单的数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1067
#, no-wrap
msgid "   data Color = Red | Green | Blue\n"
msgstr "   data Color = Red | Green | Blue\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1076
#, no-wrap
msgid ""
"   You should now implement the following functions, but\n"
"   please note that while `readColor` will need to\n"
"   access the current line number in case of an error,\n"
"   it must *not* increase it, as otherwise line numbers\n"
"   will be wrong in the invocation of `tagAndDecodeTE`.\n"
msgstr ""
"   您现在应该实现以下功能，但是\n"
"   请注意，虽然 `readColor` 需要\n"
"   出现错误时访问当前行号，\n"
"   它必须 *不* 增加它，否则行号\n"
"   调用 `tagAndDecodeTE` 会出错。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1077
#, no-wrap
msgid ""
"   readColor : String -> State Nat (Validated TagError Color)\n"
"\n"
"   readTaggedLine : String -> Tagged String String\n"
"\n"
"   tagAndDecodeTE :  (0 ts : List Type)\n"
"                  -> CSVLine (HList ts)\n"
"                  => String\n"
"                  -> State Nat (Validated TagError (HList ts))\n"
msgstr ""
"   readColor : String -> State Nat (Validated TagError Color)\n"
"\n"
"   readTaggedLine : String -> Tagged String String\n"
"\n"
"   tagAndDecodeTE :  (0 ts : List Type)\n"
"                  -> CSVLine (HList ts)\n"
"                  => String\n"
"                  -> State Nat (Validated TagError (HList ts))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1094
#, no-wrap
msgid ""
"   Finally, implement `readTagged` by using the wrapper type\n"
"   from exercise 3 as well as `readColor` and `tagAndDecodeTE`\n"
"   in a call to `bitraverse`.\n"
"   The implementation will look very similar to `readCSV` but\n"
"   with some additional wrapping and unwrapping at the right\n"
"   places.\n"
msgstr ""
"   最后，使用 wrapper 类型实现 `readTagged`\n"
"   来自练习 3 以及 `readColor` 和 `tagAndDecodeTE`\n"
"   在对 `bitraverse` 的调用中。\n"
"   该实现看起来与 `readCSV` 非常相似，但是\n"
"   在右侧有一些额外的包装和展开。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid ""
"   readTagged :  (0 ts : List Type)\n"
"              -> CSVLine (HList ts)\n"
"              => String\n"
"              -> Validated TagError (List $ Tagged Color $ HList ts)\n"
msgstr ""
"   readTagged :  (0 ts : List Type)\n"
"              -> CSVLine (HList ts)\n"
"              => String\n"
"              -> Validated TagError (List $ Tagged Color $ HList ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1103
#, no-wrap
msgid "   Test your implementation with some example strings at the REPL.\n"
msgstr "   使用 REPL 中的一些示例字符串测试您的实现。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1108
msgid ""
"You can find more examples for functor/bifunctor compositions in Haskell's "
"[bifunctors](https://hackage.haskell.org/package/bifunctors)  package."
msgstr ""
"您可以找到更多关于函子/二元函子组合的示例\n"
"在 Haskell 的 [bifunctors](https://hackage.haskell.org/package/bifunctors)\n"
"包装。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1117
msgid ""
"Interface `Traversable` and its main function `traverse` are incredibly "
"powerful forms of abstraction - even more so, because both `Applicative` and "
"`Traversable` are closed under composition. If you are interested in "
"additional use cases, the publication, which introduced `Traversable` to "
"Haskell, is a highly recommended read: [The Essence of the Iterator Pattern]"
"(https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)"
msgstr ""
"接口`Traversable`及其主函数`traverse`令人难以置信\n"
"强大的抽象形式 - 更是如此，因为 `Applicative`\n"
"和 `Traversable` 在组合下是闭合的。如果你感兴趣\n"
"在其他用例中，该出版物，其中\n"
"向 Haskell 介绍了 `Traversable`，强烈推荐阅读：\n"
"[迭代器模式的本质](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/"
"iterator.pdf)"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1124
msgid ""
"The *base* library provides an extended version of the state monad in module "
"`Control.Monad.State`. We will look at this in more detail when we talk "
"about monad transformers.  Please note also, that `IO` itself is implemented "
"as a [simple state monad](IO.md#how-io-is-implemented)  over an abstract, "
"primitive state type: `%World`."
msgstr ""
"*base* 库提供了\n"
"模块 `Control.Monad.State` 中的状态单子。我们会看\n"
"当我们谈论 monad 转换器时，会更详细地介绍这一点。\n"
"另请注意，`IO` 本身被实现为\n"
"[简单状态单子](IO.md#how-io-is-implemented)\n"
"在抽象的原始状态类型上：`%World`。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1126
msgid "Here's a short summary of what we learned in this chapter:"
msgstr "以下是我们在本章中学到的内容的简短摘要："

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Function `traverse` is used to run effectful computations over container "
"types without affecting their size or shape."
msgstr ""
"函数 `traverse` 用于对容器类型运行有效的计算，而不影响它们的大小或形状。"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"We can use `IORef` as mutable references in stateful computations running in "
"`IO`."
msgstr "我们可以使用 `IORef` 作为在 `IO` 中运行的有状态计算中的可变引用。"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"For referentially transparent computations with \"mutable\" state, the "
"`State` monad is extremely useful."
msgstr "对于具有“可变”状态的引用透明计算，`State` 单子非常有用。"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Applicative functors are closed under composition, so we can run several "
"effectful computations in a single traversal."
msgstr "应用函子在组合下是封闭的，因此我们可以在一次遍历中运行多个有效的计算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Traversables are also closed under composition, so we can use `traverse` to "
"operate on a nesting of containers."
msgstr ""
"Traversables 在组合下也是封闭的，所以我们可以使用 `traverse` 对容器的嵌套进行"
"操作。"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1146
msgid ""
"For now, this concludes our introduction of the *Prelude*'s higher-kinded "
"interfaces, which started with the introduction of `Functor`, `Applicative`, "
"and `Monad`, before moving on to `Foldable`, and - last but definitely not "
"least - `Traversable`.  There's one still missing - `Alternative` - but this "
"will have to wait a bit longer, because we need to first make our brains "
"smoke with some more [type-level wizardry](./DPair.md)."
msgstr ""
"至此，我们对 *Prelude* 的介绍到此结束\n"
"更高级的接口，从引入\n"
"`Functor`、`Applicative` 和 `Monad`，在继续 `Foldable` 之前，\n"
"和 - 最后但同样重要的是 - `Traversable`。\n"
"仍然缺少一个 - `Alternative` - 但这会\n"
"必须等待更长的时间，因为我们需要先使\n"
"我们的大脑会冒出更多 [类型级别的魔法](./DPair.md)。"
