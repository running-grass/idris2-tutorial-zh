# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:645
#, no-wrap
msgid "And at the REPL:\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Predicates.md:1
#, no-wrap
msgid "Predicates and Proof Search"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:12
#, no-wrap
msgid ""
"In the [last chapter](Eq.md) we learned about propositional\n"
"equality, which allowed us to proof that two values are\n"
"equal. Equality is a relation between values, and we used\n"
"an indexed data type to encode this relation by limiting\n"
"the degrees of freedom of the indices in the sole data\n"
"constructor. There are other relations and contracts we\n"
"can encode this way. This will allow us to restrict the\n"
"values we accept as a function's arguments or the values\n"
"returned by functions.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:13
#, no-wrap
msgid ""
"module Tutorial.Predicates\n"
"\n"
"import Data.Either\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"import Data.HList\n"
"import Decidable.Equality\n"
"\n"
"import Text.CSV\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:29
#, no-wrap
msgid "Preconditions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:38
#, no-wrap
msgid ""
"Often, when we implement functions operating on values\n"
"of a given type, not all values are considered to be\n"
"valid arguments for the function in question. For instance,\n"
"we typically do not allow division by zero, as the result\n"
"is undefined in the general case. This concept of putting\n"
"a *precondition* on a function argument comes up pretty often,\n"
"and there are several ways to go about this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:45
#, no-wrap
msgid ""
"A very common operation when working with lists or other\n"
"container types is to extract the first value in the sequence.\n"
"This function, however, cannot work in the general case, because\n"
"in order to extract a value from a list, the list must not\n"
"be empty. Here are a couple of ways to encode and implement\n"
"this, each with its own advantages and disadvantages:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:57
#, no-wrap
msgid ""
"Wrap the result in a failure type, such as a `Maybe` or\n"
"`Either e` with some custom error type `e`. This makes it\n"
"immediately clear that the function might not be able to\n"
"return a result. It is a natural way to deal with unvalidated\n"
"input from unknown sources. The drawback of this approach is\n"
"that results will carry the `Maybe` stain, even in situations\n"
"when we *know* that the *nil* case is impossible, for instance because we\n"
"know the value of the list argument at compile-time,\n"
"or because we already *refined* the input value in such a\n"
"way that we can be sure it is not empty (due to an earlier\n"
"pattern match, for instance).\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:67
#, no-wrap
msgid ""
"Define a new data type for non-empty lists and use this\n"
"as the function's argument. This is the approach taken in\n"
"module `Data.List1`. It allows us to return a pure value\n"
"(meaning \"not wrapped in a failure type\" here), because the\n"
"function cannot possibly fail, but it comes with the\n"
"burden of reimplementing many of the utility functions and\n"
"interfaces we already implemented for `List`. For a very common\n"
"data structure this can be a valid option, but for rare use cases\n"
"it is often too cumbersome.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:81
#, no-wrap
msgid ""
"Use an index to keep track of the property we are interested\n"
"in. This was the approach we took with type family `List01`,\n"
"which we saw in several examples and exercises in this guide\n"
"so far. This is also the approach taken with vectors,\n"
"where we use the exact length as our index, which is even\n"
"more expressive. While this allows us to implement many functions\n"
"only once and with greater precision at the type level, it\n"
"also comes with the burden of keeping track of changes\n"
"in the types, making for more complex function types\n"
"and forcing us to at times return existentially quantified\n"
"wrappers (for instance, dependent pairs),\n"
"because the outcome of a computation is not known until\n"
"runtime.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:87
#, no-wrap
msgid ""
"Fail with a runtime exception. This is a popular solution\n"
"in many programming languages (even Haskell), but in Idris\n"
"we try to avoid this, because it breaks totality in a way,\n"
"which also affects client code. Luckily, we can make use of\n"
"our powerful type system to avoid this situation in general.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:94
#, no-wrap
msgid ""
"Take an additional (possibly erased) argument of a type\n"
"we can use as a witness that the input value is of the\n"
"correct kind or shape. This is the solution we will discuss\n"
"in this chapter in great detail. It is an incredibly powerful way\n"
"to talk about restrictions on values without having to\n"
"replicate a lot of already existing functionality.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:100
#, no-wrap
msgid ""
"There is a time and place for most if not all of the solutions\n"
"listed above in Idris, but we will often turn to the last one and\n"
"refine function arguments with predicates (so called\n"
"*preconditions*), because it makes our functions nice to use at\n"
"runtime *and* compile time.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:101
#, no-wrap
msgid "Example: Non-empty Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:107
#, no-wrap
msgid ""
"Remember how we implemented an indexed data type for\n"
"propositional equality: We restricted the valid\n"
"values of the indices in the constructors. We can do\n"
"the same thing for a predicate for non-empty lists:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:108
#, no-wrap
msgid ""
"data NotNil : (as : List a) -> Type where\n"
"  IsNotNil : NotNil (h :: t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:117
#, no-wrap
msgid ""
"This is a single-value data type, so we can always use it\n"
"as an erased function argument and still pattern match on\n"
"it. We can now use this to implement a safe and pure `head`\n"
"function:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:118
#, no-wrap
msgid ""
"head1 : (as : List a) -> (0 _ : NotNil as) -> a\n"
"head1 (h :: _) _ = h\n"
"head1 [] IsNotNil impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:129
#, no-wrap
msgid ""
"Note, how value `IsNotNil` is a *witness* that its index,\n"
"which corresponds to our list argument, is indeed non-empty,\n"
"because this is what we specified in its type.\n"
"The impossible case in the implementation of `head1` is not\n"
"strictly necessary here. It was given above for completeness.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:134
#, no-wrap
msgid ""
"We call `NotNil` a *predicate* on lists, as it restricts\n"
"the values allowed in the index. We can express a function's\n"
"preconditions by adding additional (possibly erased) predicates\n"
"to the function's list of arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:138
#, no-wrap
msgid ""
"The first really cool thing is how we can safely use `head1`,\n"
"if we can at compile-time show that our list argument is\n"
"indeed non-empty:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:139
#, no-wrap
msgid ""
"headEx1 : Nat\n"
"headEx1 = head1 [1,2,3] IsNotNil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:152
#, no-wrap
msgid ""
"It is a bit cumbersome that we have to pass the `IsNotNil` proof\n"
"manually. Before we scratch that itch, we will first discuss what\n"
"to do with lists, the values of which are not known until\n"
"runtime. For these cases, we have to try and produce a value\n"
"of the predicate programmatically by inspecting the runtime\n"
"list value. In the most simple case, we can wrap the proof\n"
"in a `Maybe`, but if we can show that our predicate is *decidable*,\n"
"we can get even stronger guarantees by returning a `Dec`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:153
#, no-wrap
msgid ""
"Uninhabited (NotNil []) where\n"
"  uninhabited IsNotNil impossible\n"
"\n"
"nonEmpty : (as : List a) -> Dec (NotNil as)\n"
"nonEmpty (x :: xs) = Yes IsNotNil\n"
"nonEmpty []        = No uninhabited\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:164
#, no-wrap
msgid ""
"With this, we can implement function `headMaybe`, which\n"
"is to be used with lists of unknown origin:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:165
#, no-wrap
msgid ""
"headMaybe1 : List a -> Maybe a\n"
"headMaybe1 as = case nonEmpty as of\n"
"  Yes prf => Just $ head1 as prf\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:176
#, no-wrap
msgid ""
"Of course, for trivial functions like `headMaybe` it makes\n"
"more sense to implement them directly by pattern matching on\n"
"the list argument, but we will soon see examples of predicates\n"
"the values of which are more cumbersome to create.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:177
#, no-wrap
msgid "Auto Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:187
#, no-wrap
msgid ""
"Having to manually pass a proof of being non-empty to\n"
"`head1` makes this function unnecessarily verbose to\n"
"use at compile time. Idris allows us to define implicit\n"
"function arguments, the values of which it tries to assemble\n"
"on its own by means of a technique called *proof search*. This is not\n"
"to be confused with type inference, which means inferring\n"
"values or types from the surrounding context. It's best\n"
"to look at some examples to explain the difference.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:190
#, no-wrap
msgid ""
"Let us first have a look at the following implementation of\n"
"`replicate` for vectors:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:191
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' {n = 0}   _ = []\n"
"replicate' {n = S _} v = v :: replicate' v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:202
#, no-wrap
msgid ""
"Function `replicate'` takes an unerased implicit argument.\n"
"The *value* of this argument must be derivable from the surrounding\n"
"context. For instance, in the following example it is\n"
"immediately clear that `n` equals three, because that is\n"
"the length of the vector we want:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:203
#, no-wrap
msgid ""
"replicateEx1 : Vect 3 Nat\n"
"replicateEx1 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:211
#, no-wrap
msgid ""
"In the next example, the value of `n` is not known at compile time,\n"
"but it is available as an unerased implicit, so this can again\n"
"be passed as is to `replicate'`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:212
#, no-wrap
msgid ""
"replicateEx2 : {n : _} -> Vect n Nat\n"
"replicateEx2 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:223
#, no-wrap
msgid ""
"However, in the following example, the value of `n` can't\n"
"be inferred, as the intermediary vector is immediately converted\n"
"to a list of unknown length. Although Idris could try and insert\n"
"any value for `n` here, it won't do so, because it can't be\n"
"sure that this is the length we want. We therefore have to pass the\n"
"length explicitly:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:224
#, no-wrap
msgid ""
"replicateEx3 : List Nat\n"
"replicateEx3 = toList $ replicate' {n = 17} 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:234
#, no-wrap
msgid ""
"Note, how the *value* of `n` had to be inferable in\n"
"these examples, which means it had to make an appearance\n"
"in the surrounding context. With auto implicit arguments,\n"
"this works differently. Here is the `head` example, this\n"
"time with an auto implicit:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:235
#, no-wrap
msgid ""
"head : (as : List a) -> {auto 0 prf : NotNil as} -> a\n"
"head (x :: _) = x\n"
"head [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:249
#, no-wrap
msgid ""
"Note the `auto` keyword before the quantity of implicit argument\n"
"`prf`. This means, we want Idris to construct this value\n"
"on its own, without it being visible in the surrounding context.\n"
"In order to do so, Idris will have to at compile time know the\n"
"structure of the list argument `as`. It will then try and build\n"
"such a value from the data type's constructors. If it succeeds,\n"
"this value will then be automatically filled in as the desired argument,\n"
"otherwise, Idris will fail with a type error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:251
#, no-wrap
msgid "Let's see this in action:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:252
#, no-wrap
msgid ""
"headEx3 : Nat\n"
"headEx3 = Predicates.head [1,2,3]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:258
#, no-wrap
msgid "The following example fails with an error:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:259
#, no-wrap
msgid ""
"failing \"Can't find an implementation\\nfor NotNil [].\"\n"
"  errHead : Nat\n"
"  errHead = Predicates.head []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:276
#, no-wrap
msgid ""
"Wait! \"Can't find an implementation for...\"? Is this not the\n"
"error message we get for missing interface implementations?\n"
"That's correct, and I'll show you that interface resolution\n"
"is just proof search at the end of this chapter. What I can\n"
"show you already, is that writing the lengthy `{auto prf : t} ->`\n"
"all the times can be cumbersome. Idris therefore allows us\n"
"to use the same syntax as for constrained functions instead:\n"
"`(prf : t) =>`, or even `t =>`, if we don't need to name the\n"
"constraint. As usual, we can then access a constraint in the\n"
"function body by its name (if any). Here is another implementation\n"
"of `head`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:277
#, no-wrap
msgid ""
"head' : (as : List a) -> (0 _ : NotNil as) => a\n"
"head' (x :: _) = x\n"
"head' [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:287
#, no-wrap
msgid ""
"During proof search, Idris will also look for values of\n"
"the required type in the current function context. This allows\n"
"us to implement `headMaybe` without having to pass on\n"
"the `NotNil` proof manually:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:288
#, no-wrap
msgid ""
"headMaybe : List a -> Maybe a\n"
"headMaybe as = case nonEmpty as of\n"
"  -- `prf` is available during proof seach\n"
"  Yes prf => Just $ Predicates.head as\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:304
#, no-wrap
msgid ""
"To conclude: Predicates allow us to restrict the values\n"
"a function accepts as arguments. At runtime, we need to\n"
"build such *witnesses* by pattern matching on the function\n"
"arguments. These operations can typically fail. At compile\n"
"time, we can let Idris try and build these values for us\n"
"using a technique called *proof search*. This allows us\n"
"to make functions safe and convenient to use at the same\n"
"time.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:312
#, no-wrap
msgid ""
"In these exercises, you'll have to implement several\n"
"functions making use of auto implicits, to constrain\n"
"the values accepted as function arguments. The results\n"
"should be *pure*, that is, not wrapped in a failure type\n"
"like `Maybe`.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:314
#, no-wrap
msgid "Implement `tail` for lists.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:318
#, no-wrap
msgid ""
"Implement `concat1` and `foldMap1` for lists. These\n"
"should work like `concat` and `foldMap`, but taking only\n"
"a `Semigroup` constraint on the element type.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:321
#, no-wrap
msgid ""
"Implement functions for returning the largest and smallest\n"
"element in a list.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:325
#, no-wrap
msgid ""
"Define a predicate for strictly positive natural numbers\n"
"and use it to implement a safe and provably total division\n"
"function on natural numbers.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Predicates.md:330
#, no-wrap
msgid ""
"Define a predicate for a non-empty `Maybe` and use it to\n"
"safely extract the value stored in a `Just`. Show that this\n"
"predicate is decidable by implementing a corresponding\n"
"conversion function.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Predicates.md:334
#, no-wrap
msgid ""
"Define and implement functions for safely extracting values\n"
"from a `Left` and a `Right` by using suitable predicates.\n"
"Show again that these predicates are decidable.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:339
#, no-wrap
msgid ""
"The predicates you implemented in these exercises are already\n"
"available in the *base* library: `Data.List.NonEmpty`,\n"
"`Data.Maybe.IsJust`, `Data.Either.IsLeft`, `Data.Either.IsRight`,\n"
"and `Data.Nat.IsSucc`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:340
#, no-wrap
msgid "Contracts between Values"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:346
#, no-wrap
msgid ""
"The predicates we saw so far restricted the values of\n"
"a single type, but it is also possible to define predicates\n"
"describing contracts between several values of possibly\n"
"distinct types.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:347
#, no-wrap
msgid "The `Elem` Predicate"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:351
#, no-wrap
msgid ""
"Assume we'd like to extract a value of a given type from\n"
"a heterogeneous list:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:352
#, no-wrap
msgid "get' : (0 t : Type) -> HList ts -> t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:358
#, no-wrap
msgid ""
"This can't work in general: If we could implement this we would\n"
"immediately have a proof of void:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:359
#, no-wrap
msgid ""
"voidAgain : Void\n"
"voidAgain = get' Void []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:367
#, no-wrap
msgid ""
"The problem is obvious: The type of which we'd like to extract\n"
"a value must be an element of the index of the heterogeneous list.\n"
"Here is a predicate, with which we can express this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:368
#, no-wrap
msgid ""
"data Elem : (elem : a) -> (as : List a) -> Type where\n"
"  Here  : Elem x (x :: xs)\n"
"  There : Elem x xs -> Elem x (y :: xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:386
#, no-wrap
msgid ""
"This is a predicate describing a contract between two values:\n"
"A value of type `a` and a list of `a`s. Values of this predicate\n"
"are witnesses that the value is an element of the list.\n"
"Note, how this is defined recursively: The case\n"
"where the value we look for is at the head of the list is\n"
"handled by the `Here` constructor, where the same variable (`x`) is used\n"
"for the element and the head of the list. The case where the value\n"
"is deeper within  the list is handled by the `There`\n"
"constructor. This can be read as follows: If `x` is an element\n"
"of `xs`, then `x` is also an element of `y :: xs` for any\n"
"value `y`. Let's write down some examples to get a feel\n"
"for these:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:387
#, no-wrap
msgid ""
"MyList : List Nat\n"
"MyList = [1,3,7,8,4,12]\n"
"\n"
"oneElemMyList : Elem 1 MyList\n"
"oneElemMyList = Here\n"
"\n"
"sevenElemMyList : Elem 7 MyList\n"
"sevenElemMyList = There $ There Here\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:402
#, no-wrap
msgid ""
"Now, `Elem` is just another way of indexing into a list\n"
"of values. Instead of using a `Fin` index, which is limited\n"
"by the list's length, we use a proof that a value can be found\n"
"at a certain position.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:405
#, no-wrap
msgid ""
"We can use the `Elem` predicate to extract a value from\n"
"the desired type of a heterogeneous list:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:406
#, no-wrap
msgid "get : (0 t : Type) -> HList ts -> (prf : Elem t ts) => t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:415
#, no-wrap
msgid ""
"It is important to note that the auto implicit must not be\n"
"erased in this case. This is no longer a single value data type,\n"
"and we must be able to pattern match on this value in order to\n"
"figure out, how far within the heterogeneous list our value\n"
"is stored:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:416
#, no-wrap
msgid ""
"get t (v :: vs) {prf = Here}    = v\n"
"get t (v :: vs) {prf = There p} = get t vs\n"
"get _ [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:425
#, no-wrap
msgid ""
"It can be instructive to implement `get` yourself, using holes on\n"
"the right hand side to see the context and types of values Idris\n"
"infers based on the value of the `Elem` predicate.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:427
#, no-wrap
msgid "Let's give this a spin at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:428
#, no-wrap
msgid ""
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\", S Z]\n"
"1\n"
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\"]\n"
"Error: Can't find an implementation for Elem Nat [String, Maybe String].\n"
"\n"
"(Interactive):1:1--1:28\n"
" 1 | get Nat [\"foo\", Just \"bar\"]\n"
"     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:446
#, no-wrap
msgid ""
"With this example we start to appreciate what *proof search*\n"
"actually means: Given a value `v` and a list of values `vs`, Idris tries\n"
"to find a proof that `v` is an element of `vs`.\n"
"Now, before we continue, please note that proof search is\n"
"not a silver bullet. The search algorithm has a reasonably limited\n"
"*search depth*, and will fail with the search if this limit\n"
"is exceeded. For instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:447
#, no-wrap
msgid ""
"Tps : List Type\n"
"Tps = List.replicate 50 Nat ++ [Maybe String]\n"
"\n"
"hlist : HList Tps\n"
"hlist = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , Nothing ]\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:462
#, no-wrap
msgid ""
"Tutorial.Predicates> get (Maybe String) hlist\n"
"Error: Can't find an implementation for Elem (Maybe String) [Nat,...\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:474
#, no-wrap
msgid ""
"As you can see, Idris fails to find a proof that `Maybe String`\n"
"is an element of `Tps`. The search depth can be increased with\n"
"the `%auto_implicit_depth` directive, which will hold for the\n"
"rest of the source file or until set to a different value.\n"
"The default value is set at 25. In general, it is not advisable\n"
"to set this to a too large value as this can drastically increase\n"
"compile times.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:475
#, no-wrap
msgid ""
"%auto_implicit_depth 100\n"
"aMaybe : Maybe String\n"
"aMaybe = get _ hlist\n"
"\n"
"%auto_implicit_depth 25\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:483
#, no-wrap
msgid "Use Case: A nicer Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:492
#, no-wrap
msgid ""
"In the chapter about [sigma types](DPair.md), we introduced\n"
"a schema for CSV files. This was not very nice to use, because\n"
"we had to use natural numbers to access a certain column. Even\n"
"worse, users of our small library had to do the same. There was\n"
"no way to define a name for each column and access columns by\n"
"name. We are going to change this. Here is an encoding\n"
"for this use case:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:493
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"record Column where\n"
"  constructor MkColumn\n"
"  name : String\n"
"  type : ColType\n"
"\n"
"infixr 8 :>\n"
"\n"
"(:>) : String -> ColType -> Column\n"
"(:>) = MkColumn\n"
"\n"
"Schema : Type\n"
"Schema = List Column\n"
"\n"
"Show ColType where\n"
"  show I64     = \"I64\"\n"
"  show Str     = \"Str\"\n"
"  show Boolean = \"Boolean\"\n"
"  show Float   = \"Float\"\n"
"\n"
"Show Column where\n"
"  show (MkColumn n ct) = \"\\{n}:\\{show ct}\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:531
#, no-wrap
msgid ""
"As you can see, in a schema we now pair a column's type\n"
"with its name. Here is an example schema for a CSV file\n"
"holding information about employees in a company:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:532
#, no-wrap
msgid ""
"EmployeeSchema : Schema\n"
"EmployeeSchema = [ \"firstName\"  :> Str\n"
"                 , \"lastName\"   :> Str\n"
"                 , \"email\"      :> Str\n"
"                 , \"age\"        :> I64\n"
"                 , \"salary\"     :> Float\n"
"                 , \"management\" :> Boolean\n"
"                 ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:549
#, no-wrap
msgid ""
"Such a schema could of course again be read from user\n"
"input, but we will wait with implementing a parser until\n"
"later in this chapter.\n"
"Using this new schema with an `HList` directly led to issues\n"
"with type inference, therefore I quickly wrote a custom\n"
"row type: A heterogeneous list indexed over a schema.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:550
#, no-wrap
msgid ""
"data Row : Schema -> Type where\n"
"  Nil  : Row []\n"
"\n"
"  (::) :  {0 name : String}\n"
"       -> {0 type : ColType}\n"
"       -> (v : IdrisType type)\n"
"       -> Row ss\n"
"       -> Row (name :> type :: ss)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:565
#, no-wrap
msgid ""
"In the signature of *cons*, I list the erased implicit arguments\n"
"explicitly. This is good practice, as otherwise Idris will often\n"
"issue shadowing warnings when using such data constructors in client\n"
"code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:567
#, no-wrap
msgid "We can now define a type alias for CSV rows representing employees:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:568
#, no-wrap
msgid ""
"0 Employee : Type\n"
"Employee = Row EmployeeSchema\n"
"\n"
"hock : Employee\n"
"hock = [ \"Stefan\", \"Höck\", \"hock@foo.com\", 46, 5443.2, False ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:584
#, no-wrap
msgid ""
"Note, how I gave `Employee` a zero quantity. This means, we are\n"
"only ever allowed to use this function at compile time\n"
"but never at runtime. This is a safe way to make sure\n"
"our type-level functions and aliases do not leak into the\n"
"executable when we build our application. We are allowed\n"
"to use zero-quantity functions and values in type signatures\n"
"and when computing other erased values, but not for runtime-relevant\n"
"computations.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:602
#, no-wrap
msgid ""
"We would now like to access a value in a row based on\n"
"the name given. For this, we write a custom predicate, which\n"
"serves as a witness that a column with the given name is\n"
"part of the schema. Now, here is an important thing to note:\n"
"In this predicate we include an index for the *type* of the\n"
"column with the given name. We need this, because when we\n"
"access a column by name, we need a way to figure out\n"
"the return type. But during proof search, this type will\n"
"have to be derived by Idris based on the column name and\n"
"schema in question (otherwise, the proof search will fail\n"
"unless the return type is known in advance).\n"
"We therefore *must* tell Idris, that\n"
"it can't include this type in the list of search criteria,\n"
"otherwise it will try and infer the column type from the\n"
"context (using type inference) before running the proof\n"
"search. This can be done by listing the indices to be used in\n"
"the search like so: `[search name schema]`.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:603
#, no-wrap
msgid ""
"data InSchema :  (name    : String)\n"
"              -> (schema  : Schema)\n"
"              -> (colType : ColType)\n"
"              -> Type where\n"
"  [search name schema]\n"
"  IsHere  : InSchema n (n :> t :: ss) t\n"
"  IsThere : InSchema n ss t -> InSchema n (fld :: ss) t\n"
"\n"
"Uninhabited (InSchema n [] c) where\n"
"  uninhabited IsHere impossible\n"
"  uninhabited (IsThere _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:619
#, no-wrap
msgid ""
"With this, we are now ready to access the value\n"
"at a given column based on the column's name:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:620
#, no-wrap
msgid ""
"getAt :  {0 ss : Schema}\n"
"      -> (name : String)\n"
"      -> (row  : Row ss)\n"
"      -> (prf  : InSchema name ss c)\n"
"      => IdrisType c\n"
"getAt name (v :: vs) {prf = IsHere}    = v\n"
"getAt name (_ :: vs) {prf = IsThere p} = getAt name vs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:638
#, no-wrap
msgid ""
"Below is an example how to use this at compile time. Note\n"
"the amount of work Idris performs for us: It first comes\n"
"up with proofs that `firstName`, `lastName`, and `age`\n"
"are indeed valid names in the `Employee` schema. From\n"
"these proofs it automatically figures out the return types\n"
"of the calls to `getAt` and extracts the corresponding values\n"
"from the row. All of this happens in a provably total and type\n"
"safe way.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:639
#, no-wrap
msgid ""
"shoeck : String\n"
"shoeck =  getAt \"firstName\" hock\n"
"       ++ \" \"\n"
"       ++ getAt \"lastName\" hock\n"
"       ++ \": \"\n"
"       ++ show (getAt \"age\" hock)\n"
"       ++ \" years old.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:657
#, no-wrap
msgid ""
"In order to at runtime specify a column name, we need a way\n"
"for computing values of type `InSchema` by comparing\n"
"the column names with the schema in question. Since we have\n"
"to compare two string values for being propositionally equal,\n"
"we use the `DecEq` implementation for `String` here (Idris provides `DecEq`\n"
"implementations for all primitives). We extract the column type\n"
"at the same time and pair this (as a dependent pair) with\n"
"the `InSchema` proof:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:658
#, no-wrap
msgid ""
"inSchema : (ss : Schema) -> (n : String) -> Maybe (c ** InSchema n ss c)\n"
"inSchema []                    _ = Nothing\n"
"inSchema (MkColumn cn t :: xs) n = case decEq cn n of\n"
"  Yes Refl   => Just (t ** IsHere)\n"
"  No  contra => case inSchema xs n of\n"
"    Just (t ** prf) => Just $ (t ** IsThere prf)\n"
"    Nothing         => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:671
#, no-wrap
msgid ""
"At the end of this chapter we will use `InSchema` in\n"
"our CSV command-line application to list all values\n"
"in a column.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:676
#, no-wrap
msgid ""
"Show that `InSchema` is decidable by changing the output type\n"
"of `inSchema` to `Dec (c ** InSchema n ss c)`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:679
#, no-wrap
msgid ""
"Declare and implement a function for modifying a field\n"
"in a row based on the column name given.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:684
#, no-wrap
msgid ""
"Define a predicate to be used as a witness that one\n"
"list contains only elements in the second list in the\n"
"same order and use this predicate to extract several columns\n"
"from a row at once.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:688
#, no-wrap
msgid ""
"   For instance, `[2,4,5]` contains elements from\n"
"   `[1,2,3,4,5,6]` in the correct order, but `[4,2,5]`\n"
"   does not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:694
#, no-wrap
msgid ""
"Improve the functionality from exercise 3 by defining a new\n"
"predicate, witnessing that all strings in a list correspond\n"
"to column names in a schema (in arbitrary order).\n"
"Use this to extract several columns from a row at once in\n"
"arbitrary order.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:698
#, no-wrap
msgid ""
"   Hint: Make sure to include the resulting schema as an index,\n"
"   but search only based on the list of names and the input\n"
"   schema.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:699
#, no-wrap
msgid "Use Case: Flexible Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:718
#, no-wrap
msgid ""
"A recurring pattern when writing larger applications is\n"
"the combination of different parts of a program each with\n"
"their own failure types in a larger effectful computation.\n"
"We saw this, for instance, when implementing a command-line\n"
"tool for handling CSV files. There, we read and wrote data\n"
"from and to files, we parsed column types and schemata,\n"
"we parsed row and column indices and command-line commands.\n"
"All these operations came with the potential of failure and\n"
"might be implemented in different parts of our application.\n"
"In order to unify these different failure types, we wrote\n"
"a custom sum type encapsulating each of them, and wrote a\n"
"single handler for this sum type. This approach was alright\n"
"then, but it does not scale well and is lacking in terms of\n"
"flexibility. We are therefore trying a different\n"
"approach here. Before we continue, we quickly implement a\n"
"couple of functions with the potential of failure plus\n"
"some custom error types:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:719
#, no-wrap
msgid ""
"record NoNat where\n"
"  constructor MkNoNat\n"
"  str : String\n"
"\n"
"readNat' : String -> Either NoNat Nat\n"
"readNat' s = maybeToEither (MkNoNat s) $ parsePositive s\n"
"\n"
"record NoColType where\n"
"  constructor MkNoColType\n"
"  str : String\n"
"\n"
"readColType' : String -> Either NoColType ColType\n"
"readColType' \"I64\"     = Right I64\n"
"readColType' \"Str\"     = Right Str\n"
"readColType' \"Boolean\" = Right Boolean\n"
"readColType' \"Float\"   = Right Float\n"
"readColType' s         = Left $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:746
#, no-wrap
msgid ""
"However, if we wanted to parse a `Fin n`, there'd be already\n"
"two ways how this could fail: The string in question could not\n"
"represent a natural number (leading to a `NoNat` error), or it\n"
"could be out of bounds (leading to an `OutOfBounds` error).\n"
"We have to somehow encode these two possibilities in the\n"
"return type, for instance, by using an `Either` as the error\n"
"type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:747
#, no-wrap
msgid ""
"record OutOfBounds where\n"
"  constructor MkOutOfBounds\n"
"  size  : Nat\n"
"  index : Nat\n"
"\n"
"readFin' : {n : _} -> String -> Either (Either NoNat OutOfBounds) (Fin n)\n"
"readFin' s = do\n"
"  ix <- mapFst Left (readNat' s)\n"
"  maybeToEither (Right $ MkOutOfBounds n ix) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:767
#, no-wrap
msgid ""
"This is incredibly ugly. A custom sum type might have been slightly better,\n"
"but we still would have to use `mapFst` when invoking `readNat'`, and\n"
"writing custom sum types for every possible combination of errors\n"
"will get cumbersome very quickly as well.\n"
"What we are looking for, is a generalized sum type: A type\n"
"indexed by a list of types (the possible choices) holding\n"
"a single value of exactly one of the types in question.\n"
"Here is a first naive try:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:768
#, no-wrap
msgid ""
"data Sum : List Type -> Type where\n"
"  MkSum : (val : t) -> Sum ts\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:783
#, no-wrap
msgid ""
"However, there is a crucial piece of information missing:\n"
"We have not verified that `t` is an element of `ts`, nor\n"
"*which* type it actually is. In fact, this is another case\n"
"of an erased existential, and we will have no way to at runtime\n"
"learn something about `t`. What we need to do is to pair the value\n"
"with a proof, that its type `t` is an element of `ts`.\n"
"We could use `Elem` again for this, but for some use cases\n"
"we will require access to the number of types in the list.\n"
"We will therefore use a vector instead of a list as our index.\n"
"Here is a predicate similar to `Elem` but for vectors:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:784
#, no-wrap
msgid ""
"data Has :  (v : a) -> (vs  : Vect n a) -> Type where\n"
"  Z : Has v (v :: vs)\n"
"  S : Has v vs -> Has v (w :: vs)\n"
"\n"
"Uninhabited (Has v []) where\n"
"  uninhabited Z impossible\n"
"  uninhabited (S _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:797
#, no-wrap
msgid ""
"A value of type `Has v vs` is a witness that `v` is an\n"
"element of `vs`. With this, we can now implement an indexed\n"
"sum type (also called an *open union*):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:798
#, no-wrap
msgid ""
"data Union : Vect n Type -> Type where\n"
"  U : (ix : Has t ts) -> (val : t) -> Union ts\n"
"\n"
"Uninhabited (Union []) where\n"
"  uninhabited (U ix _) = absurd ix\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:811
#, no-wrap
msgid ""
"Note the difference between `HList` and `Union`. `HList` is\n"
"a *generalized product type*: It holds a value for each type\n"
"in its index. `Union` is a *generalized sum type*: It holds\n"
"only a single value, which must be of a type listed in the index.\n"
"With this we can now define a much more flexible error type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:812
#, no-wrap
msgid ""
"0 Err : Vect n Type -> Type -> Type\n"
"Err ts t = Either (Union ts) t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:820
#, no-wrap
msgid ""
"A function returning an `Err ts a` describes a computation, which\n"
"can fail with one of the errors listed in `ts`.\n"
"We first need some utility functions.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:821
#, no-wrap
msgid ""
"inject : (prf : Has t ts) => (v : t) -> Union ts\n"
"inject v = U prf v\n"
"\n"
"fail : Has t ts => (err : t) -> Err ts a\n"
"fail err = Left $ inject err\n"
"\n"
"failMaybe : Has t ts => (err : Lazy t) -> Maybe a -> Err ts a\n"
"failMaybe err = maybeToEither (inject err)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:834
#, no-wrap
msgid ""
"Next, we can write more flexible versions of the\n"
"parsers we wrote above:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:835
#, no-wrap
msgid ""
"readNat : Has NoNat ts => String -> Err ts Nat\n"
"readNat s = failMaybe (MkNoNat s) $ parsePositive s\n"
"\n"
"readColType : Has NoColType ts => String -> Err ts ColType\n"
"readColType \"I64\"     = Right I64\n"
"readColType \"Str\"     = Right Str\n"
"readColType \"Boolean\" = Right Boolean\n"
"readColType \"Float\"   = Right Float\n"
"readColType s         = fail $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:849
#, no-wrap
msgid ""
"Before we implement `readFin`, we introduce a short cut for\n"
"specifying that several error types must be present:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:850
#, no-wrap
msgid ""
"0 Errs : List Type -> Vect n Type -> Type\n"
"Errs []        _  = ()\n"
"Errs (x :: xs) ts = (Has x ts, Errs xs ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:860
#, no-wrap
msgid ""
"Function `Errs` returns a tuple of constraints. This can\n"
"be used as a witness that all listed types are present\n"
"in the vector of types: Idris will automatically extract\n"
"the proofs from the tuple as needed.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:862
#, no-wrap
msgid ""
"readFin : {n : _} -> Errs [NoNat, OutOfBounds] ts => String -> Err ts (Fin n)\n"
"readFin s = do\n"
"  S ix <- readNat s | Z => fail (MkOutOfBounds n Z)\n"
"  failMaybe (MkOutOfBounds n (S ix)) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:871
#, no-wrap
msgid ""
"As a last example, here are parsers for schemata and\n"
"CSV rows:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:872
#, no-wrap
msgid ""
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"record InvalidColumn where\n"
"  constructor MkInvalidColumn\n"
"  str : String\n"
"\n"
"readColumn : Errs [InvalidColumn, NoColType] ts => String -> Err ts Column\n"
"readColumn s = case forget $ split (':' ==) s of\n"
"  [n,ct] => MkColumn n <$> readColType ct\n"
"  _      => fail $ MkInvalidColumn s\n"
"\n"
"readSchema : Errs [InvalidColumn, NoColType] ts => String -> Err ts Schema\n"
"readSchema = traverse readColumn . fromCSV\n"
"\n"
"data RowError : Type where\n"
"  InvalidField  : (row, col : Nat) -> (ct : ColType) -> String -> RowError\n"
"  UnexpectedEOI : (row, col : Nat) -> RowError\n"
"  ExpectedEOI   : (row, col : Nat) -> RowError\n"
"\n"
"decodeField :  Has RowError ts\n"
"            => (row,col : Nat)\n"
"            -> (c : ColType)\n"
"            -> String\n"
"            -> Err ts (IdrisType c)\n"
"decodeField row col c s =\n"
"  let err = InvalidField row col c s\n"
"   in case c of\n"
"        I64     => failMaybe err $ read s\n"
"        Str     => failMaybe err $ read s\n"
"        Boolean => failMaybe err $ read s\n"
"        Float   => failMaybe err $ read s\n"
"\n"
"decodeRow :  Has RowError ts\n"
"          => {s : _}\n"
"          -> (row : Nat)\n"
"          -> (str : String)\n"
"          -> Err ts (Row s)\n"
"decodeRow row = go 1 s . fromCSV\n"
"  where go : Nat -> (cs : Schema) -> List String -> Err ts (Row cs)\n"
"        go k []       []                    = Right []\n"
"        go k []       (_ :: _)              = fail $ ExpectedEOI row k\n"
"        go k (_ :: _) []                    = fail $ UnexpectedEOI row k\n"
"        go k (MkColumn n c :: cs) (s :: ss) =\n"
"          [| decodeField row k c s :: go (S k) cs ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:925
#, no-wrap
msgid ""
"Here is an example REPL session, where I test `readSchema`. I defined\n"
"variable `ts` using the `:let` command to make this more convenient.\n"
"Note, how the order of error types is of no importance, as long\n"
"as types `InvalidColumn` and `NoColType` are present in the list of\n"
"errors:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:926
#, no-wrap
msgid ""
"Tutorial.Predicates> :let ts = the (Vect 3 _) [NoColType,NoNat,InvalidColumn]\n"
"Tutorial.Predicates> readSchema {ts} \"foo:bar\"\n"
"Left (U Z (MkNoColType \"bar\"))\n"
"Tutorial.Predicates> readSchema {ts} \"foo:Float\"\n"
"Right [MkColumn \"foo\" Float]\n"
"Tutorial.Predicates> readSchema {ts} \"foo Float\"\n"
"Left (U (S (S Z)) (MkInvalidColumn \"foo Float\"))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:936
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:943
#, no-wrap
msgid ""
"There are several techniques for handling errors, all of which\n"
"are useful at times. For instance, we might want to handle some\n"
"errors early on and individually, while dealing with others\n"
"much later in our application. Or we might want to handle\n"
"them all in one fell swoop. We look at both approaches here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:950
#, no-wrap
msgid ""
"First, in order to handle a single error individually, we need\n"
"to *split* a union into one of two possibilities: A value of\n"
"the error type in question or a new union, holding one of the\n"
"other error types. We need a new predicate for this, which\n"
"not only encodes the presence of a value in a vector\n"
"but also the result of removing that value:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:951
#, no-wrap
msgid ""
"data Rem : (v : a) -> (vs : Vect (S n) a) -> (rem : Vect n a) -> Type where\n"
"  [search v vs]\n"
"  RZ : Rem v (v :: rem) rem\n"
"  RS : Rem v vs rem -> Rem v (w :: vs) (w :: rem)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:962
#, no-wrap
msgid ""
"Once again, we want to use one of the indices (`rem`) in our\n"
"functions' return types, so we only use the other indices during\n"
"proof search. Here is a function for splitting off a value from\n"
"an open union:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:963
#, no-wrap
msgid ""
"split : (prf : Rem t ts rem) => Union ts -> Either t (Union rem)\n"
"split {prf = RZ}   (U Z     val) = Left val\n"
"split {prf = RZ}   (U (S x) val) = Right (U x val)\n"
"split {prf = RS p} (U Z     val) = Right (U Z val)\n"
"split {prf = RS p} (U (S x) val) = case split {prf = p} (U x val) of\n"
"  Left vt        => Left vt\n"
"  Right (U ix y) => Right $ U (S ix) y\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:977
#, no-wrap
msgid ""
"This tries to extract a value of type `t` from a union. If it works,\n"
"the result is wrapped in a `Left`, otherwise a new union is returned\n"
"in a `Right`, but this one has `t` removed from its list of possible\n"
"types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:982
#, no-wrap
msgid ""
"With this, we can implement a handler for single errors.\n"
"Error handling often happens in an effectful context (we might want to\n"
"print a message to the console or write the error to a log file), so\n"
"we use an applicative effect type to handle errors in.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:983
#, no-wrap
msgid ""
"handle :  Applicative f\n"
"       => Rem t ts rem\n"
"       => (h : t -> f a)\n"
"       -> Err ts a\n"
"       -> f (Err rem a)\n"
"handle h (Left x)  = case split x of\n"
"  Left v    => Right <$> h v\n"
"  Right err => pure $ Left err\n"
"handle _ (Right x) = pure $ Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:998
#, no-wrap
msgid ""
"For handling all errors at once, we can use a handler type\n"
"indexed by the vector of errors, and parameterized by the\n"
"output type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:999
#, no-wrap
msgid ""
"namespace Handler\n"
"  public export\n"
"  data Handler : (ts : Vect n Type) -> (a : Type) -> Type where\n"
"    Nil  : Handler [] a\n"
"    (::) : (t -> a) -> Handler ts a -> Handler (t :: ts) a\n"
"\n"
"extract : Handler ts a -> Has t ts -> t -> a\n"
"extract (f :: _)  Z     val = f val\n"
"extract (_ :: fs) (S y) val = extract fs y val\n"
"extract []        ix    _   = absurd ix\n"
"\n"
"handleAll : Applicative f => Handler ts (f a) -> Err ts a -> f a\n"
"handleAll _ (Right v)       = pure v\n"
"handleAll h (Left $ U ix v) = extract h ix v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1019
#, no-wrap
msgid ""
"Below, we will see an additional way of handling all\n"
"errors at once by defining a custom interface for\n"
"error handling.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:1023
#, no-wrap
msgid "Implement the following utility functions for `Union`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1024
#, no-wrap
msgid ""
"   project : (0 t : Type) -> (prf : Has t ts) => Union ts -> Maybe t\n"
"\n"
"   project1 : Union [t] -> t\n"
"\n"
"   safe : Err [] a -> a\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:1034
#, no-wrap
msgid ""
"Implement the following two functions for embedding\n"
"an open union in a larger set of possibilities.\n"
"Note the unerased implicit in `extend`!\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1035
#, no-wrap
msgid ""
"   weaken : Union ts -> Union (ts ++ ss)\n"
"\n"
"   extend : {m : _} -> {0 pre : Vect m _} -> Union ts -> Union (pre ++ ts)\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:1043
#, no-wrap
msgid ""
"Find a general way to embed a `Union ts` in a `Union ss`,\n"
"so that the following is possible:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1044
#, no-wrap
msgid ""
"   embedTest :  Err [NoNat,NoColType] a\n"
"             -> Err [FileError, NoColType, OutOfBounds, NoNat] a\n"
"   embedTest = mapFst embed\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:1052
#, no-wrap
msgid ""
"Make `handle` more powerful, by letting the handler convert\n"
"the error in question to an `f (Err rem a)`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:1053
#, no-wrap
msgid "The Truth about Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1065
#, no-wrap
msgid ""
"Well, here it finally is: The truth about interfaces. Internally,\n"
"an interface is just a record data type, with its fields corresponding\n"
"to the members of the interface. An interface implementation is\n"
"a *value* of such a record, annotated with a `%hint` pragma (see\n"
"below) to make the value available during proof search. Finally,\n"
"a constrained function is just a function with one or more auto implicit\n"
"arguments. For instance, here is the same function for looking up\n"
"an element in a list, once with the known syntax for constrained\n"
"functions, and once with an auto implicit argument. The code\n"
"produced by Idris is the same in both cases:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1066
#, no-wrap
msgid ""
"isElem1 : Eq a => a -> List a -> Bool\n"
"isElem1 v []        = False\n"
"isElem1 v (x :: xs) = x == v || isElem1 v xs\n"
"\n"
"isElem2 : {auto _ : Eq a} -> a -> List a -> Bool\n"
"isElem2 v []        = False\n"
"isElem2 v (x :: xs) = x == v || isElem2 v xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1079
#, no-wrap
msgid ""
"Being mere records, we can also take interfaces as\n"
"regular function arguments and dissect them with a pattern\n"
"match:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1080
#, no-wrap
msgid ""
"eq : Eq a -> a -> a -> Bool\n"
"eq (MkEq feq fneq) = feq\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:1085
#, no-wrap
msgid "A manual Interface Definition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1093
#, no-wrap
msgid ""
"I'll now demonstrate how we can achieve the same behavior\n"
"with proof search as with a regular interface definition\n"
"plus implementations. Since I want to finish the CSV\n"
"example with our new error handling tools, we are\n"
"going to implement some error handlers.\n"
"First, an interface is just a record:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1094
#, no-wrap
msgid ""
"record Print a where\n"
"  constructor MkPrint\n"
"  print' : a -> String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1104
#, no-wrap
msgid ""
"In order to access the record in a constrained function,\n"
"we use the `%search` keyword, which will try to conjure a\n"
"value of the desired type (`Print a` in this case) by\n"
"means of a proof search:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1105
#, no-wrap
msgid ""
"print : Print a => a -> String\n"
"print = print' %search\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1112
#, no-wrap
msgid ""
"As an alternative, we could use a named constraint, and access\n"
"it directly via its name:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1113
#, no-wrap
msgid ""
"print2 : (impl : Print a) => a -> String\n"
"print2 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1120
#, no-wrap
msgid ""
"As yet another alternative, we could use the syntax for auto\n"
"implicit arguments:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1121
#, no-wrap
msgid ""
"print3 : {auto impl : Print a} -> a -> String\n"
"print3 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1129
#, no-wrap
msgid ""
"All three versions of `print` behave exactly the same at runtime.\n"
"So, whenever we write `{auto x : Foo} ->` we can just as well\n"
"write `(x : Foo) =>` and vice versa.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1133
#, no-wrap
msgid ""
"Interface implementations are just values of the given\n"
"record type, but in order to be available during proof search,\n"
"these need to be annotated with a `%hint` pragma:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1134
#, no-wrap
msgid ""
"%hint\n"
"noNatPrint : Print NoNat\n"
"noNatPrint = MkPrint $ \\e => \"Not a natural number: \\{e.str}\"\n"
"\n"
"%hint\n"
"noColTypePrint : Print NoColType\n"
"noColTypePrint = MkPrint $ \\e => \"Not a column type: \\{e.str}\"\n"
"\n"
"%hint\n"
"outOfBoundsPrint : Print OutOfBounds\n"
"outOfBoundsPrint = MkPrint $ \\e => \"Index is out of bounds: \\{show e.index}\"\n"
"\n"
"%hint\n"
"rowErrorPrint : Print RowError\n"
"rowErrorPrint = MkPrint $\n"
"  \\case InvalidField r c ct s =>\n"
"          \"Not a \\{show ct} in row \\{show r}, column \\{show c}. \\{s}\"\n"
"        UnexpectedEOI r c =>\n"
"          \"Unexpected end of input in row \\{show r}, column \\{show c}.\"\n"
"        ExpectedEOI r c =>\n"
"          \"Expected end of input in row \\{show r}, column \\{show c}.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1162
#, no-wrap
msgid ""
"We can also write an implementation of `Print` for\n"
"a union or errors. For this, we first come up with a\n"
"proof that all types in the union's index come with an\n"
"implementation of `Print`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1163
#, no-wrap
msgid ""
"0 All : (f : a -> Type) -> Vect n a -> Type\n"
"All f []        = ()\n"
"All f (x :: xs) = (f x, All f xs)\n"
"\n"
"unionPrintImpl : All Print ts => Union ts -> String\n"
"unionPrintImpl (U Z val)     = print val\n"
"unionPrintImpl (U (S x) val) = unionPrintImpl $ U x val\n"
"\n"
"%hint\n"
"unionPrint : All Print ts => Print (Union ts)\n"
"unionPrint = MkPrint unionPrintImpl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1184
#, no-wrap
msgid ""
"Defining interfaces this way can be an advantage, as there\n"
"is much less magic going on, and we have more fine grained\n"
"control over the types and values of our fields. Note also,\n"
"that all of the magic comes from the search hints, with\n"
"which our \"interface implementations\" were annotated.\n"
"These made the corresponding values and functions available\n"
"during proof search.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Predicates.md:1185
#, no-wrap
msgid "Parsing CSV Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1195
#, no-wrap
msgid ""
"To conclude this chapter, we reimplement our CSV command\n"
"parser, using the flexible error handling approach from\n"
"the last section. While not necessarily less verbose than\n"
"the original parser, this approach decouples the handling\n"
"of errors and printing of error messages from the rest\n"
"of the application: Functions with a possibility of failure\n"
"are reusable in different contexts, as are the pretty\n"
"printers we use for the error messages.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1198
#, no-wrap
msgid ""
"First, we repeat some stuff from earlier chapters. I sneaked\n"
"in a new command for printing all values in a column:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1199
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"data Command : (t : Table) -> Type where\n"
"  PrintSchema :  Command t\n"
"  PrintSize   :  Command t\n"
"  New         :  (newSchema : Schema) -> Command t\n"
"  Prepend     :  Row (schema t) -> Command t\n"
"  Get         :  Fin (size t) -> Command t\n"
"  Delete      :  Fin (size t) -> Command t\n"
"  Col         :  (name : String)\n"
"              -> (tpe  : ColType)\n"
"              -> (prf  : InSchema name t.schema tpe)\n"
"              -> Command t\n"
"  Quit        : Command t\n"
"\n"
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand t                 (Col _ _ _) = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1235
#, no-wrap
msgid ""
"Next, below is the command parser reimplemented. In total,\n"
"it can fail in seven different was, at least some of which\n"
"might also be possible in other parts of a larger application.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1236
#, no-wrap
msgid ""
"record UnknownCommand where\n"
"  constructor MkUnknownCommand\n"
"  str : String\n"
"\n"
"%hint\n"
"unknownCommandPrint : Print UnknownCommand\n"
"unknownCommandPrint = MkPrint $ \\v => \"Unknown command: \\{v.str}\"\n"
"\n"
"record NoColName where\n"
"  constructor MkNoColName\n"
"  str : String\n"
"\n"
"%hint\n"
"noColNamePrint : Print NoColName\n"
"noColNamePrint = MkPrint $ \\v => \"Unknown column: \\{v.str}\"\n"
"\n"
"0 CmdErrs : Vect 7 Type\n"
"CmdErrs = [ InvalidColumn\n"
"          , NoColName\n"
"          , NoColType\n"
"          , NoNat\n"
"          , OutOfBounds\n"
"          , RowError\n"
"          , UnknownCommand ]\n"
"\n"
"readCommand : (t : Table) -> String -> Err CmdErrs (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow 1 (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  [\"column\", str] => case inSchema ts str of\n"
"    Just (ct ** prf) => Right $ Col str ct prf\n"
"    Nothing          => fail $ MkNoColName str\n"
"  _               => fail $ MkUnknownCommand s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1280
#, no-wrap
msgid ""
"Note, how we could invoke functions like `readFin` or\n"
"`readSchema` directly, because the necessary error types\n"
"are part of our list of possible errors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1286
#, no-wrap
msgid ""
"To conclude this sections, here is the functionality\n"
"for printing the result of a command plus the application's\n"
"main loop. Most of this is repeated from earlier chapters,\n"
"but note how we can handle all errors at once with a single\n"
"call to `print`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1287
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (s : Schema) -> Row s -> String\n"
"encodeRow s = concat . intersperse \",\" . go s\n"
"  where go : (s' : Schema) -> Row s' -> Vect (length s') String\n"
"        go []        []        = []\n"
"        go (MkColumn _ c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"encodeCol :  (name : String)\n"
"          -> (c    : ColType)\n"
"          -> InSchema name s c\n"
"          => Vect n (Row s)\n"
"          -> String\n"
"encodeCol name c = unlines . toList . map (\\r => encodeField c $ getAt name r)\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema   = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize     = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)      = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r)   = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)    = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit          = \"Goodbye.\"\n"
"result t (Col n c prf) = \"Column \\{n}:\\n\\{encodeCol n c t.rows}\"\n"
"result t (Get x)       =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (print err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1336
#, no-wrap
msgid "Here is an example REPL session:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:1337
#, no-wrap
msgid ""
"Tutorial.Predicates> :exec main\n"
"Enter a command: new name:Str,age:Int64,salary:Float\n"
"Not a column type: Int64\n"
"Enter a command: new name:Str,age:I64,salary:Float\n"
"Created table. Schema: name:Str,age:I64,salary:Float\n"
"Enter a command: add John Doe,44,3500\n"
"Row prepended: \"John Doe\",44,3500.0\n"
"Enter a command: add Jane Doe,50,4000\n"
"Row prepended: \"Jane Doe\",50,4000.0\n"
"Enter a command: get 1\n"
"Row 1: \"Jane Doe\",50,4000.0\n"
"Enter a command: column salary\n"
"Column salary:\n"
"4000.0\n"
"3500.0\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1367
#, no-wrap
msgid ""
"Predicates allow us to describe contracts between types\n"
"and to refine the values we accept as valid function arguments.\n"
"They allow us to make a function safe and convenient to use\n"
"at runtime *and* compile time by using them as auto implicit\n"
"arguments, which Idris should try to construct on its own if\n"
"it has enough information about the structure of a function's\n"
"arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1369
#, no-wrap
msgid "[Next chapter](./Prim.md)\n"
msgstr ""
