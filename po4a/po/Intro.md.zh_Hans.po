# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, fuzzy, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:90
#, no-wrap
msgid "Dependent Types"
msgstr "依赖类型"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1423 ../src/Tutorial/Intro.md:444
#, no-wrap
msgid "What's next?"
msgstr "下一步是什么？"

#. type: Title #
#: ../src/Tutorial/Intro.md:1
#, no-wrap
msgid "Introduction"
msgstr "介绍"

#. type: Plain text
#: ../src/Tutorial/Intro.md:15
#, fuzzy, no-wrap
msgid ""
"Welcome to my Idris 2 tutorial. I'll try and treat as many aspects\n"
"of the Idris 2 programming language as possible here.\n"
"All `.md` files in here are literate Idris files: They consist of\n"
"Markdown (hence the `.md` ending), which is being pretty printed\n"
"by GitHub together with Idris code blocks, which can be\n"
"type checked and built by the Idris compiler (more on this later).\n"
"Note, however, that regular Idris source files use an `.idr` ending,\n"
"and that you go with that file type unless you end up writing\n"
"much more prose than code as I do at the moment. Later in this\n"
"tutorial, you'll have to solve some exercises, the solutions of\n"
"which can be found in the `src/Solutions` subfolder. There, I\n"
"use regular `.idr` files.\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:23
#, no-wrap
msgid ""
"Before we begin, make sure to install the Idris compiler on your system.\n"
"Throughout this tutorial, I assume you installed the *pack* package\n"
"manager and setup a skeleton package as described\n"
"[here](../Appendices/Install.md). It is\n"
"certainly possible to follow along with just the Idris compiler installed\n"
"by other means, but some adjustments will be necessary\n"
"when starting REPL sessions or building executables.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:27
#, no-wrap
msgid ""
"Every Idris source file should typically start with a module\n"
"name plus some necessary imports, and this document is no\n"
"exception:\n"
msgstr "每个 Idris 源文件通常应该以模块名称和一些必要的导入开头，本文档也不例外。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:28
#, no-wrap
msgid "module Tutorial.Intro\n"
msgstr "module Tutorial.Intro\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:35
#, no-wrap
msgid ""
"A module name consists of a list of identifiers separated\n"
"by dots and must reflect the folder structure plus the module\n"
"file's name.\n"
msgstr "模块名称由以点分隔的标识符列表组成，并且必须反映文件夹结构加上模块文件的名称。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:36
#, no-wrap
msgid "About the Idris Programming Language"
msgstr "关于 Idris 编程语言"

#. type: Plain text
#: ../src/Tutorial/Intro.md:41
#, no-wrap
msgid ""
"Idris is a *pure*, *dependently typed*, *total* *functional*\n"
"programming language. I'll quickly explain each of these adjectives\n"
"in this section.\n"
msgstr "Idris 是一种具有*依赖类型*的、*完全*的*纯**函数式*编程语言。我将在本节中快速解释这些形容词。\n"

#. type: Title ###
#: ../src/Tutorial/Intro.md:42
#, no-wrap
msgid "Functional Programming"
msgstr "函数式编程"

#. type: Plain text
#: ../src/Tutorial/Intro.md:56
#, fuzzy, no-wrap
msgid ""
"In functional programming languages, functions are first-class\n"
"constructs, meaning that they can be assigned to variables,\n"
"passed as arguments to other functions, and returned as results\n"
"from functions. Unlike for instance in\n"
"object-oriented programming languages, in functional programming,\n"
"functions are the main form of abstraction. This means that whenever\n"
"we find a common pattern or (almost) identical code in several\n"
"parts of a project, we try to abstract over this in order to\n"
"have to write the corresponding code only once.\n"
"We do this by introducing one or more new functions\n"
"implementing this behavior. Doing so, we often try to be as general\n"
"as possible to make our functions as versatile to use as possible.\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:60
#, no-wrap
msgid ""
"Functional programming languages are concerned with the evaluation\n"
"of functions, unlike classical imperative languages, which are\n"
"concerned with the execution of statements.\n"
msgstr "函数式编程语言关注函数的求值，不像经典的命令式语言关注语句的执行。\n"

#. type: Title ###
#: ../src/Tutorial/Intro.md:61
#, no-wrap
msgid "Pure Functional Programming"
msgstr "纯函数式编程"

#. type: Plain text
#: ../src/Tutorial/Intro.md:71
#, no-wrap
msgid ""
"Pure functional programming languages come with an additional\n"
"important guarantee: Functions don't have side effects like\n"
"writing to a file or mutating global state. They can only\n"
"compute a result from their arguments possibly by invoking other\n"
"pure functions, *and nothing else*. As a consequence, given\n"
"the same input, they will *always* generate the same output.\n"
"This property is known as\n"
"[referential transparency](https://en.wikipedia.org/wiki/Referential_transparency).\n"
msgstr "纯函数式编程语言有一个额外的重要保证：函数不会产生像写入文件或改变全局状态这样的副作用。他们只能通过调用其他纯函数，给定参数来获取计算结果，*而没有其它的途径*。因此，给定相同的输入，它们将*总是*生成相同的输出。此属性称为 [引用透明](https://en.wikipedia.org/wiki/Referential_transparency)。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:73
#, no-wrap
msgid "Pure functions have several advantages:\n"
msgstr "纯函数有几个优点：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:76
#, no-wrap
msgid ""
"They can easily be tested by specifying (possibly randomly generated)\n"
"sets of input arguments together with the expected results.\n"
msgstr "它们可以通过指定（可能是随机生成的）输入参数集以及预期结果来轻松测试。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:80
#, fuzzy, no-wrap
msgid ""
"They are thread-safe, since they don't mutate global state, and\n"
"as such can be freely used in several computations running\n"
"in parallel.\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使用。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:82
#, no-wrap
msgid "There are, of course, also some disadvantages:\n"
msgstr "当然，也有一些缺点：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:85
#, no-wrap
msgid ""
"Some algorithms are hard to implement efficiently using\n"
"only pure functions.\n"
msgstr "仅使用纯函数很难有效地实现某些算法。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:89
#, no-wrap
msgid ""
"Writing programs that actually *do* something\n"
"(have some observable effect) is a bit trickier but certainly\n"
"possible.\n"
msgstr "编写实际上*做*某些事情（具有一些可观察到的效果）的程序有点棘手，但肯定是可能的。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:97
#, fuzzy, no-wrap
msgid ""
"Idris is a strongly, statically typed programming language. This\n"
"means that every Idris expression is given a *type* (for instance:\n"
"integer, list of strings, boolean, function from integer to boolean, etc.)\n"
"and types are verified at compile time to rule out certain\n"
"common programming errors.\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"Idris 是一种强静态类型的编程语言。这意味着，会给每个 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:103
#, no-wrap
msgid ""
"For instance, if a function expects an argument of type `String`\n"
"(a sequence of unicode characters, such as `\"Hello123\"`), it\n"
"is a *type error* to invoke this function with an argument of\n"
"type `Integer`, and the Idris compiler will refuse to\n"
"generate an executable from such an ill-typed program.\n"
msgstr "例如，如果一个函数需要 `String` 类型的参数（Unicode 字符序列，例如 `\"Hello123\"`），使用 `Integer` 类型的参数调用此函数是*类型错误*的，Idris 编译器将拒绝从此类错误类型的程序生成可执行文件。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:111
#, no-wrap
msgid ""
"Being *statically typed* means that the Idris compiler will catch\n"
"type errors at *compile time*, that is, before it generates an executable\n"
"program that can be run. The opposite to this are *dynamically typed*\n"
"languages such as Python, which check for type errors at *runtime*, that is,\n"
"when a program is being executed. It is the philosophy of statically typed\n"
"languages to catch as many type errors as possible before there even is\n"
"a program that can be run.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:119
#, no-wrap
msgid ""
"Even more, Idris is *dependently typed*, which is one of its most\n"
"characteristic properties in the landscape of programming\n"
"languages. In Idris, types are *first class*: Types can be passed\n"
"as arguments to functions, and functions can return types as\n"
"their results. Even more, types can *depend* on other *values*.\n"
"What this means, and why this is incredibly useful, we'll explore\n"
"in due time.\n"
msgstr "更重要的是，Idris 具有*依赖类型*，这是它在编程语言领域中最具特色的属性之一。在 Idris 中，类型是*一等*的：类型可以作为参数传递给函数，函数可以返回类型作为结果。更重要的是，类型可以*依赖于*其他*值*。这意味着什么，以及为什么这非常有用，我们将在适当的时候进行探索。\n"

#. type: Title ###
#: ../src/Tutorial/Intro.md:120
#, no-wrap
msgid "Total Functions"
msgstr "全函数"

#. type: Plain text
#: ../src/Tutorial/Intro.md:127
#, fuzzy, no-wrap
msgid ""
"A *total* function is a pure function, that is guaranteed to return\n"
"a value of the expected return type for every possible input in\n"
"a finite number of computational steps. A total function will never fail with an\n"
"exception or loop infinitely, although it can still take arbitrarily\n"
"long to compute its result\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:136
#, no-wrap
msgid ""
"Idris comes with a totality checker built-in, which enables us to\n"
"verify the functions we write to be provably total. Totality\n"
"in Idris is opt-in, as in general, checking the totality of\n"
"an arbitrary computer program is undecidable\n"
"(see also the [halting problem](https://en.wikipedia.org/wiki/Halting_problem)).\n"
"However, if we annotate a function with the `total` keyword,\n"
"Idris will fail with a type error, if its totality checker\n"
"cannot verify that the function in question is indeed total.\n"
msgstr "Idris 内置了一个完全性检查器，它使我们能够验证我们编写的函数是否是可证明的完全性。 Idris 中的完全性是可选的，因为一般来说，检查任意计算机程序的完全性是无法确定的（另请参见 [停机问题](https://en.wikipedia.org/wiki/Halting_problem)）。但是，如果我们使用 `total` 关键字注释函数，如果 Idris 的完全性检查器无法验证所讨论的函数确实是完全的，则 Idris 将失败并出现类型错误。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:137
#, no-wrap
msgid "Using the REPL"
msgstr "使用 REPL"

#. type: Plain text
#: ../src/Tutorial/Intro.md:144
#, no-wrap
msgid ""
"Idris comes with a useful REPL (an acronym for *Read Evaluate\n"
"Print Loop*), which we will use for tinkering with small\n"
"ideas, and for quickly experimenting with the code we just wrote.\n"
"In order to start a REPL session, run the following command\n"
"in a terminal:\n"
msgstr "Idris 附带了一个有用的 REPL（*Read Evaluate Print Loop* 的首字母缩写词），我们将使用它来修补小想法，并快速试验我们刚刚编写的代码。要启动 REPL 会话，请在终端中运行以下命令：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:145
#, no-wrap
msgid "pack repl\n"
msgstr "pack repl\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:150
#, no-wrap
msgid "Idris should now be ready to accept you commands:\n"
msgstr "Idris 现在应该准备好接受你的命令了：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:151
#, no-wrap
msgid ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"
msgstr ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:164
#, no-wrap
msgid ""
"We can go ahead and enter some simple arithmetic expressions. Idris\n"
"will *evaluate* these and print the result:\n"
msgstr "我们可以继续输入一些简单的算术表达式。 Idris 将进行*求值*并打印结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:165
#, no-wrap
msgid ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"
msgstr ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:174
#, no-wrap
msgid ""
"Since every expression in Idris has an associated *type*,\n"
"we might want to inspect these as well:\n"
msgstr "由于 Idris 中的每个表达式都有一个关联的*类型*，我们可能还想检查这些：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:175
#, no-wrap
msgid ""
"Main> :t 2\n"
"2 : Integer\n"
msgstr ""
"Main> :t 2\n"
"2 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:183
#, no-wrap
msgid ""
"Here `:t` is a command of the Idris REPL (it is not part of the\n"
"Idris programming language), and it is used to inspect the type\n"
"of an expression.\n"
msgstr "这里的 `:t` 是 Idris REPL 的命令（它不是 Idris 编程语言的一部分），它用于检查表达式的类型。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:184
#, no-wrap
msgid ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"
msgstr ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid ""
"Whenever we perform calculations with integer literals without\n"
"being explicit about the types we want to use, Idris will\n"
"use `Integer` as a default. `Integer` is an arbitrary precision\n"
"signed integer type. It is one of the *primitive types* built\n"
"into the language. Other primitives include fixed precision\n"
"signed and unsigned integral types (`Bits8`, `Bits16`, `Bits32`\n"
"`Bits64`, `Int8`, `Int16`, `Int32`, and `Int64`), double\n"
"precision (64 bit) floating point numbers (`Double`), unicode\n"
"characters (`Char`) and strings of unicode characters (`String`).\n"
"We will use many of these in due time.\n"
msgstr "每当我们使用整数字面量执行计算而没有明确说明我们想要使用的类型时，Idris 将使用 `Integer` 作为默认值。 `Integer` 是任意精度的有符号整数类型。它是语言中内置的*原语类型*之一。其他原语包括固定精度有符号和无符号整数类型（`Bits8`、`Bits16`、`Bits32` `Bits64`、`Int8`、 `Int16`、`Int32` 和 `Int64`）、双精度（64 位）浮点数（`Double`）、Unicode 字符（`Char`) 和 Unicode 字符串 (`String`)。我们将在适当的时候会使用到大多数。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:200
#, no-wrap
msgid "A First Idris Program"
msgstr "第一个 Idris 程序"

#. type: Plain text
#: ../src/Tutorial/Intro.md:207
#, no-wrap
msgid ""
"We will often start up a REPL for tinkering with small parts\n"
"of the Idris language, for reading some documentation, or\n"
"for inspecting the content of an Idris module, but now we will\n"
"write a minimal Idris program to get started with\n"
"the language. Here comes the mandatory *Hello World*:\n"
msgstr "我们经常会启动一个 REPL 来修补 Idris 语言的一小部分，阅读一些文档，或检查 Idris 模块的内容，但现在我们将编写一个最小的 Idris 程序来开始使用该语言。这是强制性的 *Hello World*：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:208
#, no-wrap
msgid ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"
msgstr ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:216
#, no-wrap
msgid ""
"We will inspect the code above in some detail in a moment,\n"
"but first we'd like to compile and run it. From this project's\n"
"root directory, run the following:\n"
msgstr "稍后我们将详细检查上面的代码，但首先我们要编译并运行它。在此项目的根目录中，运行以下命令：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:216
#, no-wrap
msgid "pack -o hello exec src/Tutorial/Intro.md\n"
msgstr "pack -o hello exec src/Tutorial/Intro.md\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:224
#, no-wrap
msgid ""
"This will create executable `hello` in directory `build/exec`,\n"
"which can be invoked from the command-line like so (without the\n"
"dollar prefix; this is used here to distinguish the terminal command\n"
"from its output):\n"
msgstr "这将在目录 `build/exec` 中创建可执行文件 `hello`，可以像这样从命令行调用它（没有美元前缀；这里用来区分终端命令和它的输出）：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:225
#, no-wrap
msgid ""
"$ build/exec/hello\n"
"Hello World!\n"
msgstr ""
"$ build/exec/hello\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:238
#, fuzzy, no-wrap
msgid ""
"The pack program requires an `.ipkg` to be in scope (in the current\n"
"directory or one of its parent directories) from which\n"
"it will get other settings like the source directory to use\n"
"(`src` in our case). The optional `-o` option gives the name of the\n"
"executable to be generated. Pack comes up with a name of its own\n"
"it this is missing. Type `pack help` for a list\n"
"of available command-line options and commands, and `pack help <cmd>`\n"
"for getting help for a specific command.\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:241
#, no-wrap
msgid ""
"As an alternative, you can also load this source file in a REPL\n"
"session and invoke function `main` from there:\n"
msgstr "作为替代方案，您还可以在 REPL 会话中加载此源文件并从那里调用函数 `main`：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:242
#, no-wrap
msgid "pack repl src/Tutorial/Intro.md\n"
msgstr "pack repl src/Tutorial/Intro.md\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:246
#, no-wrap
msgid ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"
msgstr ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:253
#, no-wrap
msgid ""
"Go ahead and try both ways of building and running function `main`\n"
"on your system!\n"
msgstr "继续尝试在您的系统上构建和运行函数 `main` 的两种方法！\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:254
#, no-wrap
msgid "The Shape of an Idris Definition"
msgstr "如何声明一个 Idris 定义"

#. type: Plain text
#: ../src/Tutorial/Intro.md:258
#, no-wrap
msgid ""
"Now that we executed our first Idris program, we will talk\n"
"a bit more about the code we had to write to define it.\n"
msgstr "现在我们执行了第一个 Idris 程序，接下来我们将更多地讨论我们如何编写代码来定义它。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:265
#, no-wrap
msgid ""
"A typical top level function in Idris consists of three things:\n"
"The function's name (`main` in our case), its type (`IO ()`)\n"
"plus its implementation (`putStrLn \"Hello World\"`). It is easier\n"
"to explain these things with a couple of simple examples. Below,\n"
"we define a top level constant for the largest unsigned eight bit\n"
"integer:\n"
msgstr "Idris 中一个典型的顶级函数由三部分组成：函数的名称（在我们的例子中是 `main`），它的类型（`IO ()`）加上它的实现（`putStrLn \"你好世界”`）。用几个简单的例子来解释这些事情会更容易。下面，我们为最大的无符号八位整数定义一个顶级常量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:266
#, no-wrap
msgid ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"
msgstr ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:280
#, fuzzy, no-wrap
msgid ""
"The first line can be read as: \"We'd like to declare  (nullary)\n"
"function `maxBits8`. It is of type `Bits8`\". This is\n"
"called the *function declaration*: we declare that there\n"
"shall be a function of the given name and type. The second line\n"
"reads: \"The result of invoking `maxBits8` should be `255`.\"\n"
"(As you can see, we can use integer literals for other integral\n"
"types than just `Integer`.) This is called the *function definition*:\n"
"Function `maxBits8` should behave as described here when being\n"
"evaluated.\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:283
#, no-wrap
msgid ""
"We can inspect this at the REPL. Load this source file into\n"
"an Idris REPL (as described above), and run the following tests.\n"
msgstr "我们可以在 REPL 进行检查。将此源文件加载到 Idris REPL 中（如上所述），然后运行以下测试。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:284
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"
msgstr ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:292
#, no-wrap
msgid "We can also use `maxBits8` as part of another expression:\n"
msgstr "我们也可以使用 `maxBits8` 作为另一个表达式的一部分：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:293
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"
msgstr ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:300
#, no-wrap
msgid ""
"I called `maxBits8` a *nullary function*, which is just a fancy\n"
"word for *constant*. Let's write and test our first *real* function:\n"
msgstr "我将 `maxBits8` 称为*零元函数*，它只是*常量*的一个花哨的同义词。让我们编写并测试我们的第一个*真实*的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:301
#, no-wrap
msgid ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"
msgstr ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:313
#, no-wrap
msgid ""
"This introduces some new syntax and a new kind of type: Function\n"
"types. `distanceToMax : Bits8 -> Bits8` can be read as follows:\n"
"\"`distanceToMax` is a function of one argument of type `Bits8`, which\n"
"returns a result of type `Bits8`\". In the implementation, the argument\n"
"is given a local identifier `n`, which is then used in the\n"
"calculation on the right hand side. Again, go ahead and try this\n"
"function at the REPL:\n"
msgstr "这引入了一些新语法和一种新类型：函数类型。 `distanceToMax : Bits8 -> Bits8` 可以这样读：“`distanceToMax` 是具有一个 `Bits8` 类型参数的函数，它返回 `Bits8` 类型的结果”。在实现中，参数给定一个本地标识符 `n`，然后在右侧计算。再次在 REPL 中尝试函数：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:314
#, no-wrap
msgid ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"
msgstr ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:325
#, no-wrap
msgid ""
"As a final example, let's implement a function to calculate\n"
"the square of an integer:\n"
msgstr "作为最后一个例子，让我们实现一个计算整数平方的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:326
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:339
#, no-wrap
msgid ""
"We now learn a very important aspect of programming\n"
"in Idris: Idris is\n"
"a *statically typed* programming language. We are not\n"
"allowed to freely mix types as we please. Doing so\n"
"will result in an error message from the type checker\n"
"(which is part of the compilation process of Idris).\n"
"For instance, if we try the following at the REPL,\n"
"we will get a type error:\n"
msgstr "我们现在学习 Idris 编程的一个非常重要的方面：Idris 是一种*静态类型*的编程语言。我们不允许随意混合类型。这样做会导致来自类型检查器的错误消息（这是 Idris 编译过程的一部分）。例如，如果我们在 REPL 中尝试以下操作，我们将收到类型错误：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:340
#, no-wrap
msgid ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"
msgstr ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:350
#, no-wrap
msgid ""
"The reason: `square` expects an argument of type `Integer`,\n"
"but `maxBits8` is of type `Bits8`. Many primitive types\n"
"are interconvertible (sometimes with the risk of loss\n"
"of precision) using function `cast` (more on the details\n"
"later):\n"
msgstr "原因：`square` 需要 `Integer` 类型的参数，但 `maxBits8` 的类型是 `Bits8`。许多原语类型可以使用函数 `cast` 相互转换（有时会有精度损失的风险）（稍后会详细介绍）：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:351
#, no-wrap
msgid ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"
msgstr ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:362
#, no-wrap
msgid ""
"Note, that in the example above the result is much larger\n"
"that `maxBits8`. The reason is, that `maxBits8` is first\n"
"converted to an `Integer` of the same value, which is\n"
"then squared. If on the other hand we squared `maxBits8`\n"
"directly, the result would be truncated to still fit the\n"
"valid range of `Bits8`:\n"
msgstr "请注意，在上面的示例中，结果比 `maxBits8` 大得多。原因是，首先将 `maxBits8` 转换为相同值的 `Integer`，然后对其进行平方。另一方面，如果我们直接将 `maxBits8` 平方，结果将被截断以适应 `Bits8` 的有效范围：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:363
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"
msgstr ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:368
#, no-wrap
msgid "Where to get Help"
msgstr "在哪里可以获得帮助"

#. type: Plain text
#: ../src/Tutorial/Intro.md:373
#, no-wrap
msgid ""
"There are several resources available online and in print, where\n"
"you can find help and documentation about the Idris programming\n"
"language. Here is a non-comprehensive list of them:\n"
msgstr "有多种在线资源和印刷资源，您可以在其中找到有关 Idris 编程语言的帮助和文档。以下是它们的非全面列表：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:375
#, no-wrap
msgid "[Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)\n"
msgstr "[使用 Idris 进行类型驱动开发](https://www.manning.com/books/type-driven-development-with-idris)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:382
#, no-wrap
msgid ""
"  *The* Idris book! This describes in great detail\n"
"  the core concepts for using Idris and dependent types\n"
"  to write robust and concise code. It uses Idris 1 in\n"
"  its examples, so parts of it have to be slightly adjusted\n"
"  when using Idris 2. There is also a\n"
"  [list of required updates](https://idris2.readthedocs.io/en/latest/typedd/typedd.html).\n"
msgstr "  *专门*讲 Idris 的书！这描述得很详细。使用 Idris 和依赖类型的核心概念编写健壮和简洁的代码。它使用 Idris 1 实现书中的例子，所以使用 Idris 2 时它的一部分必须稍微调整，有一个[所需更新列表](https://idris2.readthedocs.io/en/latest/typedd/typedd.html)。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:384
#, no-wrap
msgid "[A Crash Course in Idris 2](https://idris2.readthedocs.io/en/latest/tutorial/index.html)\n"
msgstr "[Idris 2 速成课程](https://idris2.readthedocs.io/en/latest/tutorial/index.html)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:389
#, no-wrap
msgid ""
"  The official Idris 2 tutorial. A comprehensive but dense explanation of\n"
"  all features of Idris 2. I find this to be useful as a reference, and as such\n"
"  it is highly accessible. However, it is not an introduction to functional\n"
"  programming or type-driven development in general.\n"
msgstr "  Idris 2 官方教程。全面而密集的解释 Idris 2 的所有功能。我发现这作为参考很有用，因此它是高度可访问的。但是，它不是函数式编程或类型驱动开发的入门介绍\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:391
#, no-wrap
msgid "[The Idris 2 GitHub Repository](https://github.com/idris-lang/Idris2)\n"
msgstr "[Idris 2 GitHub 存储库](https://github.com/idris-lang/Idris2)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:398
#, no-wrap
msgid ""
"  Look here for detailed installation instructions and some\n"
"  introductory material. There is also a [wiki](https://github.com/idris-lang/Idris2/wiki),\n"
"  where you can find a [list of editor plugins](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience),\n"
"  a [list of community libraries](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  a [list of external backends](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"  and other useful information.\n"
msgstr ""
"  在这里查看详细的安装说明和一些介绍材料。还有一个[wiki](https://github.com/idris-lang/Idris2/wiki)，\n"
"  在这里你可以找到[编辑器插件列表](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience)，\n"
"  [社区库列表](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  [外部后端列表](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"和其他有用的信息。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:400
#, no-wrap
msgid "[The Idris 2 Discord Channel](https://discord.gg/UX68fDs2jc)\n"
msgstr "[Idris 2 Discord 频道](https://discord.gg/UX68fDs2jc)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:406
#, no-wrap
msgid ""
"  If you get stuck with a piece of code, want to ask about some\n"
"  obscure language feature, want to promote your new library,\n"
"  or want to just hang out with other Idris programmers, this\n"
"  is the place to go. The discord channel is pretty active and\n"
"  *very* friendly towards newcomers.\n"
msgstr "  如果你被一段代码卡住了，想问一些晦涩的语言功能，想推广你的新库，或者想和其他 Idris 程序员一起出去玩，可以来这个地方。Discord 频道非常活跃且对新人*非常*友好。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:408
#, no-wrap
msgid "The Idris REPL\n"
msgstr "Idris REPL\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:414
#, no-wrap
msgid ""
"  Finally, a lot of useful information can be provided by\n"
"  Idris itself. I tend to have at least one REPL session open all the\n"
"  time when programming in Idris. My editor (neovim) is set up\n"
"  to use the [language server for Idris 2](https://github.com/idris-community/idris2-lsp),\n"
"  which is incredibly useful. In the REPL,\n"
msgstr "  最后，Idris 本身可以提供很多有用的信息。在 Idris 编程的时间我倾向于至少打开一个 REPL 会话。我的编辑器（neovim）已设置使用 [Idris 2 的语言服务器](https://github.com/idris-community/idris2-lsp)，在 REPL 中这非常有用。\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
#, no-wrap
msgid ""
"use `:t` to inspect the type of an expression\n"
"or meta variable (hole): `:t foldl`,\n"
msgstr "使用 `:t` 检查表达式或元变量（孔）的类型：`:t foldl`,\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
#, no-wrap
msgid ""
"use `:ti` to inspect the type of a function\n"
"including implicit arguments: `:ti foldl`,\n"
msgstr "使用 `:ti` 检查包含隐式参数的函数类型：`:ti foldl`,\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
#, no-wrap
msgid "use `:m` to list all meta variables (holes) in scope,\n"
msgstr "使用 `:m` 列出作用域内的所有元变量（孔），\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
#, no-wrap
msgid ""
"use `:doc` to access the documentation of a\n"
"top level function (`:doc the`), a data type plus all its constructors\n"
"and available hints (`:doc Bool`), a language feature (`:doc case`,\n"
"`:doc let`, `:doc interface`, `:doc record`,\n"
"or even `:doc ?`), or an interface (`:doc Uninhabited`),\n"
msgstr "使用 `:doc` 访问顶级函数 (`:doc the`) 的文档，一种数据类型及其所有构造函数和可用提示 (`:doc Bool` )，语言特性（`:doc case`, `:doc let`, `:doc interface`, `:doc record`，甚至是 `:doc ?`)，或者一个接口（`:doc Uninhabited`），\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
#, no-wrap
msgid ""
"use `:module` to import a module from one of the available\n"
"packages: `:module Data.Vect`,\n"
msgstr "使用 `:module` 从可用包之一导入模块：`:module Data.Vect`,\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
#, no-wrap
msgid ""
"use `:browse` to list the names and types of all functions\n"
"exported by a loaded module: `:browse Data.Vect`,\n"
msgstr "使用 `:browse` 列出加载模块导出的所有函数的名称和类型： `:browse Data.Vect`,\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
#, no-wrap
msgid ""
"use `:help` to get a list of other commands plus a short\n"
"description for each.\n"
msgstr "使用 `:help` 获取其他命令的列表以及每个命令的简短描述。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:432
#, no-wrap
msgid "Summary"
msgstr "概括"

#. type: Plain text
#: ../src/Tutorial/Intro.md:439
#, no-wrap
msgid ""
"In this introduction we learned about the most basic\n"
"features of the Idris programming language. We used\n"
"the REPL to tinker with our ideas and inspect the\n"
"types of things in our code, and we used the Idris\n"
"compiler to compile an Idris source file to an executable.\n"
msgstr "在本介绍中，我们了解了 Idris 编程语言的最基本功能。我们使用 REPL 来修改我们的想法并检查代码中事物的类型，我们使用 Idris 编译器将 Idris 源文件编译为可执行文件。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:443
#, no-wrap
msgid ""
"We also learned about the basic shape of a top level\n"
"definition in Idris, which always consists of an identifier\n"
"(its name), a type, and an implementation.\n"
msgstr "我们还了解了 Idris 中顶级定义的基本形式，它始终由标识符（其名称）、类型和实现组成。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:451
#, no-wrap
msgid ""
"In the [next chapter](Functions1.md), we start programming\n"
"in Idris for real. We learn how to write our own pure\n"
"functions, how functions compose, and how we can treat\n"
"functions just like other values and pass them around\n"
"as arguments to other functions.\n"
msgstr "在[下一章](Functions1.md)中，我们开始在 Idris 中进行真正的编程。我们学习如何编写我们自己的纯函数，函数如何组合，以及我们如何像对待其他值一样对待函数并将它们作为参数传递给其他函数。\n"
