# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Stefan HÃ¶ck
# This file is distributed under the same license as the Functional Programming in Idris 2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Idris 2 1.0\n"
"POT-Creation-Date: 2025-05-15 20:00+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functions2.md:1
#, no-wrap
msgid "Functions Part 2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
msgid ""
"So far, we learned about the core features of the Idris language, which it "
"has in common with several other pure, strongly typed programming languages "
"like Haskell: (Higher-order) Functions, algebraic data types, pattern "
"matching, parametric polymorphism (generic types and functions), and ad hoc "
"polymorphism (interfaces and constrained functions)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
msgid ""
"In this chapter, we start to dissect Idris functions and their types for "
"real. We learn about implicit arguments, named arguments, as well as erasure "
"and quantities. But first, we'll look at `let` bindings and `where` blocks, "
"which help us implement functions too complex to fit on a single line of "
"code. Let's get started!"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:16
#, no-wrap
msgid ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:22
#, no-wrap
msgid "Let Bindings and Local Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
msgid ""
"The functions we looked at so far were simple enough to be implemented "
"directly via pattern matching without the need of additional auxiliary "
"functions or variables. This is not always the case, and there are two "
"important language constructs for introducing and reusing new local "
"variables and functions. We'll look at these in two case studies."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:32
#, no-wrap
msgid "Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
msgid ""
"In this example, we'd like to calculate the arithmetic mean and the standard "
"deviation of a list of floating point values.  There are several things we "
"need to consider."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
msgid ""
"First, we need a function for calculating the sum of a list of numeric "
"values. The *Prelude* exports function `sum` for this:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:42
#, no-wrap
msgid ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
msgid ""
"This is - of course - similar to `sumList` from Exercise 10 of the [last "
"section](Interfaces.md), but generalized to all container types with a "
"`Foldable` implementation. We will learn about interface `Foldable` in a "
"later section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
msgid ""
"In order to also calculate the variance, we need to convert every value in "
"the list to a new value, as we have to subtract the mean from every value in "
"the list and square the result. In the previous section's exercises, we "
"defined function `mapList` for this. The *Prelude* - of course - already "
"exports a similar function called `map`, which is again more general and "
"works also like our `mapMaybe` for `Maybe` and `mapEither` for `Either e`. "
"Here's its type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:63
#, no-wrap
msgid ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
msgid "Interface `Functor` is another one we'll talk about in a later section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
msgid ""
"Finally, we need a way to calculate the length of a list of values. We use "
"function `length` for this:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:74
#, no-wrap
msgid ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
#, no-wrap
msgid ""
"Here, `Nat` is the type of natural numbers\n"
"(unbounded, unsigned integers). `Nat` is actually not a primitive data\n"
"type but a sum type defined in the *Prelude* with\n"
"data constructors `Z : Nat` (for zero)\n"
"and `S : Nat -> Nat` (for successor). It might seem highly inefficient\n"
"to define natural numbers this way, but the Idris compiler\n"
"treats these and several other *number-like* types specially, and\n"
"replaces them with primitive integers during code generation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
msgid ""
"We are now ready to give the implementation of `mean` a go.  Since this is "
"Idris, and we care about clear semantics, we will quickly define a custom "
"record type instead of just returning a tuple of `Double`s. This makes it "
"clearer, which floating point number corresponds to which statistic entity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:94
#, no-wrap
msgid ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
msgid "As usual, we first try this at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:114
#, no-wrap
msgid ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
msgid ""
"Seems to work, so let's digest this step by step.  We introduce several new "
"local variables (`len`, `mean`, and `variance`), which all will be used more "
"than once in the remainder of the implementation. To do so, we use a `let` "
"binding. This consists of the `let` keyword, followed by one or more "
"variable assignments, followed by the final expression, which has to be "
"prefixed by `in`. Note, that whitespace is significant again: We need to "
"properly align the three variable names. Go ahead, and try out what happens "
"if you remove a space in front of `mean` or `variance`.  Note also, that the "
"alignment of assignment operators `:=` is optional. I do this, since I "
"thinks it helps readability."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
msgid ""
"Let's also quickly look at the different variables and their types. `len` is "
"the length of the list cast to a `Double`, since this is what's needed later "
"on, where we divide other values of type `Double` by the length. Idris is "
"very strict about this: We are not allowed to mix up numeric types without "
"explicit casts. Please note, that in this case Idris is able to *infer* the "
"type of `len` from the surrounding context. `mean` is straight forward: We "
"`sum` up the values stored in the list and divide by the list's length. "
"`variance` is the most involved of the three: We map each item in the list "
"to a new value using an anonymous function to subtract the mean and square "
"the result. We then sum up the new terms and divide again by the number of "
"values."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:150
#, no-wrap
msgid "Use Case 2: Simulating a Simple Web Server"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
msgid ""
"In the second use case, we are going to write a slightly larger application. "
"This should give you an idea about how to design data types and functions "
"around some business logic you'd like to implement."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
msgid ""
"Assume we run a music streaming web server, where users can buy whole albums "
"and listen to them online. We'd like to simulate a user connecting to the "
"server and getting access to one of the albums they bought."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
msgid "We first define a bunch of record types:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:164
#, no-wrap
msgid ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
msgid ""
"Most of these should be self-explanatory. Note, however, that in several "
"cases (`Email`, `Artist`, `Password`) we wrap a single value in a new record "
"type. Of course, we *could* have used the unwrapped `String` type instead, "
"but we'd have ended up with many `String` fields, which can be hard to "
"disambiguate.  In order not to confuse an email string with a password "
"string, it can therefore be helpful to wrap both of them in a new record "
"type to drastically increase type safety at the cost of having to "
"reimplement some interfaces.  Utility function `on` from the *Prelude* is "
"very useful for this. Don't forget to inspect its type at the REPL, and try "
"to understand what's going on here."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:203
#, no-wrap
msgid ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
msgid ""
"In case of `Album`, we wrap the two fields of the record in a `Pair`, which "
"already comes with an implementation of `Eq`.  This allows us to again use "
"function `on`, which is very convenient."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
msgid ""
"Next, we have to define the data types representing server requests and "
"responses:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:220
#, no-wrap
msgid ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
msgid ""
"For server responses, we use a custom sum type encoding the possible "
"outcomes of a client request. In practice, the `Success` case would return "
"some kind of connection to start the actual album stream, but we just wrap "
"up the album we found to simulate this behavior."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
msgid ""
"We can now go ahead and simulate the handling of a request at the server. To "
"emulate our user data base, a simple list of users will do. Here's the type "
"of the function we'd like to implement:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:249
#, no-wrap
msgid ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.  This is "
"often useful to make lengthy type signatures more readable and communicate "
"the meaning of a type in the given context. However, this will *not* "
"introduce a new type, nor will it increase type safety: `DB` is *identical* "
"to `List User`, and as such, a value of type `DB` can be used wherever a "
"`List User` is expected and vice versa. In more complex programs it is "
"therefore usually preferable to define new types by wrapping values in "
"single-field records."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
msgid ""
"The implementation will proceed as follows: It will first try and lookup a "
"`User` by is email address in the data base. If this is successful, it will "
"compare the provided password with the user's actual password. If the two "
"match, it will lookup the requested album in the user's list of albums.  If "
"all of these steps succeed, the result will be an `Album` wrapped in a "
"`Success`. If any of the steps fails, the result will describe exactly what "
"went wrong."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
msgid "Here's a possible implementation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:277
#, no-wrap
msgid ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
msgid ""
"I'd like to point out several things in this example. First, note how we can "
"extract values from nested records in a single pattern match.  Second, we "
"defined two *local* functions in a `where` block: `lookupUser`, and "
"`lookupAlbum`. Both of these have access to all variables in the surrounding "
"scope. For instance, `lookupUser` uses the `email` variable from the pattern "
"match in the implementation's first line. Likewise, `lookupAlbum` makes use "
"of the `album` variable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
msgid ""
"A `where` block introduces new local definitions, accessible only from the "
"surrounding scope and from other functions defined later in the same `where` "
"block. These need to be explicitly typed and indented by the same amount of "
"whitespace."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
msgid ""
"Local definitions can also be introduced *before* a function's "
"implementation by using the `let` keyword. This usage of `let` is not to be "
"confused with *let bindings* described above, which are used to bind and "
"reuse the results of intermediate computations. Below is how we could have "
"implemented `handleRequest` with local definitions introduced by the `let` "
"keyword. Again, all definitions have to be properly typed and indented:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:319
#, no-wrap
msgid ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
msgid ""
"The exercises in this section are supposed to increase you experience in "
"writing purely functional code. In some cases it might be useful to use "
"`let` expressions or `where` blocks, but this will not always be required."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
msgid ""
"Exercise 3 is again of utmost importance. `traverseList` is a specialized "
"version of the more general `traverse`, one of the most powerful and "
"versatile functions available in the *Prelude* (check out its type!)."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.  Inspect "
"their types and use these in the implementation of `handleRequest`. This "
"should allow you to completely get rid of the `where` block."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
msgid ""
"Define an enumeration type listing the four [nucleobases](https://en."
"wikipedia.org/wiki/Nucleobase)  occurring in DNA strands. Define also a type "
"alias `DNA` for lists of nucleobases.  Declare and implement function "
"`readBase` for converting a single character (type `Char`) to a nucleobase.  "
"You can use character literals in your implementation like so: `'A'`, `'a'`. "
"Note, that this function might fail, so adjust the result type accordingly."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
msgid ""
"Implement the following function, which tries to convert all values in a "
"list with a function, which might fail. The result should be a `Just` "
"holding the list of converted values in unmodified order, if and only if "
"every single conversion was successful."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:372
#, no-wrap
msgid "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
msgid ""
"Implement function `readDNA : String -> Maybe DNA` using the functions and "
"types defined in exercises 2 and 3.  You will also need function `unpack` "
"from the *Prelude*."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
msgid ""
"Implement function `complement : DNA -> DNA` to calculate the complement of "
"a strand of DNA."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:386
#, no-wrap
msgid "The Truth about Function Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
msgid ""
"So far, when we defined a top level function, it looked something like the "
"following:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:391
#, no-wrap
msgid ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the "
"values stored in two `Either`s via a binary function. If either of the "
"`Either` arguments is a `Left`, the result is also a `Left`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and `e`.  "
"However, there is a more verbose type for `zipEitherWith`, which is visible "
"in the REPL when entering `:ti zipEitherWith` (the `i` here tells Idris to "
"include `implicit` arguments). You will get a type similar to this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:408
#, no-wrap
msgid ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
msgid ""
"In order to understand what's going on here, we will have to talk about "
"named arguments, implicit arguments, and quantities."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:422
#, no-wrap
msgid "Named Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
msgid "In a function type, we can give each argument a name. Like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:426
#, no-wrap
msgid ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These names "
"can be reused in a function's implementation, as was done for `deflt`, but "
"this is not mandatory: We are free to use different names in the "
"implementation. There are several reasons, why we'd choose to name our "
"arguments: It can serve as documentation, but it also allows us to pass the "
"arguments to a function in arbitrary order when using the following syntax:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:440
#, no-wrap
msgid ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
msgid "Or even :"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:447
#, no-wrap
msgid ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
msgid ""
"The arguments in a record's constructor are automatically named in "
"accordance with the field names:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:455
#, no-wrap
msgid ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
msgid ""
"For the use cases described above, named arguments are merely a convenience "
"and completely optional. However, Idris is a *dependently typed* programming "
"language: Types can be calculated from and depend on values. For instance, "
"the *result type* of a function can *depend* on the *value* of one of its "
"arguments. Here's a contrived example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:472
#, no-wrap
msgid ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
msgid ""
"If you see such a thing for the first time, it can be hard to understand "
"what's going on here. First, function `IntOrString` computes a `Type` from a "
"`Bool` value: If the argument is `True`, it returns type `Integer`, if the "
"argument is `False` it returns `String`. We use this to calculate the return "
"type of function `intOrString` based on its boolean argument `v`: If `v` is "
"`True`, the return type is (in accordance with `IntOrString True = Integer`) "
"`Integer`, otherwise it is `String`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the "
"argument of type `Bool` a name (`v`) in order to reference it in the result "
"type `IntOrString v`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
msgid ""
"You might wonder at this moment, why this is useful and why we would ever "
"want to define a function with such a strange type. We will see lots of very "
"useful examples in due time! For now, suffice to say that in order to "
"express dependent function types, we need to name at least some of the "
"function's arguments and refer to them by name in the types of other "
"arguments."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:501
#, no-wrap
msgid "Implicit Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
msgid ""
"Implicit arguments are arguments, the values of which the compiler should "
"infer and fill in for us automatically. For instance, in the following "
"function signature, we expect the compiler to infer the value of type "
"parameter `a` automatically from the types of the other arguments (ignore "
"the 0 quantity for the moment; I'll explain it in the next subsection):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:510
#, no-wrap
msgid ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
msgid ""
"As you can see, implicit arguments are wrapped in curly braces, unlike "
"explicit named arguments, which are wrapped in parentheses.  Inferring the "
"value of an implicit argument is not always possible.  For instance, if we "
"enter the following at the REPL, Idris will fail with an error:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:528
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)` "
"without knowing what `a` actually is.  Note the question mark in front of "
"the type parameter: `?a`.  If this happens, there are several ways to help "
"the type checker.  We could, for instance, pass a value for the implicit "
"argument explicitly. Here's the syntax to do this:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:541
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
msgid ""
"As you can see, we use the same syntax as shown above for explicit named "
"arguments and the two forms of argument passing can be mixed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
msgid ""
"We could also specify the type of the whole expression using utility "
"function `the` from the *Prelude*:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:553
#, no-wrap
msgid ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
msgid "It is instructive to have a look at the type of `the`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:560
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
msgid "Compare this with the identity function `id`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:567
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
msgid ""
"The only difference between the two: In case of `the`, the type parameter "
"`a` is an *explicit* argument, while in case of `id`, it is an *implicit* "
"argument. Although the two functions have almost identical types (and "
"implementations!), they serve quite different purposes: `the` is used to "
"help type inference, while `id` is used whenever we'd like to return an "
"argument without modifying it at all (which, in the presence of higher-order "
"functions, happens surprisingly often)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
msgid ""
"Both ways to improve type inference shown above are used quite often, and "
"must be understood by Idris programmers."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:586
#, no-wrap
msgid "Multiplicities"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared in "
"several of the type signatures in this section. Idris 2, unlike its "
"predecessor Idris 1, is based on a core language called *quantitative type "
"theory* (QTT): Every variable in Idris 2 is associated with one of three "
"possible multiplicities:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`0`, meaning that the variable is *erased* at runtime."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`1`, meaning that the variable is used *exactly once* at runtime."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, "
"here.  We are, however, often interested in multiplicity `0`: A variable "
"with multiplicity `0` is only relevant at *compile time*. It will not make "
"any appearance at runtime, and the computation of such a variable will never "
"affect a program's runtime performance."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
msgid ""
"In the type signature of `maybeToEither` we see that type parameter `a` has "
"multiplicity `0`, and will therefore be erased and is only relevant at "
"compile time, while the `Maybe a` argument has *unrestricted* multiplicity."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
msgid ""
"It is also possible to annotate explicit arguments with multiplicities, in "
"which case the argument must again be put in parentheses. For an example, "
"look again at the type signature of `the`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:614
#, no-wrap
msgid "Underscores"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
msgid ""
"It is often desirable, to only write as little code as necessary and let "
"Idris figure out the rest.  We have already learned about one such occasion: "
"Catch-all patterns.  If a variable in a pattern match is not used on the "
"right hand side, we can't just drop it, as this would make it impossible for "
"Idris to know, which of several arguments we were planning to drop, but we "
"can use an underscore as a placeholder instead:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:624
#, no-wrap
msgid ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
msgid ""
"But when we look at the type signature of `isRight`, we will note that type "
"parameters `a` and `b` are also only used once, and are therefore of no "
"importance. Let's get rid of them:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:634
#, no-wrap
msgid ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
#, no-wrap
msgid ""
"In the detailed type signature of `zipEitherWith`, it should\n"
"be obvious for Idris that the implicit arguments are of type `Type`.\n"
"After all, all of them are later on applied to the `Either` type\n"
"constructor, which is of type `Type -> Type -> Type`. Let's get rid\n"
"of them:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:646
#, no-wrap
msgid ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
msgid "Consider the following contrived example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:659
#, no-wrap
msgid ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious that the second "
"argument in `Either String Integer` is `Integer`. Only the `String` argument "
"can't be inferred by Idris. Even better, the `Either` itself is obvious! "
"Let's get rid of the unnecessary noise:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:670
#, no-wrap
msgid ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
msgid ""
"Please note, that using underscores as in `foo'` is not always desirable, as "
"it can quite drastically obfuscate the written code. Always use a syntactic "
"convenience to make code more readable, and not to show people how clever "
"you are."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:681
#, no-wrap
msgid "Programming with Holes"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
msgid ""
"Solved all the exercises so far? Got angry at the type checker for always "
"complaining and never being really helpful? It's time to change that. Idris "
"comes with several highly useful interactive editing features. Sometimes, "
"the compiler is able to implement complete functions for us (if the types "
"are specific enough). Even if that's not possible, there's an incredibly "
"useful and important feature, which can help us when the types are getting "
"too complicated: Holes.  Holes are variables, the names of which are "
"prefixed with a question mark.  We can use them as placeholders whenever we "
"plan to implement a piece of functionality at a later time. In addition, "
"their types and the types and quantities of all other variables in scope can "
"be inspected at the REPL (or in your editor, if you setup the necessary "
"plugin).  Let's see them holes in action."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
msgid ""
"Remember the `traverseList` example from an Exercise earlier in this "
"section? If this was your first encounter with applicative list traversals, "
"this might have been a nasty bit of work. Well, let's just make it a wee bit "
"harder still. We'd like to implement the same piece of functionality for "
"functions returning `Either e`, where `e` is a type with a `Semigroup` "
"implementation, and we'd like to accumulate the values in all `Left`s we "
"meet along the way."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
msgid "Here's the type of the function:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:707
#, no-wrap
msgid ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
msgid ""
"Now, in order to follow along, you might want to start your own Idris source "
"file, load it into a REPL session and adjust the code as described here. The "
"first thing we'll do, is write a skeleton implementation with a hole on the "
"right hand side:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:719
#, no-wrap
msgid "traverseEither fun as = ?impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
msgid ""
"When you now go to the REPL and reload the file using command `:r`, you can "
"enter `:m` to list all the *metavariables*:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:726
#, no-wrap
msgid ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
msgid ""
"Next, we'd like to display the hole's type (including all variables in the "
"surrounding context plus their types):"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:735
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value of type "
"`List a` called `as`, and a function from `a` to `Either e b` called `fun`. "
"Our goal is to come up with a value of type `Either a (List b)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
msgid ""
"We *could* just return a `Right []`, but that only make sense if our input "
"list is indeed the empty list. We therefore should start with a pattern "
"match on the list:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:755
#, no-wrap
msgid ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
msgid ""
"The result is two holes, which must be given distinct names. When inspecting "
"`impl_0`, we get the following result:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:763
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a "
"value of type `Either e (List b)` with nothing to work with. We know nothing "
"about `a`, so we can't provide an argument with which to invoke `fun`.  "
"Likewise, we know nothing about `e` or `b` either, so we can't produce any "
"values of these either. The *only* option we have is to replace `impl_0` "
"with an empty list wrapped in a `Right`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:780
#, no-wrap
msgid "traverseEither fun []        = Right []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
msgid ""
"The non-empty case is of course slightly more involved. Here's the context "
"of `?impl_1`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:787
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
msgid ""
"Since `x` is of type `a`, we can either use it as an argument to `fun` or "
"drop and ignore it. `xs`, on the other hand, is the remainder of the list of "
"type `List a`. We could again drop it or process it further by invoking "
"`traverseEither` recursively. Since the goal is to try and convert *all* "
"values, we should drop neither. Since in case of two `Left`s we are supposed "
"to accumulate the values, we eventually need to run both computations anyway "
"(invoking `fun`, and recursively calling `traverseEither`). We therefore can "
"do both at the same time and analyze the results in a single pattern match "
"by wrapping both in a `Pair`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:811
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
msgid "Once again, we inspect the context:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:819
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
msgid ""
"We'll definitely need to pattern match on pair `p` next to figure out, which "
"of the two computations succeeded:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:835
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
msgid ""
"At this point we might have forgotten what we actually wanted to do (at "
"least to me, this happens annoyingly often), so we'll just quickly check "
"what our goal is:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:848
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and we "
"have two values of type `e` in scope. According to the spec we want to "
"accumulate these using `e`s `Semigroup` implementation.  We can proceed for "
"the other cases in a similar manner, remembering that we should return a "
"`Right`, if and only if all conversions where successful:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:869
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
msgid "To reap the fruits of our labour, let's show off with a small example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:880
#, no-wrap
msgid ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
msgid "Let's try this at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:899
#, no-wrap
msgid ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:906
#, no-wrap
msgid "Interactive Editing"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
msgid ""
"There are plugins available for several editors and programming "
"environments, which facilitate interacting with the Idris compiler when "
"implementing your functions.  One editor, which is well supported in the "
"Idris community, is Neovim. Since I am a Neovim user myself, I added some "
"examples of what's possible to the [appendix](../Appendices/Neovim.md). Now "
"would be a good time to start using the utilities discussed there."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
msgid ""
"If you use a different editor, probably with less support for the Idris "
"programming language, you should at the very least have a REPL session open "
"all the time, where the source file you are currently working on is loaded. "
"This allows you to introduce new metavariables and inspect their types and "
"context as you develop your code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that "
"you should get yourselves accustomed to programming with holes and let the "
"type checker help you figure out what to do next."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
msgid "Use *let expressions* to define and reuse local variables."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
msgid ""
"In the [next chapter](Dependent.md)  we'll start using dependent types to "
"help us write provably correct code.  Having a good understanding of how to "
"read Idris' type signatures will be of paramount importance there. Whenever "
"you feel lost, add one or more holes and inspect their context to decide "
"what to do next."
msgstr ""
