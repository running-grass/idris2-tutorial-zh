# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functions2.md:1
#, no-wrap
msgid "Functions Part 2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
#, no-wrap
msgid ""
"So far, we learned about the core features of the Idris\n"
"language, which it has in common with several other\n"
"pure, strongly typed programming languages like Haskell:\n"
"(Higher-order) Functions, algebraic data types, pattern matching,\n"
"parametric polymorphism (generic types and functions), and\n"
"ad hoc polymorphism (interfaces and constrained functions).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
#, no-wrap
msgid ""
"In this chapter, we start to dissect Idris functions and their types\n"
"for real. We learn about implicit arguments, named arguments, as well\n"
"as erasure and quantities. But first, we'll look at `let` bindings\n"
"and `where` blocks, which help us implement functions too complex\n"
"to fit on a single line of code. Let's get started!\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:16
#, no-wrap
msgid ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:22
#, no-wrap
msgid "Let Bindings and Local Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
#, no-wrap
msgid ""
"The functions we looked at so far were simple enough\n"
"to be implemented directly via pattern matching\n"
"without the need of additional auxiliary functions or\n"
"variables. This is not always the case, and there are two\n"
"important language constructs for introducing and reusing\n"
"new local variables and functions. We'll look at these\n"
"in two case studies.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:32
#, no-wrap
msgid "Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
#, no-wrap
msgid ""
"In this example, we'd like to calculate the arithmetic\n"
"mean and the standard deviation of a list of floating point values.\n"
"There are several things we need to consider.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
#, no-wrap
msgid ""
"First, we need a function for calculating the sum of\n"
"a list of numeric values. The *Prelude* exports function\n"
"`sum` for this:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:42
#, no-wrap
msgid ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
#, no-wrap
msgid ""
"This is - of course - similar to `sumList` from Exercise 10\n"
"of the [last section](Interfaces.md), but generalized to all\n"
"container types with a `Foldable` implementation. We will\n"
"learn about interface `Foldable` in a later section.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
#, no-wrap
msgid ""
"In order to also calculate the variance,\n"
"we need to convert every value in the list to\n"
"a new value, as we have to subtract the mean\n"
"from every value in the list and square the\n"
"result. In the previous section's exercises, we\n"
"defined function `mapList` for this. The *Prelude* - of course -\n"
"already exports a similar function called `map`,\n"
"which is again more general\n"
"and works also like our `mapMaybe` for `Maybe`\n"
"and `mapEither` for `Either e`. Here's its type:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:63
#, no-wrap
msgid ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
#, no-wrap
msgid ""
"Interface `Functor` is another one we'll talk about\n"
"in a later section.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
#, no-wrap
msgid ""
"Finally, we need a way to calculate the length of\n"
"a list of values. We use function `length` for this:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:74
#, no-wrap
msgid ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
#, no-wrap
msgid ""
"Here, `Nat` is the type of natural numbers\n"
"(unbounded, unsigned integers). `Nat` is actually not a primitive data\n"
"type but a sum type defined in the *Prelude* with\n"
"data constructors `Z : Nat` (for zero)\n"
"and `S : Nat -> Nat` (for successor). It might seem highly inefficient\n"
"to define natural numbers this way, but the Idris compiler\n"
"treats these and several other *number-like* types specially, and\n"
"replaces them with primitive integers during code generation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
#, no-wrap
msgid ""
"We are now ready to give the implementation of `mean` a go.\n"
"Since this is Idris, and we care about clear semantics, we will\n"
"quickly define a custom record type instead of just returning\n"
"a tuple of `Double`s. This makes it clearer, which floating\n"
"point number corresponds to which statistic entity:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:94
#, no-wrap
msgid ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
#, no-wrap
msgid "As usual, we first try this at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:114
#, no-wrap
msgid ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
#, no-wrap
msgid ""
"Seems to work, so let's digest this step by step.\n"
"We introduce several new local variables\n"
"(`len`, `mean`, and `variance`),\n"
"which all will be used more than once in the remainder\n"
"of the implementation. To do so, we use a `let` binding. This\n"
"consists of the `let` keyword, followed by one or more\n"
"variable assignments, followed by the final expression,\n"
"which has to be prefixed by `in`. Note, that whitespace\n"
"is significant again: We need to properly align the three\n"
"variable names. Go ahead, and try out what happens if\n"
"you remove a space in front of `mean` or `variance`.\n"
"Note also, that the alignment of assignment operators\n"
"`:=` is optional. I do this, since I thinks it helps\n"
"readability.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
#, no-wrap
msgid ""
"Let's also quickly look at the different variables\n"
"and their types. `len` is the length of the list\n"
"cast to a `Double`, since this is what's needed\n"
"later on, where we divide other values of type `Double`\n"
"by the length. Idris is very strict about this: We are\n"
"not allowed to mix up numeric types without explicit\n"
"casts. Please note, that in this case Idris is able\n"
"to *infer* the type of `len` from the surrounding\n"
"context. `mean` is straight forward: We `sum` up the\n"
"values stored in the list and divide by the list's\n"
"length. `variance` is the most involved of the\n"
"three: We map each item in the list to a new value\n"
"using an anonymous function to subtract the mean\n"
"and square the result. We then sum up the new terms\n"
"and divide again by the number of values.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:150
#, no-wrap
msgid "Use Case 2: Simulating a Simple Web Server"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
#, no-wrap
msgid ""
"In the second use case, we are going to write a slightly\n"
"larger application. This should give you an idea about how to\n"
"design data types and functions around some business\n"
"logic you'd like to implement.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
#, no-wrap
msgid ""
"Assume we run a music streaming web server, where users\n"
"can buy whole albums and listen to them online. We'd\n"
"like to simulate a user connecting to the server and\n"
"getting access to one of the albums they bought.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
#, no-wrap
msgid "We first define a bunch of record types:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:164
#, no-wrap
msgid ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
#, no-wrap
msgid ""
"Most of these should be self-explanatory. Note, however, that\n"
"in several cases (`Email`, `Artist`, `Password`) we wrap a\n"
"single value in a new record type. Of course, we *could* have\n"
"used the unwrapped `String` type instead, but we'd have ended\n"
"up with many `String` fields, which can be hard to disambiguate.\n"
"In order not to confuse an email string with a password string,\n"
"it can therefore be helpful to wrap both of them in a new\n"
"record type to drastically increase type safety at the cost\n"
"of having to reimplement some interfaces.\n"
"Utility function `on` from the *Prelude* is very useful for this. Don't\n"
"forget to inspect its type at the REPL, and try to understand what's\n"
"going on here.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:203
#, no-wrap
msgid ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
#, no-wrap
msgid ""
"In case of `Album`, we wrap the two fields of the record in\n"
"a `Pair`, which already comes with an implementation of `Eq`.\n"
"This allows us to again use function `on`, which is very convenient.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
#, no-wrap
msgid ""
"Next, we have to define the data types representing\n"
"server requests and responses:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:220
#, no-wrap
msgid ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
#, no-wrap
msgid ""
"For server responses, we use a custom sum type encoding\n"
"the possible outcomes of a client request. In practice,\n"
"the `Success` case would return some kind of connection\n"
"to start the actual album stream, but we just\n"
"wrap up the album we found to simulate this behavior.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
#, no-wrap
msgid ""
"We can now go ahead and simulate the handling of\n"
"a request at the server. To emulate our user data base,\n"
"a simple list of users will do. Here's the type of the\n"
"function we'd like to implement:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:249
#, no-wrap
msgid ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
#, no-wrap
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.\n"
"This is often useful to make lengthy type signatures more readable\n"
"and communicate the meaning of a type in the given context. However,\n"
"this will *not* introduce a new type, nor will it\n"
"increase type safety: `DB` is *identical* to `List User`, and as\n"
"such, a value of type `DB` can be used wherever a `List User` is\n"
"expected and vice versa. In more complex programs it is therefore\n"
"usually preferable to define new types by wrapping values in\n"
"single-field records.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
#, no-wrap
msgid ""
"The implementation will proceed as follows: It will first\n"
"try and lookup a `User` by is email address in the data\n"
"base. If this is successful, it will compare the provided password\n"
"with the user's actual password. If the two match, it will\n"
"lookup the requested album in the user's list of albums.\n"
"If all of these steps succeed, the result will be an `Album`\n"
"wrapped in a `Success`. If any of the steps fails, the\n"
"result will describe exactly what went wrong.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
#, no-wrap
msgid "Here's a possible implementation:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:277
#, no-wrap
msgid ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
#, no-wrap
msgid ""
"I'd like to point out several things in this example. First,\n"
"note how we can extract values from nested records in a\n"
"single pattern match.\n"
"Second, we defined two *local* functions in a `where` block: `lookupUser`,\n"
"and `lookupAlbum`. Both of these have access to all variables\n"
"in the surrounding scope. For instance, `lookupUser` uses the\n"
"`email` variable from the pattern match in the implementation's\n"
"first line. Likewise, `lookupAlbum` makes use of the `album`\n"
"variable.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
#, no-wrap
msgid ""
"A `where` block introduces new local definitions, accessible\n"
"only from the surrounding scope and from other functions\n"
"defined later in the same `where` block. These need to\n"
"be explicitly typed and indented by the same amount of whitespace.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
#, no-wrap
msgid ""
"Local definitions can also be introduced *before* a function's\n"
"implementation by using the `let` keyword. This usage\n"
"of `let` is not to be confused with *let bindings* described\n"
"above, which are used to bind and reuse the results of intermediate\n"
"computations. Below is how we could have implemented `handleRequest` with\n"
"local definitions introduced by the `let` keyword. Again,\n"
"all definitions have to be properly typed and indented:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:319
#, no-wrap
msgid ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
#, no-wrap
msgid ""
"The exercises in this section are supposed to increase\n"
"you experience in writing purely functional code. In some\n"
"cases it might be useful to use `let` expressions or\n"
"`where` blocks, but this will not always be required.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
#, no-wrap
msgid ""
"Exercise 3 is again of utmost importance. `traverseList`\n"
"is a specialized version of the more general `traverse`,\n"
"one of the most powerful and versatile functions\n"
"available in the *Prelude* (check out its type!).\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
#, no-wrap
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.\n"
"Inspect their types and use these in the implementation of\n"
"`handleRequest`. This should allow you to completely get rid\n"
"of the `where` block.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
#, no-wrap
msgid ""
"Define an enumeration type listing the four\n"
"[nucleobases](https://en.wikipedia.org/wiki/Nucleobase)\n"
"occurring in DNA strands. Define also a type alias\n"
"`DNA` for lists of nucleobases.\n"
"Declare and implement function `readBase`\n"
"for converting a single character (type `Char`) to a nucleobase.\n"
"You can use character literals in your implementation like so:\n"
"`'A'`, `'a'`. Note, that this function might fail, so adjust the\n"
"result type accordingly.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
#, no-wrap
msgid ""
"Implement the following function, which tries to convert all\n"
"values in a list with a function, which might fail. The\n"
"result should be a `Just` holding the list of converted\n"
"values in unmodified order, if and\n"
"only if every single conversion was successful.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:372
#, no-wrap
msgid "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
#, no-wrap
msgid ""
"Implement function `readDNA : String -> Maybe DNA`\n"
"using the functions and types defined in exercises 2 and 3.\n"
"You will also need function `unpack` from the *Prelude*.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
#, no-wrap
msgid ""
"Implement function `complement : DNA -> DNA` to\n"
"calculate the complement of a strand of DNA.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:386
#, no-wrap
msgid "The Truth about Function Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
#, no-wrap
msgid ""
"So far, when we defined a top level function, it looked something\n"
"like the following:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:391
#, no-wrap
msgid ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
#, no-wrap
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the\n"
"values stored in two `Either`s via a binary function. If either\n"
"of the `Either` arguments is a `Left`, the result is also a `Left`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
#, no-wrap
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and `e`.\n"
"However, there is a more verbose type for `zipEitherWith`, which is\n"
"visible in the REPL when entering `:ti zipEitherWith` (the `i` here\n"
"tells Idris to include `implicit` arguments). You will get a type\n"
"similar to this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:408
#, no-wrap
msgid ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
#, no-wrap
msgid ""
"In order to understand what's going on here, we will have to talk about\n"
"named arguments, implicit arguments, and quantities.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:422
#, no-wrap
msgid "Named Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
#, no-wrap
msgid "In a function type, we can give each argument a name. Like so:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:426
#, no-wrap
msgid ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
#, no-wrap
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These\n"
"names can be reused in a function's implementation, as was done for `deflt`,\n"
"but this is not mandatory: We are free to use different names in the\n"
"implementation. There are several reasons, why we'd choose to name our\n"
"arguments: It can serve as documentation, but it also\n"
"allows us to pass the arguments to a function in arbitrary order\n"
"when using the following syntax:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:440
#, no-wrap
msgid ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
#, no-wrap
msgid "Or even :\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:447
#, no-wrap
msgid ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
#, no-wrap
msgid ""
"The arguments in a record's constructor are automatically named\n"
"in accordance with the field names:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:455
#, no-wrap
msgid ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
#, no-wrap
msgid ""
"For the use cases described above, named arguments are merely a\n"
"convenience and completely optional. However, Idris is a *dependently typed*\n"
"programming language: Types can be calculated from and depend on\n"
"values. For instance, the *result type* of a function can *depend* on\n"
"the *value* of one of its arguments. Here's a contrived example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:472
#, no-wrap
msgid ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
#, no-wrap
msgid ""
"If you see such a thing for the first time, it can be hard to understand\n"
"what's going on here. First, function `IntOrString` computes a `Type`\n"
"from a `Bool` value: If the argument is `True`, it returns type `Integer`,\n"
"if the argument is `False` it returns `String`. We use this to\n"
"calculate the return type of function `intOrString` based on its\n"
"boolean argument `v`: If `v` is `True`, the return type is (in accordance\n"
"with `IntOrString True = Integer`) `Integer`, otherwise it is `String`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
#, no-wrap
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the\n"
"argument of type `Bool` a name (`v`) in order to reference it in\n"
"the result type `IntOrString v`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
#, no-wrap
msgid ""
"You might wonder at this moment, why this is useful and why we would\n"
"ever want to define a function with such a strange type. We will see\n"
"lots of very useful examples in due time! For now, suffice to say that\n"
"in order to express dependent function types, we need to name\n"
"at least some of the function's arguments and refer to them by name\n"
"in the types of other arguments.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:501
#, no-wrap
msgid "Implicit Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
#, no-wrap
msgid ""
"Implicit arguments are arguments, the values of which the compiler\n"
"should infer and fill in for us automatically. For instance, in\n"
"the following function signature, we expect the compiler to\n"
"infer the value of type parameter `a` automatically from the\n"
"types of the other arguments (ignore the 0 quantity for the moment;\n"
"I'll explain it in the next subsection):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:510
#, no-wrap
msgid ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
#, no-wrap
msgid ""
"As you can see, implicit arguments are wrapped in curly braces,\n"
"unlike explicit named arguments, which are wrapped in parentheses.\n"
"Inferring the value of an implicit argument is not always possible.\n"
"For instance, if we enter the following\n"
"at the REPL, Idris will fail with an error:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:528
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
#, no-wrap
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)`\n"
"without knowing what `a` actually is.\n"
"Note the question mark in front of the\n"
"type parameter: `?a`.\n"
"If this happens, there are several ways to help the type checker.\n"
"We could, for instance, pass a value for the implicit argument\n"
"explicitly. Here's the syntax to do this:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:541
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
#, no-wrap
msgid ""
"As you can see, we use the same syntax\n"
"as shown above for explicit named arguments and the\n"
"two forms of argument passing can be mixed.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
#, no-wrap
msgid ""
"We could also specify the type of the whole expression using\n"
"utility function `the` from the *Prelude*:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:553
#, no-wrap
msgid ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
#, no-wrap
msgid "It is instructive to have a look at the type of `the`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:560
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
#, no-wrap
msgid "Compare this with the identity function `id`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:567
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
#, no-wrap
msgid ""
"The only difference between the two: In case of `the`,\n"
"the type parameter `a` is an *explicit* argument, while\n"
"in case of `id`, it is an *implicit* argument. Although\n"
"the two functions have almost identical types (and implementations!),\n"
"they serve quite different purposes: `the` is used to help\n"
"type inference, while `id` is used whenever we'd like\n"
"to return an argument without modifying it at all (which,\n"
"in the presence of higher-order functions,\n"
"happens surprisingly often).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
#, no-wrap
msgid ""
"Both ways to improve type inference shown above\n"
"are used quite often, and must be understood by Idris\n"
"programmers.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:586
#, no-wrap
msgid "Multiplicities"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
#, no-wrap
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared\n"
"in several of the type signatures in this section. Idris 2, unlike\n"
"its predecessor Idris 1, is based on a core language called\n"
"*quantitative type theory* (QTT): Every variable in Idris 2 is\n"
"associated with one of three possible multiplicities:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid "`0`, meaning that the variable is *erased* at runtime.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid "`1`, meaning that the variable is used *exactly once* at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
#, no-wrap
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, here.\n"
"We are, however, often interested in multiplicity `0`: A variable with\n"
"multiplicity `0` is only relevant at *compile time*. It will not make\n"
"any appearance at runtime, and the computation of such a variable will\n"
"never affect a program's runtime performance.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
#, no-wrap
msgid ""
"In the type signature of `maybeToEither` we see that type\n"
"parameter `a` has multiplicity `0`, and will therefore be erased and\n"
"is only relevant at compile time, while the `Maybe a` argument\n"
"has *unrestricted* multiplicity.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
#, no-wrap
msgid ""
"It is also possible to annotate explicit arguments with multiplicities,\n"
"in which case the argument must again be put in parentheses. For an example,\n"
"look again at the type signature of `the`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:614
#, no-wrap
msgid "Underscores"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
#, no-wrap
msgid ""
"It is often desirable, to only write as little code as necessary\n"
"and let Idris figure out the rest.\n"
"We have already learned about one such occasion: Catch-all patterns.\n"
"If a variable in a pattern match is not used on the right hand side,\n"
"we can't just drop it, as this would make it impossible for\n"
"Idris to know, which of several arguments we were planning to drop,\n"
"but we can use an underscore as a placeholder instead:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:624
#, no-wrap
msgid ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
#, no-wrap
msgid ""
"But when we look at the type signature of `isRight`, we will note\n"
"that type parameters `a` and `b` are also only used once, and\n"
"are therefore of no importance. Let's get rid of them:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:634
#, no-wrap
msgid ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
#, no-wrap
msgid ""
"In the detailed type signature of `zipEitherWith`, it should\n"
"be obvious for Idris that the implicit arguments are of type `Type`.\n"
"After all, all of them are later on applied to the `Either` type\n"
"constructor, which is of type `Type -> Type -> Type`. Let's get rid\n"
"of them:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:646
#, no-wrap
msgid ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
#, no-wrap
msgid "Consider the following contrived example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:659
#, no-wrap
msgid ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
#, no-wrap
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious\n"
"that the second argument in `Either String Integer` is\n"
"`Integer`. Only the `String` argument can't be inferred\n"
"by Idris. Even better, the `Either` itself is obvious!\n"
"Let's get rid of the unnecessary noise:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:670
#, no-wrap
msgid ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
#, no-wrap
msgid ""
"Please note, that using underscores as in `foo'` is\n"
"not always desirable, as it can quite drastically\n"
"obfuscate the written code. Always use a syntactic\n"
"convenience to make code more readable, and not to\n"
"show people how clever you are.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:681
#, no-wrap
msgid "Programming with Holes"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
#, no-wrap
msgid ""
"Solved all the exercises so far? Got angry at the type checker\n"
"for always complaining and never being really helpful? It's time\n"
"to change that. Idris comes with several highly useful interactive\n"
"editing features. Sometimes, the compiler is able to implement\n"
"complete functions for us (if the types are specific enough). Even\n"
"if that's not possible, there's an incredibly useful and important\n"
"feature, which can help us when the types are getting too complicated: Holes.\n"
"Holes are variables, the names of which are prefixed with a question mark.\n"
"We can use them as placeholders whenever we plan to implement a piece\n"
"of functionality at a later time. In addition, their types and the types\n"
"and quantities of all other variables in scope can be inspected\n"
"at the REPL (or in your editor, if you setup the necessary plugin).\n"
"Let's see them holes in action.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
#, no-wrap
msgid ""
"Remember the `traverseList` example from an Exercise earlier in\n"
"this section? If this was your first encounter with applicative list\n"
"traversals, this might have been a nasty bit of work. Well, let's just\n"
"make it a wee bit harder still. We'd like to implement the same\n"
"piece of functionality for functions returning `Either e`, where\n"
"`e` is a type with a `Semigroup` implementation, and we'd like\n"
"to accumulate the values in all `Left`s we meet along the way.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
#, no-wrap
msgid "Here's the type of the function:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:707
#, no-wrap
msgid ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
#, no-wrap
msgid ""
"Now, in order to follow along, you might want to start your own\n"
"Idris source file, load it into a REPL session and adjust the\n"
"code as described here. The first thing we'll do, is write a\n"
"skeleton implementation with a hole on the right hand side:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:719
#, no-wrap
msgid "traverseEither fun as = ?impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
#, no-wrap
msgid ""
"When you now go to the REPL and reload the file using command `:r`,\n"
"you can enter `:m` to list all the *metavariables*:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:726
#, no-wrap
msgid ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
#, no-wrap
msgid ""
"Next, we'd like to display the hole's type (including all variables in the\n"
"surrounding context plus their types):\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:735
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
#, no-wrap
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value\n"
"of type `List a` called `as`, and a function from `a` to\n"
"`Either e b` called `fun`. Our goal is to come up with a value\n"
"of type `Either a (List b)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
#, no-wrap
msgid ""
"We *could* just return a `Right []`, but that only make sense\n"
"if our input list is indeed the empty list. We therefore should\n"
"start with a pattern match on the list:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:755
#, no-wrap
msgid ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
#, no-wrap
msgid ""
"The result is two holes, which must be given distinct names. When inspecting `impl_0`,\n"
"we get the following result:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:763
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
#, no-wrap
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a value\n"
"of type `Either e (List b)` with nothing to work with. We know nothing\n"
"about `a`, so we can't provide an argument with which to invoke `fun`.\n"
"Likewise, we know nothing about `e` or `b` either, so we can't produce\n"
"any values of these either. The *only* option we have is to replace `impl_0`\n"
"with an empty list wrapped in a `Right`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:780
#, no-wrap
msgid "traverseEither fun []        = Right []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
#, no-wrap
msgid ""
"The non-empty case is of course slightly more involved. Here's the context\n"
"of `?impl_1`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:787
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
#, no-wrap
msgid ""
"Since `x` is of type `a`, we can either use it as an argument\n"
"to `fun` or drop and ignore it. `xs`, on the other hand, is\n"
"the remainder of the list of type `List a`. We could again\n"
"drop it or process it further by invoking `traverseEither`\n"
"recursively. Since the goal is to try and convert *all* values,\n"
"we should drop neither. Since in case of two `Left`s we\n"
"are supposed to accumulate the values, we eventually need to\n"
"run both computations anyway (invoking `fun`, and recursively\n"
"calling `traverseEither`). We therefore can do both at the\n"
"same time and analyze the results in a single pattern match\n"
"by wrapping both in a `Pair`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:811
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
#, no-wrap
msgid "Once again, we inspect the context:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:819
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
#, no-wrap
msgid ""
"We'll definitely need to pattern match on pair `p` next\n"
"to figure out, which of the two computations succeeded:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:835
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
#, no-wrap
msgid ""
"At this point we might have forgotten what we actually\n"
"wanted to do (at least to me, this happens annoyingly often),\n"
"so we'll just quickly check what our goal is:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:848
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
#, no-wrap
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and\n"
"we have two values of type `e` in scope. According to the spec we\n"
"want to accumulate these using `e`s `Semigroup` implementation.\n"
"We can proceed for the other cases in a similar manner, remembering\n"
"that we should return a `Right`, if and only if all conversions\n"
"where successful:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:869
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
#, no-wrap
msgid "To reap the fruits of our labour, let's show off with a small example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:880
#, no-wrap
msgid ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
#, no-wrap
msgid "Let's try this at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:899
#, no-wrap
msgid ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:906
#, no-wrap
msgid "Interactive Editing"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
#, no-wrap
msgid ""
"There are plugins available for several editors and\n"
"programming environments, which facilitate interacting\n"
"with the Idris compiler when implementing your functions.\n"
"One editor, which is well supported in the Idris\n"
"community, is Neovim. Since I am a Neovim user myself,\n"
"I added some examples of what's possible to the\n"
"[appendix](../Appendices/Neovim.md). Now would be a good\n"
"time to start using the utilities discussed there.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
#, no-wrap
msgid ""
"If you use a different editor, probably with less support\n"
"for the Idris programming language, you should at the very\n"
"least have a REPL session open all the time, where the\n"
"source file you are currently working on is loaded. This\n"
"allows you to introduce new metavariables and inspect their\n"
"types and context as you develop your code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
#, no-wrap
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that you\n"
"should get yourselves accustomed to programming with holes and let the\n"
"type checker help you figure out what to do next.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
#, no-wrap
msgid "Use *let expressions* to define and reuse local variables.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
#, no-wrap
msgid ""
"In the [next chapter](Dependent.md)\n"
"we'll start using dependent types to help us write provably correct code.\n"
"Having a good understanding of how to read\n"
"Idris' type signatures will be of paramount importance there. Whenever\n"
"you feel lost, add one or more holes and inspect their context to decide what to\n"
"do next.\n"
msgstr ""
