# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 07:57+0000\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "练习第 1 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "练习第 2 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "练习第 3 部分"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429
#: ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"

#. type: Title #
#: ../src/Tutorial/Functor.md:1
#, no-wrap
msgid "Functor and Friends"
msgstr "函子和它的朋友们"

#. type: Plain text
#: ../src/Tutorial/Functor.md:6
msgid ""
"Programming, like mathematics, is about abstraction. We try to model parts "
"of the real world, reusing recurring patterns by abstracting over them."
msgstr ""
"编程，就像数学一样，是关于抽象的。我们尝试对现实世界的某些部分进行建模，通过"
"对它们进行抽象来重用重复出现的模式。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:17
msgid ""
"In this chapter, we will learn about several related interfaces, which are "
"all about abstraction and therefore can be hard to understand at the "
"beginning. Especially figuring out *why* they are useful and *when* to use "
"them will take time and experience. This chapter therefore comes with tons "
"of exercises, most of which can be solved with only a few short lines of "
"code. Don't skip them.  Come back to them several times until these things "
"start feeling natural to you. You will then realize that their initial "
"complexity has vanished."
msgstr ""
"在本章中，我们将学习几个相关的接口，它们都是关于抽象的，因此一开始可能很难理"
"解。尤其是弄清楚 *为什么* 有用以及 *何时* 使用它们需要时间和经验。因此，本章"
"包含大量练习，其中大部分练习只需几行代码即可解决。不要跳过它们。回到他们身边"
"几次，直到这些事情开始对你来说很自然。然后你会意识到它们最初的复杂性已经消失"
"了。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:18
#, no-wrap
msgid ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:28
#, no-wrap
msgid "Functor"
msgstr "函子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:42
#, no-wrap
msgid ""
"What do type constructors like `List`, `List1`, `Maybe`, or\n"
"`IO` have in common? First, all of them are of type\n"
"`Type -> Type`. Second, they all put values of a given type\n"
"in a certain *context*. With `List`,\n"
"the *context* is *non-determinism*: We know there to\n"
"be zero or more values, but we don't know the exact number\n"
"until we start taking the list apart by pattern matching\n"
"on it. Likewise for `List1`, though we know for sure that\n"
"there is at least one value. For `Maybe`, we are still not\n"
"sure about how many values there are, but the possibilities\n"
"are much smaller: Zero or one. With `IO`, the context is a different one:\n"
"Arbitrary side effects.\n"
msgstr "`List`、`List1`、`Maybe` 或 `IO` 等类型构造函数有什么共同点？首先，它们都是类型 `Type -> Type`。其次，它们都将给定类型的值放在某个 *上下文* 中。对于 `List`，*上下文* 是 *不确定性*：我们知道有零个或多个值，但在开始之前我们不知道确切的数字通过对其进行模式匹配将列表分开。对于 `List1` 也是如此，尽管我们确定至少有一个值。对于 `Maybe`，我们仍然不确定有多少个值，但可能性要小得多：零或一。使用 `IO`，上下文是不同的：任意副作用。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:49
msgid ""
"Although the type constructors discussed above are quite different in how "
"they behave and when they are useful, there are certain operations that keep "
"coming up when working with them. The first such operation is *mapping a "
"pure function over the data type, without affecting its underlying "
"structure*."
msgstr ""
"尽管上面讨论的类型构造函数在它们的行为方式和何时有用方面有很大不同，但在使用"
"它们时会不断出现某些操作。第一个这样的操作是 *在数据类型上映射一个纯函数，而"
"不影响其底层结构*。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:53
msgid ""
"For instance, given a list of numbers, we'd like to multiply each number by "
"two, without changing their order or removing any values:"
msgstr ""
"例如，给定一个数字列表，我们希望将每个数字乘以 2，而不更改它们的顺序或删除任"
"何值："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:54
#, no-wrap
msgid ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
msgstr ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:62
msgid ""
"But we might just as well convert every string in a list of strings to upper "
"case characters:"
msgstr "但是我们也可以将字符串列表中的每个字符串都转换为大写字符："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:63
#, no-wrap
msgid ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
msgstr ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:72
msgid ""
"Sometimes, the type of the stored value changes. In the next example, we "
"calculate the lengths of the strings stored in a list:"
msgstr ""
"有时，存储值的类型会发生变化。在下一个示例中，我们计算存储在列表中的字符串的"
"长度："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:73
#, no-wrap
msgid ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"
msgstr ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:83
msgid ""
"I'd like you to appreciate, just how boring these functions are. They are "
"almost identical, with the only interesting part being the function we apply "
"to each element. Surely, there must be a pattern to abstract over:"
msgstr ""
"我希望你能体会到，这些功能是多么无聊。它们几乎相同，唯一有趣的部分是我们应用"
"于每个元素的函数。当然，必须有一个抽象的模式："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:84
#, no-wrap
msgid ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"
msgstr ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:94
msgid ""
"This is often the first step of abstraction in functional programming: Write "
"a (possibly generic) higher-order function.  We can now concisely implement "
"all examples shown above in terms of `mapList`:"
msgstr ""
"这通常是函数式编程中抽象的第一步：编写一个（可能是通用的）高阶函数。我们现在"
"可以根据 `mapList` 简洁地实现上面显示的所有示例："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:95
#, no-wrap
msgid ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"
msgstr ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:110
msgid ""
"But surely we'd like to do the same kind of thing with `List1` and `Maybe`! "
"After all, they are just container types like `List`, the only difference "
"being some detail about the number of values they can or can't hold:"
msgstr ""
"但我们肯定想对 `List1` 和 `Maybe` 做同样的事情！毕竟，它们只是像 `List` 这样"
"的容器类型，唯一的区别是关于它们可以或不可以保存的值的数量的一些细节："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:111
#, no-wrap
msgid ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"
msgstr ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:125
msgid ""
"Even with `IO`, we'd like to be able to map pure functions over effectful "
"computations. The implementation is a bit more involved, due to the nested "
"layers of data constructors, but if in doubt, the types will surely guide "
"us. Note, however, that `IO` is not publicly exported, so its data "
"constructor is unavailable to us. We can use functions `toPrim` and "
"`fromPrim`, however, for converting `IO` from and to `PrimIO`, which we can "
"freely dissect:"
msgstr ""
"即使使用 `IO`，我们也希望能够将纯函数映射到副作用的计算上。由于数据构造函数的"
"嵌套层，实现有点复杂，但如果有疑问，类型肯定会指导我们。但是请注意，`IO` 不是"
"公开导出的，因此我们无法使用它的数据构造函数。我们可以使用函数 `toPrim` 和 "
"`fromPrim`，但是，将 `IO` 与 `PrimIO` 相互转换，我们可以自由剖析："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:126
#, no-wrap
msgid ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"
msgstr ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:138
msgid ""
"From the concept of *mapping a pure function over values in a context* "
"follow some derived functions, which are often useful. Here are some of them "
"for `IO`:"
msgstr ""
"从 *将纯函数映射到上下文中的值的概念* 遵循一些派生函数，这些函数通常很有用。"
"以下是 `IO` 中的一些："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:139
#, no-wrap
msgid ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"
msgstr ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:151
msgid ""
"Of course, we'd want to implement `mapConst` and `forget` as well for "
"`List`, `List1`, and `Maybe` (and dozens of other type constructors with "
"some kind of mapping function), and they'd all look the same and be equally "
"boring."
msgstr ""
"当然，我们也想为 `List`、`List1` 和 `Maybe` 实现 `mapConst` 和 `forget` ]（以"
"及其他几十个具有某种映射函数的类型构造函数），它们看起来都一样并且同样无聊。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:161
#, no-wrap
msgid ""
"When we come upon a recurring class of functions with\n"
"several useful derived functions, we should consider defining\n"
"an interface. But how should we go about this here?\n"
"When you look at the types of `mapList`, `mapMaybe`, and `mapIO`,\n"
"you'll see that it's the `List`, `List1`, and `IO` types we\n"
"need to get rid of. These are not of type `Type` but of type\n"
"`Type -> Type`. Luckily, there is nothing preventing us\n"
"from parametrizing an interface over something else than\n"
"a `Type`.\n"
msgstr "当我们遇到具有几个有用的派生函数的重复函数类时，我们应该考虑定义一个接口。但是我们应该怎么做呢？当您查看 `mapList`、`mapMaybe` 和 `mapIO` 的类型时，您会发现它是 `List`、`我们需要去掉 List1` 和 `IO` 类型。这些不是 `Type` 类型，而是 `Type -> Type` 类型。幸运的是，除了 `Type` 之外，没有什么能阻止我们对接口进行参数化。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:166
msgid ""
"The interface we are looking for is called `Functor`.  Here is its "
"definition and an example implementation (I appended a tick at the end of "
"the names for them not to overlap with the interface and functions exported "
"by the *Prelude*):"
msgstr ""
"我们要找的接口叫做`Functor`。这是它的定义和一个示例实现（我在名称末尾附加了一"
"个引号，以免它们与 *Prelude* 导出的接口和函数重叠）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:167
#, no-wrap
msgid ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"
msgstr ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:179
msgid ""
"Note, that we had to give the type of parameter `f` explicitly, and in that "
"case it needs to be annotated with quantity zero if you want it to be erased "
"at runtime (which you almost always want)."
msgstr ""
"请注意，我们必须明确给出参数 `f` 的类型，在这种情况下，如果您希望它在运行时被"
"擦除（您几乎总是想要），则需要用定量零进行注释。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:186
msgid ""
"Now, reading type signatures consisting only of type parameters like the one "
"of `map'` can take some time to get used to, especially when some type "
"parameters are applied to other parameters as in `f a`. It can be very "
"helpful to inspect these signatures together with all implicit arguments at "
"the REPL (I formatted the output to make it more readable):"
msgstr ""
"现在，读取仅包含类型参数（如 `map'` 中的某个）的类型签名可能需要一些时间来适"
"应，尤其是当某些类型参数应用于其他参数时，例如 `f a` .检查这些签名以及 REPL "
"中的所有隐式参数会非常有帮助（我对输出进行了格式化以使其更具可读性）："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:187
#, no-wrap
msgid ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"
msgstr ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:200
msgid ""
"It can also be helpful to replace type parameter `f` with a concrete value "
"of the same type:"
msgstr "将类型参数 `f` 替换为相同类型的具体值也很有帮助："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:201
#, no-wrap
msgid ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"
msgstr ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:209
msgid ""
"Remember, being able to interpret type signatures is paramount to "
"understanding what's going on in an Idris declaration. You *must* practice "
"this and make use of the tools and utilities given to you."
msgstr ""
"请记住，能够解释类型签名对于理解 Idris 声明中发生的事情至关重要。您 *必须* 练"
"习这一点，并利用提供给您的工具和实用程序。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:210
#, no-wrap
msgid "Derived Functions"
msgstr "派生函数"

#. type: Plain text
#: ../src/Tutorial/Functor.md:215
msgid ""
"There are several functions and operators directly derivable from interface "
"`Functor`. Eventually, you should know and remember all of them as they are "
"highly useful. Here they are together with their types:"
msgstr ""
"有几个函数和运算符可以直接从接口 `Functor` 派生。最终，您应该知道并记住所有这"
"些，因为它们非常有用。在这里，它们与它们的类型一起："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:216
#, no-wrap
msgid ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"
msgstr ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:235
#, no-wrap
msgid ""
"`(<$>)` is an operator alias for `map` and allows you to sometimes\n"
"drop some parentheses. For instance:\n"
msgstr "`(<$>)` 是 `map` 的运算符别名，有时您可以去掉一些括号。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:236
#, no-wrap
msgid ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"
msgstr ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:249
#, no-wrap
msgid ""
"`(<&>)` is an alias for `(<$>)` with the arguments flipped.\n"
"The other three (`ignore`, `($>)`, and `(<$)`) are all used\n"
"to replace the values in a context with a constant. They are often useful\n"
"when you don't care about the values themselves but\n"
"want to keep the underlying structure.\n"
msgstr "`(<&>)` 是 `(<$>)` 参数被翻转后的别名，。其他三个（`ignore`、`($>)` 和 `(<$)`）都用于将上下文中的值替换为常量。当您不关心值本身但想要保留底层结构时，它们通常很有用。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:250
#, no-wrap
msgid "Functors with more than one Type Parameter"
msgstr "具有多个类型参数的函子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:259
#, no-wrap
msgid ""
"The type constructors we looked at so far were all\n"
"of type `Type -> Type`. However, we can also implement `Functor`\n"
"for other type constructors. The only prerequisite is that\n"
"the type parameter we'd like to change with function `map` must\n"
"be the last in the argument list. For instance, here is the\n"
"`Functor` implementation for `Either e` (note, that `Either e`\n"
"has of course type `Type -> Type` as required):\n"
msgstr "到目前为止，我们看到的类型构造函数都是 `Type -> Type`。但是，我们也可以为其他类型的构造函数实现 `Functor`。唯一的先决条件是我们想用函数 `map` 更改的类型参数必须是参数列表中的最后一个。例如，这里是 `Either e` 的 `Functor` 实现（注意， `Either e` 当然有类型 `Type -> Type` 为必要条件）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:260
#, no-wrap
msgid ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"
msgstr ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:269
#, no-wrap
msgid ""
"Here is another example, this time for a type constructor of\n"
"type `Bool -> Type -> Type` (you might remember this from\n"
"the exercises in the [last chapter](IO.md)):\n"
msgstr "这是另一个例子，这次是一个类型为 `Bool -> Type -> Type` 的类型构造函数（你可能还记得 [上一章](IO.md) 的练习中的这个）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:270
#, no-wrap
msgid ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"
msgstr ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:280
#, no-wrap
msgid "Functor Composition"
msgstr "函子组合"

#. type: Plain text
#: ../src/Tutorial/Functor.md:284
msgid ""
"The nice thing about functors is how they can be paired and nested with "
"other functors and the results are functors again:"
msgstr "函子的好处是它们可以如何与其他函子配对和嵌套，结果又是函子："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:285
#, no-wrap
msgid ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"
msgstr ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:297
msgid ""
"The above allows us to conveniently map over a pair of functors. Note, "
"however, that Idris needs some help with inferring the types involved:"
msgstr ""
"以上允许我们方便地映射一对函子。但是请注意，Idris 需要一些帮助来推断所涉及的"
"类型："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:298
#, no-wrap
msgid ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"
msgstr ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:313
msgid ""
"More often, we'd like to map over several layers of nested functors at once. "
"Here's how to do this with an example:"
msgstr "更多时候，我们想一次映射多层嵌套函子。以下是如何通过示例执行此操作："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:314
#, no-wrap
msgid ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"
msgstr ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"

#. type: Title ####
#: ../src/Tutorial/Functor.md:326
#, no-wrap
msgid "Named Implementations"
msgstr "命名实现"

#. type: Plain text
#: ../src/Tutorial/Functor.md:334
msgid ""
"Sometimes, there are more ways to implement an interface for a given type. "
"For instance, for numeric types we can have a `Monoid` representing addition "
"and one representing multiplication.  Likewise, for nested functors, `map` "
"can be interpreted as a mapping over only the first layer of values, or a "
"mapping over several layers of values."
msgstr ""
"有时，有更多方法可以为给定类型实现接口。例如，对于数字类型，我们可以有一个 "
"`Monoid` 代表加法和一个代表乘法。同样，对于嵌套函子，`map` 可以解释为仅对第一"
"层值的映射，或对若干层值的映射。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:339
msgid ""
"One way to go about this is to define single-field wrappers as shown with "
"data type `Comp` above. However, Idris also allows us to define additional "
"interface implementations, which must then be given a name. For instance:"
msgstr ""
"解决此问题的一种方法是定义单字段包装器，如上面的数据类型 `Comp` 所示。然而，"
"Idris 也允许我们定义额外的接口实现，然后必须给它一个名字。例如："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:340
#, no-wrap
msgid ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"
msgstr ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:350
msgid ""
"Note, that this defines a new implementation of `Functor`, which will *not* "
"be considered during implicit resolution in order to avoid ambiguities. "
"However, it is possible to explicitly choose to use this implementation by "
"passing it as an explicit argument to `map`, prefixed with an `@`:"
msgstr ""
"请注意，这定义了 `Functor` 的新实现，在隐式解析期间将 *不* 细化以避免歧义。但"
"是，可以通过将其作为显式参数传递给 `map` 来显式选择使用此实现，并以 `@` 为前"
"缀："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:351
#, no-wrap
msgid ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"
msgstr ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:358
msgid ""
"In the example above, we used `Compose` instead of `Compose'`, since the "
"former is already exported by the *Prelude*."
msgstr ""
"在上面的示例中，我们使用 `Compose` 代替 `Compose'`，因为前者已经由 *Prelude* "
"导出。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:359
#, no-wrap
msgid "Functor Laws"
msgstr "函子定律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:365
msgid ""
"Implementations of `Functor` are supposed to adhere to certain laws, just "
"like implementations of `Eq` or `Ord`. Again, these laws are not verified by "
"Idris, although it would be possible (and often cumbersome) to do so."
msgstr ""
"`Functor` 的实现应该遵守某些规律，就像 `Eq` 或 `Ord` 的实现一样。同样，这些法"
"律并未得到 Idris 的验证，尽管这样做是可能的（而且通常很麻烦）。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:370
#, no-wrap
msgid ""
"1. `map id = id`: Mapping the identity function over a functor\n"
"    must not have any visible effect such as changing a container's\n"
"    structure or affecting the side effects perfomed when\n"
"    running an `IO` action.\n"
msgstr ""
"1. `map id = id`：将恒等函数映射到函子上\n"
"    不得有任何可见的副作用，例如更改容器的\n"
"    结构或影响运行 `IO` 动作的副作用\n"
"    。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:373
msgid ""
"`map (f . g) = map f . map g`: Sequencing two mappings must be identical to "
"a single mapping using the composition of the two functions."
msgstr ""
"`map (f . g) = map f . map g`: 两个映射的顺序必须与使用两个函数组合后的单个映"
"射相同。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:380
msgid ""
"Both of these laws request, that `map` is preserving the *structure* of "
"values. This is easier to understand with container types like `List`, "
"`Maybe`, or `Either e`, where `map` is not allowed to add or remove any "
"wrapped value, nor - in case of `List` - change their order. With `IO`, this "
"can best be described as `map` not performing additional side effects."
msgstr ""
"这两条定律都要求 `map` 保留值的 *结构*。使用 `List`、`Maybe` 或 `Either e` 等"
"容器类型更容易理解，其中 `map` 不允许添加或删除任何包装的值，也不 - 在 "
"`List` 的情况下 - 更改它们的顺序。对于使用 `IO`，最好地描述为 `map` 没有执行"
"额外的副作用。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:385
msgid ""
"Write your own implementations of `Functor'` for `Maybe`, `List`, `List1`, "
"`Vect n`, `Either e`, and `Pair a`."
msgstr ""
"为 `Maybe`、`List`、`List1`、`Vect n`、`Either e` 和 `Pair a` 编写自己的 "
"`Functor'` 实现。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:388
msgid ""
"Write a named implementation of `Functor` for pairs of functors (similar to "
"the one implemented for `Product`)."
msgstr ""
"为 pairs 函数编写 `Functor` 的命名实现（类似于为 `Product` 实现的实现）。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:391
msgid ""
"Implement `Functor` for data type `Identity` (which is available from "
"`Control.Monad.Identity` in *base*):"
msgstr ""
"为数据类型 `Identity` 实现 `Functor`（可从 *base* 中的 "
"`Control.Monad.Identity` 获得）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:392
#, no-wrap
msgid ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"
msgstr ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:404
msgid ""
"Here is a curious one: Implement `Functor` for `Const e` (which is also "
"available from `Control.Applicative.Const` in *base*). You might be confused "
"about the fact that the second type parameter has absolutely no relevance at "
"runtime, as there is no value of that type. Such types are sometimes called "
"*phantom types*. They can be quite useful for tagging values with additional "
"typing information."
msgstr ""
"这是一个奇怪的问题：为 `Const e` 实现 `Functor`（也可以从 *base* 中的 "
"`Control.Applicative.Const` 获得）。您可能会对第二个类型参数在运行时绝对没有"
"相关性这一事实感到困惑，因为没有该类型的值。这种类型有时被称为 *幻像类型*。它"
"们对于使用附加类型信息标记值非常有用。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:407
#, no-wrap
msgid ""
"   Don't let the above confuse you: There is only one possible implementation.\n"
"   As usual, use holes and let the compiler guide you if you get lost.\n"
msgstr ""
"   不要让上述内容使您感到困惑：只有一种可能的实现。\n"
"   像往常一样，使用孔，如果你迷路了，让编译器指导你。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:408
#, no-wrap
msgid ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"
msgstr ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:416
msgid ""
"Here is a sum type for describing CRUD operations (Create, Read, Update, and "
"Delete) in a data store:"
msgstr "这是用于描述数据存储中的 CRUD 操作（创建、读取、更新和删除）的和类型："

#. type: Plain text
#: ../src/Tutorial/Functor.md:426
#, no-wrap
msgid "   Implement `Functor` for `Crud i`.\n"
msgstr "   为 `Crud i` 实现 `Functor`。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:428
msgid "Here is a sum type for describing responses from a data server:"
msgstr "以下是用于描述来自数据服务器的响应的和类型："

#. type: Plain text
#: ../src/Tutorial/Functor.md:439
#, no-wrap
msgid "   Implement `Functor` for `Repsonse e i`.\n"
msgstr "   为 `Repsonse e i` 实现 `Functor`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:441
msgid "Implement `Functor` for `Validated e`:"
msgstr "为 `Validated e` 实现 `Functor`："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:442
#, no-wrap
msgid ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"
msgstr ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:448
#, no-wrap
msgid "Applicative"
msgstr "应用子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:453
msgid ""
"While `Functor` allows us to map a pure, unary function over a value in a "
"context, it doesn't allow us to combine n such values under an n-ary "
"function."
msgstr ""
"虽然 `Functor` 允许我们将纯的一元函数映射到上下文中的值上，但它不允许我们在 "
"n 元函数下组合 n 个这样的值。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:455
msgid "For instance, consider the following functions:"
msgstr "例如，考虑以下函数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:456
#, no-wrap
msgid ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"
msgstr ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:478
msgid ""
"This behavior is not covered by `Functor`, yet it is a very common thing to "
"do. For instance, we might want to read two numbers from standard input "
"(both operations might fail), calculating the product of the two. Here's the "
"code:"
msgstr ""
"`Functor` 没有涵盖这种行为，但这是很常见的事情。例如，我们可能想从标准输入中"
"读取两个数字（这两个操作都可能失败），计算两者的乘积。这是代码："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:479
#, no-wrap
msgid ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
msgstr ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:490
msgid ""
"And it won't stop here. We might just as well want to have `liftMaybe3` for "
"ternary functions and three `Maybe` arguments and so on, for arbitrary "
"numbers of arguments."
msgstr ""
"它不会止步于此。对于三元函数，我们可能还希望有 `liftMaybe3` 和三个 `Maybe` 参"
"数等等，对于任意数量的参数。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:493
msgid ""
"But there is more: We'd also like to lift pure values into the context in "
"question. With this, we could do the following:"
msgstr ""
"但还有更多：我们还想将纯的值提升到所讨论的上下文中。有了这个，我们可以做以下"
"事情："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:494
#, no-wrap
msgid ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"
msgstr ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:511
msgid ""
"As you'll of course already know, I am now going to present a new interface "
"to encapsulate this behavior. It's called `Applicative`.  Here is its "
"definition and an example implementation:"
msgstr ""
"正如您当然已经知道的那样，我现在将提供一个新接口来封装这种行为。它被称为 "
"`Applicative`。这是它的定义和示例实现："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:512
#, no-wrap
msgid ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"
msgstr ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:527
#, no-wrap
msgid ""
"Interface `Applicative` is of course already exported by the *Prelude*.\n"
"There, function `app` is an operator sometimes called *app* or *apply*:\n"
"`(<*>)`.\n"
msgstr "接口 `Applicative` 当然已经由 *Prelude* 导出。在那里，函数 `app` 是一个有时称为 *app* 或 *apply* 的运算符：`(<*>)`。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:530
msgid ""
"You may wonder, how functions like `liftMaybe2` or `liftIO3` are related to "
"operator *apply*. Let me demonstrate this:"
msgstr ""
"您可能想知道，像 `liftMaybe2` 或 `liftIO3` 这样的函数如何与运算符 *apply* 相"
"关联。让我演示一下："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:531
#, no-wrap
msgid ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"
msgstr ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:544
#, no-wrap
msgid ""
"It is really important for you to understand what's going on here, so let's\n"
"break these down. If we specialize `liftA2` to use `Maybe` for `f`,\n"
"`pure fun` is of type `Maybe (a -> b -> c)`. Likewise, `pure fun <*> fa`\n"
"is of type `Maybe (b -> c)`, as `(<*>)` will apply the value stored\n"
"in `fa` to the function stored in `pure fun` (currying!).\n"
msgstr "了解这里发生的事情对您来说非常重要，所以让我们分解这些内容。如果我们将 `liftA2` 中的 `f` 用于 `Maybe`，则 `pure fun` 的类型为 `Maybe (a -> b -> c)`。同样，`pure fun <*> fa` 是 ` 类型为 `Maybe (b -> c)`，因为 `(<*>)` 将应用存储在 `f a` 到存储在 `pure fun` 中的函数（柯里化！）。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:550
msgid ""
"You'll often see such chains of applications of *apply*, the number of "
"*applies* corresponding to the arity of the function we lift.  You'll "
"sometimes also see the following, which allows us to drop the initial call "
"to `pure`, and use the operator version of `map` instead:"
msgstr ""
"你会经常看到 *apply* 这样的应用链，*applies* 的数量对应于我们提升的函数的数"
"量。您有时还会看到以下内容，这使我们可以放弃对 `pure` 的初始调用，并改用 "
"`map` 的运算符版本："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:551
#, no-wrap
msgid ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"
msgstr ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:564
msgid ""
"So, interface `Applicative` allows us to lift values (and functions!)  into "
"computational contexts and apply them to values in the same contexts. Before "
"we will see an extended example why this is useful, I'll quickly introduce "
"some syntactic sugar for working with applicative functors."
msgstr ""
"因此，接口 `Applicative` 允许我们将值（和函数！）提升到计算上下文中，并将它们"
"应用于相同上下文中的值。在我们将看到一个扩展示例为什么这很有用之前，我将快速"
"介绍一些用于使用应用函子的语法糖。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:565
#, no-wrap
msgid "Idiom Brackets"
msgstr "习语括号"

#. type: Plain text
#: ../src/Tutorial/Functor.md:571
msgid ""
"The programming style used for implementing `liftA2'` and `liftA3'` is also "
"referred to as *applicative style* and is used a lot in Haskell for "
"combining several effectful computations with a single pure function."
msgstr ""
"用于实现 `liftA2'` 和 `liftA3'` 的编程风格也称为 *应用函子风格*，在 Haskell "
"中被大量用于将单一的纯函数应用于几个副作用计算。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:575
msgid ""
"In Idris, there is an alternative to using such chains of operator "
"applications: Idiom brackets. Here's another reimplementation of `liftA2` "
"and `liftA3`:"
msgstr ""
"在 Idris 中，有一个替代使用这种运算符应用程序链的方法：习语括号。这是 "
"`liftA2` 和 `liftA3` 的另一个重新实现："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:576
#, no-wrap
msgid ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"
msgstr ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:590
#, no-wrap
msgid ""
"The above implementations will be desugared to the one given\n"
"for `liftA2` and `liftA3`, again *before disambiguating,\n"
"type checking, and filling in of implicit values*. Like with the\n"
"*bind* operator, we can therefore write custom implementations\n"
"for `pure` and `(<*>)`, and Idris will use these if it\n"
"can disambiguate between the overloaded function names.\n"
msgstr "在消除歧义、类型检查和填充隐式值 *之前*，上述实现将被简化为 `liftA2` 和 `liftA3` 给定的实现。与 *bind* 运算符一样，我们因此可以为 `pure` 和 `(<*>)` 编写自定义实现，如果 Idris 可以消除重载函数名称之间的歧义，它将使用这些名称。。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:591
#, no-wrap
msgid "Use Case: CSV Reader"
msgstr "用例：CSV 阅读器"

#. type: Plain text
#: ../src/Tutorial/Functor.md:604
msgid ""
"In order to understand the power and versatility that comes with applicative "
"functors, we will look at a slightly extended example. We are going to write "
"some utilities for parsing and decoding content from CSV files. These are "
"files where each line holds a list of values separated by commas (or some "
"other delimiter). Typically, they are used to store tabular data, for "
"instance from spread sheet applications. What we would like to do is convert "
"lines in a CSV file and store the result in custom records, where each "
"record field corresponds to a column in the table."
msgstr ""
"为了理解应用函子的强大功能和多功能性，我们将看一个稍微扩展的示例。我们将编写"
"一些实用程序来解析和解码 CSV 文件中的内容。这些文件的每一行都包含一个由逗号"
"（或其他分隔符）分隔的值列表。通常，它们用于存储表格数据，例如来自电子表格应"
"用程序的数据。我们想要做的是转换 CSV 文件中的行并将结果存储在自定义记录中，其"
"中每个记录字段对应于表中的一列。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:609
msgid ""
"For instance, here is a simple example file, containing tabular user "
"information from a web store: First name, last name, age (optional), email "
"address, gender, and password."
msgstr ""
"例如，这是一个简单的示例文件，其中包含来自网络商店的表格用户信息：名字、姓"
"氏、年龄（可选）、电子邮件地址、性别和密码。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:610
#, no-wrap
msgid ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"
msgstr ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:621
msgid ""
"And here are the Idris data types necessary to hold this information at "
"runtime. We use again custom string wrappers for increased type safety and "
"because it will allow us to define for each data type what we consider to be "
"valid input:"
msgstr ""
"以下是在运行时保存此信息所必需的 Idris 数据类型。我们再次使用自定义字符串包装"
"器来提高类型安全性，因为它允许我们为每种数据类型定义我们认为是有效输入的内"
"容："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:622
#, no-wrap
msgid ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"
msgstr ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:650
msgid ""
"We start by defining an interface for reading fields in a CSV file and "
"writing implementations for the data types we'd like to read:"
msgstr ""
"我们首先定义一个用于读取 CSV 文件中的字段的接口，并为我们想要读取的数据类型编"
"写实现："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:651
#, no-wrap
msgid ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"
msgstr ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:659
msgid ""
"Below are implementations for `Gender` and `Bool`. I decided to in these "
"cases encode each value with a single lower case character:"
msgstr ""
"下面是 `Gender` 和 `Bool` 的实现。在这些情况下，我决定使用单个小写字符对每个"
"值进行编码："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:660
#, no-wrap
msgid ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"
msgstr ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:675
msgid "For numeric types, we can use the parsing functions from `Data.String`:"
msgstr "对于数值类型，我们可以使用 `Data.String` 中的解析函数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:676
#, no-wrap
msgid ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"
msgstr ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:692
#, no-wrap
msgid ""
"For optional values, the stored type must itself\n"
"come with an instance of `CSVField`. We can then treat\n"
"the empty string `\"\"` as `Nothing`, while a non-empty\n"
"string will be passed to the encapsulated type's field reader.\n"
"(Remember that `(<$>)` is an alias for `map`.)\n"
msgstr "对于可选值，存储的类型本身必须带有 `CSVField` 的实例。然后我们可以将空字符串 `\"\"` 视为 `Nothing`，而将非空字符串传递给封装类型的字段读取器。 （记住 `(<$>)` 是 `map` 的别名。）\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:693
#, no-wrap
msgid ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"
msgstr ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:703
msgid ""
"Finally, for our string wrappers, we need to decide what we consider to be "
"valid values. For simplicity, I decided to limit the length of allowed "
"strings and the set of valid characters."
msgstr ""
"最后，对于我们的字符串包装器，我们需要决定我们认为什么是有效值。为简单起见，"
"我决定限制允许的字符串长度和有效字符集。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:704
#, no-wrap
msgid ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"-- please note that isSpace holds as well for other characaters than ' '\n"
"-- e.g. for non-breaking space: isSpace '\\160' = True\n"
"-- but only ' ' shall be llowed in passwords\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"
msgstr ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:748
msgid ""
"In a later chapter, we will learn about refinement types and how to store an "
"erased proof of validity together with a validated value."
msgstr ""
"在后面的章节中，我们将学习细化类型以及如何将已擦除的有效性证明与验证值一起存"
"储。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:752
msgid ""
"We can now start to decode whole lines in a CSV file.  In order to do so, we "
"first introduce a custom error type encapsulating how things can go wrong:"
msgstr ""
"我们现在可以开始解码 CSV 文件中的整行。为了做到这一点，我们首先引入一个自定义"
"错误类型来封装事情是如何出错的："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:753
#, no-wrap
msgid ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"
msgstr ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:763
msgid ""
"We can now use `CSVField` to read a single field at a given line and "
"position in a CSV file, and return a `FieldError` in case of a failure."
msgstr ""
"我们现在可以使用 `CSVField` 读取 CSV 文件中给定行和位置的单个字段，并在失败的"
"情况下返回 `FieldError`。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:764
#, no-wrap
msgid ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"
msgstr ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:775
msgid ""
"If we know in advance the number of fields we need to read, we can try and "
"convert a list of strings to a `Vect` of the given length. This facilitates "
"reading record values of a known number of fields, as we get the correct "
"number of string variables when pattern matching on the vector:"
msgstr ""
"如果我们事先知道需要读取的字段数量，我们可以尝试将字符串列表转换为给定长度的 "
"`Vect`。这有助于读取已知数量字段的记录值，因为我们在向量上进行模式匹配时得到"
"正确数量的字符串变量："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:776
#, no-wrap
msgid ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
msgstr ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:786
msgid ""
"Finally, we can implement function `readUser` to try and convert a single "
"line in a CSV-file to a value of type `User`:"
msgstr ""
"最后，我们可以实现函数 `readUser` 来尝试将 CSV 文件中的一行转换为 `User` 类型"
"的值："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:787
#, no-wrap
msgid ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"
msgstr ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:803 ../src/Tutorial/Traverse.md:122
msgid "Let's give this a go at the REPL:"
msgstr "让我们在 REPL 上试一试："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:804
#, no-wrap
msgid ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"
msgstr ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:819
msgid ""
"Note, how in the implementation of `readUser'` we used an idiom bracket to "
"map a function of six arguments (`MkUser`)  over six values of type `Either "
"CSVError`. This will automatically succeed, if and only if all of the "
"parsings have succeeded. It would have been notoriously cumbersome resulting "
"in much less readable code to implement `readUser'` with a succession of six "
"nested pattern matches."
msgstr ""
"请注意，在 `readUser'` 的实现中，我们如何使用习语括号将六个参数 (`MkUser`) 的"
"函数映射到 `Either CSVError` 类型的六个值上。当且仅当所有解析都成功时，这将自"
"动成功。众所周知，使用连续六个嵌套模式匹配来实现 `readUser'` 的代码的可读性会"
"大大降低。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:822
msgid ""
"However, the idiom bracket above looks still quite repetitive.  Surely, we "
"can do better?"
msgstr "但是，上面的习语括号看起来仍然非常重复。当然，我们可以做得更好吗？"

#. type: Title ####
#: ../src/Tutorial/Functor.md:823
#, no-wrap
msgid "A Case for Heterogeneous Lists"
msgstr "异构列表的案例"

#. type: Plain text
#: ../src/Tutorial/Functor.md:830
msgid ""
"It is time to learn about a family of types, which can be used as a generic "
"representation for record types, and which will allow us to represent and "
"read rows in heterogeneous tables with a minimal amount of code: "
"Heterogeneous lists."
msgstr ""
"是时候学习一组类型了，它们可以用作记录类型的通用表示，并且允许我们用最少的代"
"码表示和读取异构表中的行：异构列表。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:831
#, no-wrap
msgid ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
msgstr ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:844
msgid ""
"A heterogeneous list is a list type indexed over a *list of types*.  This "
"allows us to at each position store a value of the type at the same position "
"in the list index. For instance, here is a variant, which stores three "
"values of types `Bool`, `Nat`, and `Maybe String` (in that order):"
msgstr ""
"异构列表是在 *类型列表* 上索引的列表类型。这允许我们在每个位置将类型的值存储"
"在列表索引中的相同位置。例如，这里有一个变体，它存储了 `Bool`、`Nat` 和 "
"`Maybe String` 类型的三个值（按此顺序）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:845
#, no-wrap
msgid ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"
msgstr ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:857
msgid ""
"You could argue that heterogeneous lists are just tuples storing values of "
"the given types. That's right, of course, however, as you'll learn the hard "
"way in the exercises, we can use the list index to perform compile-time "
"computations on `HList`, for instance when concatenating two such lists to "
"keep track of the types stored in the result at the same time."
msgstr ""
"您可能会争辩说，异构列表只是存储给定类型值的元组。没错，当然，但是，因为您将"
"在练习中学习困难的方法，我们可以使用列表索引对 `HList` 执行编译时计算，例如连"
"接两个这样的列表以保持同时跟踪结果中存储的类型。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:862
msgid ""
"But first, we'll make use of `HList` as a means to concisely parse CSV-"
"lines. In order to do that, we need to introduce a new interface for types "
"corresponding to whole lines in a CSV-file:"
msgstr ""
"但首先，我们将使用 `HList` 作为简洁解析 CSV 行的方法。为此，我们需要为对应于 "
"CSV 文件中整行的类型引入一个新接口："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:863
#, no-wrap
msgid ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
msgstr ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:874
msgid ""
"We'll now write two implementations of `CSVLine` for `HList`: One for the "
"`Nil` case, which will succeed if and only if the current list of strings is "
"empty. The other for the *cons* case, which will try and read a single field "
"from the head of the list and the remainder from its tail. We use again an "
"idiom bracket to concatenate the results:"
msgstr ""
"现在，我们将为 `HList` 编写 `CSVLine` 的两个实现：一个针对 `Nil` 的情况，当且"
"仅当当前字符串列表为空时才会成功.另一个用于 *cons* 的情况，它将尝试从列表的头"
"部读取单个字段，并从其尾部读取剩余部分。我们再次使用惯用括号来连接结果："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:875
#, no-wrap
msgid ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
msgstr ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:890
msgid ""
"And that's it! All we need to add is two utility function for decoding whole "
"lines before they have been split into tokens, one of which is specialized "
"to `HList` and takes an erased list of types as argument to make it more "
"convenient to use at the REPL:"
msgstr ""
"就是这样！我们需要添加的是两个实用函数，用于在将整行拆分为标记之前对其进行解"
"码，其中一个专用于 `HList` 并将已擦除的类型列表作为参数，以使其更方便使用在 "
"REPL："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:891
#, no-wrap
msgid ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"
msgstr ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:905
msgid ""
"It's time to reap the fruits of our labour and give this a go at the REPL:"
msgstr "是时候收获我们的劳动成果并在 REPL 上试一试了："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:906
#, no-wrap
msgid ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"
msgstr ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:913
#, no-wrap
msgid "Applicative Laws"
msgstr "应用函子法律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:917
msgid ""
"Again, `Applicative` implementations must follow certain laws. Here they are:"
msgstr "同样，`Applicative` 的实现必须遵循一定的规律。他们来了："

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:920
msgid ""
"`pure id <*> fa = fa`: Lifting and applying the identity function has no "
"visible effect."
msgstr "`pure id <*> fa = fa`：提升和应用恒等函数没有可见作用。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:925
msgid ""
"`[| f . g |] <*> v = f <*> (g <*> v)`: I must not matter, whether we compose "
"our functions first and then apply them, or whether we apply our functions "
"first and then compose them."
msgstr ""
"`[| f . g |] <*> v = f <*> (g <*> v)`：不管是先组合函数然后应用它们，还是先应"
"用函数然后组合它们，结果应该相同。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:928
#, no-wrap
msgid ""
"  The above might be hard to understand, so here\n"
"  they are again with explicit types and implementations:\n"
msgstr ""
"  上面的可能很难理解，所以这里\n"
"  它们再次具有显式类型和实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:929
#, no-wrap
msgid ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"
msgstr ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:939
#, no-wrap
msgid ""
"  The second applicative law states, that the two implementations\n"
"  `compL` and `compR` should behave identically.\n"
msgstr ""
"  第二个应用函子法律规定，这两个实施\n"
"  `compL` 和 `compR` 的行为应该相同。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:942
msgid ""
"`pure f <*> pure x = pure (f x)`. This is also called the *homomorphism* "
"law. It should be pretty self-explaining."
msgstr ""
"`pure f <*> pure x = pure (f x)`。这也称为 *同态* 定律。这应该是不言自明的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:945
msgid ""
"`f <*> pure v = pure ($ v) <*> f`. This is called the law of *interchange*."
msgstr "`f <*> pure v = pure ($ v) <*> f`。这称为*交换*律。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:947
#, no-wrap
msgid "  This should again be explained with a concrete example:\n"
msgstr "  这应该再次用一个具体的例子来解释：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:948
#, no-wrap
msgid ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"
msgstr ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:960
#, no-wrap
msgid ""
"  Note, that `($ v)` has type `(a -> b) -> b`, so this\n"
"  is a function type being applied to `f`, which has\n"
"  a function of type `a -> b` wrapped in a `Maybe`\n"
"  context.\n"
msgstr ""
"  注意，`($ v)` 的类型是 `(a -> b) -> b`，所以这个\n"
"  是应用于 `f` 的函数类型，它有一个\n"
"  `a -> b` 类型的函数，被包裹在 `Maybe` 上下文中。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:964
#, no-wrap
msgid ""
"  The law of interchange states that it must not matter\n"
"  whether we apply a pure value from the left or\n"
"  right of the *apply* operator.\n"
msgstr "  交换律指出， 我们是从左边应用一个纯值还是 *apply* 运算符的右侧。它必须无关紧要\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:968
msgid "Implement `Applicative'` for `Either e` and `Identity`."
msgstr "为 `Either e` 和 `Identity` 实现 `Applicative'`。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:973
msgid ""
"Implement `Applicative'` for `Vect n`. Note: In order to implement `pure`, "
"the length must be known at runtime.  This can be done by passing it as an "
"unerased implicit to the interface implementation:"
msgstr ""
"为 `Vect n` 实现 `Applicative'`。注意：为了实现 `pure`，必须在运行时知道长"
"度。这可以通过将其作为未擦除的隐式传递给接口实现来完成："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:974
#, no-wrap
msgid "   implementation {n : _} -> Applicative' (Vect n) where\n"
msgstr "   implementation {n : _} -> Applicative' (Vect n) where\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:980
msgid ""
"Implement `Applicative'` for `Pair e`, with `e` having a `Monoid` constraint."
msgstr "为 `Pair e` 实现 `Applicative'`，其中 `e` 具有 `Monoid` 约束。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:983
msgid ""
"Implement `Applicative` for `Const e`, with `e` having a `Monoid` constraint."
msgstr "为 `Const e` 实现 `Applicative`，其中 `e` 具有 `Monoid` 约束。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:988
msgid ""
"Implement `Applicative` for `Validated e`, with `e` having a `Semigroup` "
"constraint. This will allow us to use `(<+>)` to accumulate errors in case "
"of two `Invalid` values in the implementation of *apply*."
msgstr ""
"为 `Validated e` 实现 `Applicative`，其中 `e` 具有 `Semigroup` 约束。这将允许"
"我们在 *apply* 的实现中使用 `(<+>)` 来累积两个 `Invalid` 值的错误。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:993
msgid ""
"Add an additional data constructor of type `CSVError -> CSVError -> "
"CSVError` to `CSVError` and use this to implement `Semigroup` for `CSVError`."
msgstr ""
"添加一个 `CSVError -> CSVError -> CSVError` 到 `CSVError` 类型的附加数据构造"
"函数，并使用它为 `CSVError` 实现 `Semigroup`。"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:997
msgid ""
"Refactor our CSV-parsers and all related functions so that they return "
"`Validated` instead of `Either`. This will only work, if you solved exercise "
"6."
msgstr ""
"重构我们的 CSV 解析器和所有相关函数，使它们返回 `Validated` 而不是 `Either`。"
"这只有在你解决了练习 6 的情况下才有效。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1003
#, no-wrap
msgid ""
"   Two things to note: You will have to adjust very little of\n"
"   the existing code, as we can still use applicative syntax\n"
"   with `Validated`. Also, with this change, we enhanced our CSV-parsers\n"
"   with the ability of error accumulation. Here are some examples\n"
"   from a REPL session:\n"
msgstr ""
"   需要注意的两件事：您将不得不调整很少的\n"
"   现有代码，因为我们仍然可以通过使用 `Validated`使用应用语法\n"
"   。此外，通过此更改，我们增强了 CSV 解析器\n"
"   具有累积误差的能力。这里有些来自 REPL 会话的例子：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1004
#, no-wrap
msgid ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
msgstr ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1018
#, no-wrap
msgid ""
"   Behold the power of applicative functors and heterogeneous lists: With\n"
"   only a few lines of code we wrote a pure, type-safe, and total\n"
"   parser with error accumulation for lines in CSV-files, which is\n"
"   very convenient to use at the same time!\n"
msgstr ""
"   看看应用函子和异构列表的力量：\n"
"   仅仅几行代码，我们就编写了一个纯粹的、类型安全的、完全的\n"
"   对 CSV 文件中的行进行错误累积的解析器，同时使用非常方便！\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Functor.md:1021
msgid ""
"Since we introduced heterogeneous lists in this chapter, it would be a pity "
"not to experiment with them a little."
msgstr "由于我们在本章中介绍了异构列表，很遗憾没有对它们进行一些实验。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1030
#, no-wrap
msgid ""
"   This exercise is meant to sharpen your skills in type wizardry.\n"
"   It therefore comes with very few hints. Try to decide yourself\n"
"   what behavior you'd expect from a given function, how to express\n"
"   this in the types, and how to implement it afterwards.\n"
"   If your types are correct and precise enough, the implementations\n"
"   will almost come for free. Don't give up too early if you get stuck.\n"
"   Only if you truly run out of ideas should you have a glance\n"
"   at the solutions (and then, only at the types at first!)\n"
msgstr ""
"   这个练习旨在提高你的类型技巧的技能。\n"
"   因此，它带有很少的提示。您期望从给定函数中获得什么行为试着自己做决定\n"
"   ，这在类型中如何表达，以及之后如何实现它。\n"
"   如果您的类型足够正确和精确，那么实现\n"
"   几乎是轻而易举的。如果遇到困难，不要过早放弃。\n"
"   只有当你真的没有想法时，你才应该瞥一眼\n"
"   在解决方案上（然后，首先只在类型上！）\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1032
msgid "Implement `head` for `HList`."
msgstr "为 `HList` 实现 `head`。"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1034
msgid "Implement `tail` for `HList`."
msgstr "为 `HList` 实现 `tail`。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1036
msgid "Implement `(++)` for `HList`."
msgstr "为 `HList` 实现 `(++)`。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1040
msgid ""
"Implement `index` for `HList`. This might be harder than the other three.  "
"Go back and look how we implemented `indexList` in an [earlier exercise]"
"(Dependent.md) and start from there."
msgstr ""
"为 `HList` 实现 `index`。这可能比其他三个更难。回过头来看看我们如何在 [前面的"
"练习](Dependent.md) 中实现 `indexList` 并从那里开始。"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1046
msgid ""
"Package *contrib*, which is part of the Idris project, provides "
"`Data.HVect.HVect`, a data type for heterogeneous vectors. The only "
"difference to our own `HList` is, that `HVect` is indexed over a vector of "
"types instead of a list of types. This makes it easier to express certain "
"operations at the type level."
msgstr ""
"*contrib* 包是 Idris 项目的一部分，它提供了 `Data.HVect.HVect`，一种异构向量"
"的数据类型。与我们自己的 `HList` 的唯一区别是，`HVect` 是通过类型向量而不是类"
"型列表来索引的。这使得在类型级别表达某些操作变得更容易。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1049
#, no-wrap
msgid ""
"      Write your own implementation of `HVect` together with functions\n"
"      `head`, `tail`, `(++)`, and `index`.\n"
msgstr ""
"      编写您自己的 `HVect` 实现以及函数\n"
"      `head`、`tail`、`(++)` 和 `index`。\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1053
msgid ""
"For a real challenge, try implementing a function for transposing a `Vect m "
"(HVect ts)`. You'll first have to be creative about how to even express this "
"in the types."
msgstr ""
"对于真正的挑战，尝试实现一个函数来转置 `Vect m (HVect ts)`。您首先必须对如何"
"在类型中表达这一点有创意。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1060
#, no-wrap
msgid ""
"      Note: In order to implement this, you'll need to pattern match\n"
"      on an erased argument in at least one case to help Idris with\n"
"      type inference. Pattern matching on erased arguments is forbidden\n"
"      (they are erased after all, so we can't inspect them at runtime),\n"
"      *unless* the structure of the value being matched on can be derived\n"
"      from another, un-erased argument.\n"
msgstr ""
"      注意：为了实现这一点，您需要在至少一个案例中的一个被抹去的参数上进行模式匹配，以帮助 Idris 进行类型推断。禁止对已擦除参数进行模式匹配\n"
"      （它们毕竟被删除了，所以我们不能在运行时检查它们），\n"
"      *除非* 可以通过另一个未被抹去的参数推导出被匹配的值的结构。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1064
#, no-wrap
msgid ""
"      Also, don't worry if you get stuck on this one. It took me several\n"
"      tries to figure it out. But I enjoyed the experience, so I just *had*\n"
"      to include it here. :-)\n"
msgstr "      另外，如果您卡在这个上，请不要担心。我花了好几次才试图把他弄清楚。但是我很享受这种体验，所以我 *必须* 把它包括在这里。 :-)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1068
#, no-wrap
msgid ""
"      Note, however, that such a function might be useful when working with\n"
"      CSV-files, as it allows us to convert a table represented as\n"
"      rows (a vector of tuples) to one represented as columns (a tuple of vectors).\n"
msgstr "      但是请注意，当使用 CSV 文件时这样的函数会很有用，因为它允许我们将表示为行（元组向量）的表转换到表示为列（向量元组）的表。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Functor.md:1072
msgid ""
"Show, that the composition of two applicative functors is again an "
"applicative functor by implementing `Applicative` for `Comp f g`."
msgstr ""
"通过为 `Comp f g` 实现 `Applicative` 来证明两个应用函子的组合再次是一个应用函"
"子。"

#. type: Bullet: '10. '
#: ../src/Tutorial/Functor.md:1076
msgid ""
"Show, that the product of two applicative functors is again an applicative "
"functor by implementing `Applicative` for `Prod f g`."
msgstr ""
"通过为 `Prod f g` 实现 `Applicative` 证明两个应用函子的乘积再次是一个应用函"
"子。"

#. type: Title ##
#: ../src/Tutorial/Functor.md:1077
#, no-wrap
msgid "Monad"
msgstr "单子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1084
#, no-wrap
msgid ""
"Finally, `Monad`. A lot of ink has been spilled about this one.\n"
"However, after what we already saw in the [chapter about `IO`](IO.md),\n"
"there is not much left to discuss here. `Monad` extends\n"
"`Applicative` and adds two new related functions: The *bind*\n"
"operator (`(>>=)`) and function `join`. Here is its definition:\n"
msgstr "最后，`Monad`。关于这一点已经泼了很多墨水。然而，在我们已经在 [关于 `IO`](IO.md) 的章节中看到之后，这里就没有太多要讨论的内容了。`Monad` 扩展了 `Applicative` 并添加了两个新的相关函数：*bind* 运算符 (`(>>=)`) 和函数 `join `。这是它的定义：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1085
#, no-wrap
msgid ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"
msgstr ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1094
#, no-wrap
msgid ""
"Implementers of `Monad` are free to choose to either implement\n"
"`(>>=)` or `join` or both. You will show in an exercise, how\n"
"`join` can be implemented in terms of *bind* and vice versa.\n"
msgstr "`Monad` 的实现者可以自由选择实现 `(>>=)` 或 `join` 或两者。您将在练习中展示如何根据 *bind* 来实现 `join`，反之亦然。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1102
msgid ""
"The big difference between `Monad` and `Applicative` is, that the former "
"allows a computation to depend on the result of an earlier computation. For "
"instance, we could decide based on a string read from standard input whether "
"to delete a file or play a song. The result of the first `IO` action "
"(reading some user input) will affect, which `IO` action to run next.  This "
"is not possible with the *apply* operator:"
msgstr ""
"`Monad` 和 `Applicative` 之间的最大区别在于，前者允许计算依赖于早期计算的结"
"果。例如，我们可以根据从标准输入中读取的字符串来决定是删除文件还是播放歌曲。"
"第一个 `IO` 动作（读取一些用户输入）的结果将影响下一个要运行的 `IO` 动作。这"
"对于 *apply* 运算符是不可能的："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1103
#, no-wrap
msgid "(<*>) : IO (a -> b) -> IO a -> IO b\n"
msgstr "(<*>) : IO (a -> b) -> IO a -> IO b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1118
#, no-wrap
msgid ""
"The two `IO` actions have already been decided on when they\n"
"are being passed as arguments to `(<*>)`. The result of the first\n"
"cannot - in the general case - affect which computation to\n"
"run in the second. (Actually, with `IO` this would theoretically be\n"
"possible via side effects: The first action could write some\n"
"command to a file or overwrite some mutable state, and the\n"
"second action could read from that file or state, thus\n"
"deciding on the next thing to do. But this is a speciality\n"
"of `IO`, not of applicative functors in general. If the functor in\n"
"question was `Maybe`, `List`, or `Vector`, no such thing\n"
"would be possible.)\n"
msgstr "两个 `IO` 动作在作为参数传递给 `(<*>)` 时已经确定。在一般情况下，第一个结果不能影响在第二个中运行哪个计算。 （实际上，使用 `IO` 理论上可以通过副作用实现：第一个操作可以将某些命令写入文件或覆盖某些可变状态，而第二个操作可以从该文件或状态读取，从而决定接下来要做的事情。但这是 `IO` 的特长，而不是一般的应用函子。如果有问题的函子是 `Maybe`，`List`，或 `Vector`，这是不可能的。）\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1124
msgid ""
"Let's demonstrate the difference with an example. Assume we'd like to "
"enhance our CSV-reader with the ability to decode a line of tokens to a sum "
"type. For instance, we'd like to decode CRUD requests from the lines of a "
"CSV-file:"
msgstr ""
"让我们用一个例子来演示一下区别。假设我们想增强我们的 CSV 阅读器，使其能够将一"
"行标记解码为和型。例如，我们想从 CSV 文件的行中解码 CRUD 请求："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1125
#, no-wrap
msgid ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"
msgstr ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1137
msgid ""
"We need a way to on each line decide, which data constructor to choose for "
"our decoding. One way to do this is to put the name of the data constructor "
"(or some other tag of identification) in the first column of the CSV-file:"
msgstr ""
"我们需要一种方法来在每一行上决定为我们的解码选择哪个数据构造函数。一种方法是"
"将数据构造函数的名称（或其他标识标签）放在 CSV 文件的第一列中："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1138
#, no-wrap
msgid ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"
msgstr ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1167
msgid ""
"I added two utility function for helping with type inference and to get "
"slightly nicer syntax. The important thing to note is, how we pattern match "
"on the result of the first parsing function to decide on the data "
"constructor and thus the next parsing function to use."
msgstr ""
"我添加了两个实用函数来帮助进行类型推断并获得更好的语法。需要注意的重要一点"
"是，我们如何对第一个解析函数的结果进行模式匹配，以决定数据构造函数，从而决定"
"下一个要使用的解析函数。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1169
msgid "Here's how this works at the REPL:"
msgstr "在 REPL 中看一下工作原理："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1170
#, no-wrap
msgid ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"
msgstr ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1187
msgid ""
"To conclude, `Monad`, unlike `Applicative`, allows us to chain computations "
"sequentially, where intermediary results can affect the behavior of later "
"computations.  So, if you have n unrelated effectful computations and want "
"to combine them under a pure, n-ary function, `Applicative` will be "
"sufficient. If, however, you want to decide based on the result of an "
"effectful computation what computation to run next, you need a `Monad`."
msgstr ""
"总而言之，`Monad` 与 `Applicative` 不同，它允许我们按顺序链接计算，其中中间结"
"果会影响后续计算的行为。因此，如果您有 n 个不相关的有效计算并希望将它们组合在"
"一个纯 n 元函数下，`Applicative` 就足够了。但是，如果您想根据有效计算的结果来"
"决定接下来要运行什么计算，则需要 `Monad`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1193
msgid ""
"Note, however, that `Monad` has one important drawback compared to "
"`Applicative`: In general, monads don't compose.  For instance, there is no "
"`Monad` instance for `Either e . IO`.  We will later learn about monad "
"transformers, which can be composed with other monads."
msgstr ""
"但是请注意，与 `Applicative` 相比，`Monad` 有一个重要的缺点：通常，monad 不能"
"组合。例如， `Either e . IO` 没有 `Monad` 实例。稍后我们将了解可以与其他 "
"monad 组合的 monad 转换器。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1194
#, no-wrap
msgid "Monad Laws"
msgstr "单子定律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1197
msgid "Without further ado, here are the laws for `Monad`:"
msgstr "事不宜迟，以下是 `Monad` 的定律："

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1201
msgid ""
"`ma >>= pure = ma` and `pure v >>= f = f v`.  These are monad's identity "
"laws. Here they are as concrete examples:"
msgstr ""
"`ma >>= pure = ma` 和 `pure v >>= f = f v`。这些是 monad 的恒等律。下面是具体"
"的例子："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1202
#, no-wrap
msgid ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"
msgstr ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1215
#, no-wrap
msgid ""
"  These two laws state that `pure` should behave\n"
"  neutrally w.r.t. *bind*.\n"
msgstr "  这两条定律规定 `pure` 在 *bind* 中应该表现为中立。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1221
msgid ""
"`(m >>= f) >>= g = m >>= (f >=> g)`.  This is the law of associativity for "
"monad.  You might not have seen the second operator `(>=>)`.  It can be used "
"to sequence effectful computations and has the following type:"
msgstr ""
"`(m >>= f) >>= g = m >>= (f >=> g)` 是 monad 的结合律。您可能没有见过第二个运"
"算符 `(>=>)`。它可用于对副作用计算进行排序，并具有以下类型："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1222
#, no-wrap
msgid ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
msgstr ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1232
#, no-wrap
msgid ""
"The above are the *official* monad laws. However, we need to\n"
"consider a third one, given that in Idris (and Haskell)\n"
"`Monad` extends `Applicative`: As `(<*>)` can be implemented\n"
"in terms of `(>>=)`, the actual implementation of `(<*>)`\n"
"must behave the same as the implementation in terms of `(>>=)`:\n"
msgstr "以上是 *官方的* monad 定律。但是，我们需要考虑第三个，因为在 Idris（和 Haskell）中，`Monad` 扩展自 `Applicative`: 由于 `(<*>)` 可以由 `(>>=)` 实现，`(<*>)` 的实际实现必须与 `(>>=)` 的实现表现相同：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1234
msgid "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`."
msgstr "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`."

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:1240
msgid ""
"`Applicative` extends `Functor`, because every `Applicative` is also a "
"`Functor`. Proof this by implementing `map` in terms of `pure` and `(<*>)`."
msgstr ""
"`Applicative` 扩展了 `Functor`，因为每个 `Applicative` 也是一个 `Functor`。通"
"过根据 `pure` 和 `(<*>)` 实现 `map` 来证明这一点。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:1244
msgid ""
"`Monad` extends `Applicative`, because every `Monad` is also an "
"`Applicative`. Proof this by implementing `(<*>)` in terms of `(>>=)` and "
"`pure`."
msgstr ""
"`Monad` 扩展了 `Applicative`，因为每个 `Monad` 也是一个 `Applicative`。通过根"
"据 `(>>=)` 和 `pure` 实现 `(<*>)` 来证明这一点。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:1247
msgid ""
"Implement `(>>=)` in terms of `join` and other functions in the `Monad` "
"hierarchy."
msgstr "根据 `join` 和 `Monad` 层次结构中的其他函数实现 `(>>=)`。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:1250
msgid ""
"Implement `join` in terms of `(>>=)` and other functions in the `Monad` "
"hierarchy."
msgstr "根据 `(>>=)` 和 `Monad` 层次结构中的其他函数实现 `join`。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:1253
msgid "There is no lawful `Monad` implementation for `Validated e`.  Why?"
msgstr "`Validated e` 没有合法的 `Monad` 实现。为什么？"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:1259
msgid ""
"In this slightly extended exercise, we are going to simulate CRUD operations "
"on a data store. We will use a mutable reference (imported from `Data.IORef` "
"from the *base* library)  holding a list of `User`s paired with a unique ID "
"of type `Nat` as our user data base:"
msgstr ""
"在这个稍微扩展的练习中，我们将在数据存储上模拟 CRUD 操作。我们将使用一个可变"
"引用（从 *base* 库中的 `Data.IORef` 导入），其中包含一个 `User` 列表和一个类"
"型为 `Nat` 的唯一 ID 作为我们的用户数据库："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1260
#, no-wrap
msgid ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"
msgstr ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1270
#, no-wrap
msgid ""
"   Most operations on a database come with a risk of failure:\n"
"   When we try to update or delete a user, the entry in question\n"
"   might no longer be there. When we add a new user, a user\n"
"   with the given email address might already exist. Here is\n"
"   a custom error type to deal with this:\n"
msgstr ""
"   数据库上的大多数操作都有失败的风险：\n"
"   当我们尝试更新或删除用户时，有问题的条目\n"
"   可能不再存在。当我们添加一个新用户时，一个用户\n"
"   与给定的电子邮件地址可能已经存在。这是\n"
"   处理此问题的自定义错误类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1271
#, no-wrap
msgid ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"
msgstr ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1280
#, no-wrap
msgid ""
"   In general, our functions will therefore have a\n"
"   type similar to the following:\n"
msgstr ""
"   一般来说，我们的函数因此会有一个\n"
"   类似于以下内容的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1281
#, no-wrap
msgid "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"
msgstr "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1287
#, no-wrap
msgid ""
"   We'd like to abstract over this, by introducing a new wrapper\n"
"   type:\n"
msgstr ""
"   我们想通过引入一个新的包装器来抽象这个\n"
"   类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1288
#, no-wrap
msgid ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"
msgstr ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1297
#, no-wrap
msgid ""
"   We are now ready to write us some utility functions. Make sure\n"
"   to follow the following business rules when implementing the\n"
"   functions below:\n"
msgstr ""
"   我们现在准备为我们编写一些实用函数。确保\n"
"   在实施时遵循以下业务规则\n"
"   以下功能：\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1300
msgid ""
"Email addresses in the DB must be unique. (Consider implementing `Eq Email` "
"to verify this)."
msgstr ""
"数据库中的电子邮件地址必须是唯一的。 （考虑实现 `Eq Email` 来验证这一点）。"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1302
msgid "The size limit of 1000 entries must not be exceeded."
msgstr "不得超过 1000 个条目的大小限制。"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1306
msgid ""
"Operations trying to lookup a user by their ID must fail with `UserNotFound` "
"in case no entry was found in the DB."
msgstr ""
"如果在 DB 中找不到条目，则尝试通过 ID 查找用户的操作必须失败并显示 "
"`UserNotFound`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1311
#, no-wrap
msgid ""
"   You'll need the following functions from `Data.IORef` when working\n"
"   with mutable references: `newIORef`, `readIORef`, and `writeIORef`.\n"
"   In addition, functions `Data.List.lookup` and `Data.List.find` might\n"
"   be useful to implement some of the functions below.\n"
msgstr ""
"   工作时需要 `Data.IORef` 中的以下功能\n"
"   具有可变引用：`newIORef`、`readIORef` 和 `writeIORef`。\n"
"   此外，函数 `Data.List.lookup` 和 `Data.List.find` 可能\n"
"   对实现以下某些功能很有用。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1313
msgid "Implement interfaces `Functor`, `Applicative`, and `Monad` for `Prog`."
msgstr "为 `Prog` 实现接口 `Functor`、`Applicative` 和 `Monad`。"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1315
msgid "Implement interface `HasIO` for `Prog`."
msgstr "为 `Prog` 实现接口 `HasIO`。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1317
msgid "Implement the following utility functions:"
msgstr "实现以下实用函数："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1320
#, no-wrap
msgid ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"
msgstr ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1322
#, no-wrap
msgid "      getUsers : Prog (List (Nat,User))\n"
msgstr "      getUsers : Prog (List (Nat,User))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1325
#, no-wrap
msgid ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"
msgstr ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1329
#, no-wrap
msgid ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"
msgstr ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1333
msgid ""
"Implement function `lookupUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found."
msgstr ""
"实现函数`lookupUser`。如果找不到具有给定 ID 的用户，这应该会失败并出现适当的"
"错误。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1337
#, no-wrap
msgid ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1342
msgid ""
"Implement function `deleteUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found. Make use of `lookupUser` in "
"your implementation."
msgstr ""
"实现函数 `deleteUser`。如果找不到具有给定 ID 的用户，这应该会失败并出现适当的"
"错误。在您的实现中使用 `lookupUser`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1346
#, no-wrap
msgid ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1352
msgid ""
"Implement function `addUser`. This should fail, if a user with the given "
"`Email` already exists, or if the data banks size limit of 1000 entries is "
"exceeded.  In addition, this should create and return a unique ID for the "
"new user entry."
msgstr ""
"实现函数 `addUser`。如果具有给定 `Email` 的用户已经存在，或者超过了 1000 个条"
"目的数据库大小限制，这应该会失败。此外，这应该为新用户条目创建并返回一个唯一 "
"ID。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1356
#, no-wrap
msgid ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Functor.md:1361
msgid ""
"Implement function `updateUser`. This should fail, if the user in question "
"cannot be found or a user with the updated user's `Email` already exists.  "
"The returned value should be the updated user."
msgstr ""
"实现函数 `updateUser`。如果找不到相关用户或更新用户的 `Email` 的用户已经存"
"在，这应该会失败。返回的值应该是更新的用户。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1365
#, no-wrap
msgid ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   8. '
#: ../src/Tutorial/Functor.md:1369
msgid ""
"Data type `Prog` is actually too specific. We could just as well abstract "
"over the error type and the `DB` environment:"
msgstr "数据类型 `Prog` 实际上太具体了。我们也可以抽象出错误类型和 `DB` 环境："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1375
#, no-wrap
msgid ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1381
#, no-wrap
msgid ""
"      Verify, that all interface implementations you wrote\n"
"      for `Prog` can be used verbatim to implement the same\n"
"      interfaces for `Prog' env err`. The same goes for\n"
"      `throw` with only a slight adjustment in the function's\n"
"      type.\n"
msgstr ""
"      验证您编写的所有接口实现\n"
"      对于 `Prog` 可以逐字使用来实现相同的\n"
"      `Prog' env err` 的接口。这同样适用于\n"
"      `throw` 只需稍微调整函数的\n"
"      类型。\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:1382
#, no-wrap
msgid "Background and further Reading"
msgstr "背景和延伸阅读"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1391
msgid ""
"Concepts like *functor* and *monad* have their origin in *category theory*, "
"a branch of mathematics. That is also where their laws come from.  Category "
"theory was found to have applications in programming language theory, "
"especially functional programming.  It is a highly abstract topic, but there "
"is a pretty accessible introduction for programmers, written by [Bartosz "
"Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-"
"programmers-the-preface/)."
msgstr ""
"*functor* 和 *monad* 等概念起源于数学分支 *范畴论*。这也是他们的定律的来源。"
"范畴理论被发现在程序设计语言理论，特别是函数式程序设计中有应用。这是一个高度"
"抽象的主题，但有一个非常容易理解的程序员介绍，由 [Bartosz Milewski](https://"
"bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) "
"编写。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1397
msgid ""
"The usefulness of applicative functors as a middle ground between functor "
"and monad was discovered several years after monads had already been in use "
"in Haskell. They were introduced in the article [*Applicative Programming "
"with Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html), "
"which is freely available online and a highly recommended read."
msgstr ""
"应用函子作为函子和单子之间的中间地带的有用性是在单子已经在 Haskell 中使用几年"
"之后才发现的。它们在文章 [*Applicative Programming with Effects*](https://"
"www.staff.city.ac.uk/~ross/papers/Applicative.html) 中进行了介绍，该文章可在"
"线免费获得，并且强烈推荐阅读。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1404
msgid ""
"Interfaces `Functor`, `Applicative`, and `Monad` abstract over programming "
"patterns that come up when working with type constructors of type `Type -> "
"Type`. Such data types are also referred to as *values in a context*, or "
"*effectful computations*."
msgstr ""
"接口 `Functor`、`Applicative` 和 `Monad` 抽象了使用 `Type -> Type` 类型的类型"
"构造函数时出现的编程模式。此类数据类型也称为上下文中的 *值*，或 *副作用计算"
"*。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1407
msgid ""
"`Functor` allows us to *map* over values in a context without affecting the "
"context's underlying structure."
msgstr "`Functor` 允许我们在上下文中的值上*映射*而不影响上下文的底层结构。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1410
msgid ""
"`Applicative` allows us to apply n-ary functions to n effectful computations "
"and to lift pure values into a context."
msgstr ""
"`Applicative` 允许我们将 n 元函数应用于 n 个有效计算，并将纯值提升到上下文"
"中。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1414
msgid ""
"`Monad` allows us to chain effectful computations, where the intermediary "
"results can affect, which computation to run further down the chain."
msgstr ""
"`Monad` 允许我们链接有效的计算，其中中间结果可能会影响，哪些计算在链中运行得"
"更远。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1418
msgid ""
"Unlike `Monad`, `Functor` and `Applicative` compose: The product and "
"composition of two functors or applicatives are again functors or "
"applicatives, respectively."
msgstr ""
"与 `Monad` 不同，`Functor` 和 `Applicative` 组合：两个函子或应用程序的乘积和"
"组合再次分别是函子或应用程序。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1422
msgid ""
"Idris provides syntactic sugar for working with some of the interfaces "
"presented here: Idiom brackets for `Applicative`, *do blocks* and the bang "
"operator for `Monad`."
msgstr ""
"Idris 为使用此处介绍的一些接口提供了语法糖：`Applicative` 的习语括号、*do 块"
"* 和 `Monad` 的感叹号运算符。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1423 ../src/Tutorial/Intro.md:444
#, no-wrap
msgid "What's next?"
msgstr "接下来做什么？"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1428
msgid ""
"In the [next chapter](Folds.md) we get to learn more about recursion, "
"totality checking, and an interface for collapsing container types: "
"`Foldable`."
msgstr ""
"在[下一章](Folds.md) 中，我们将了解更多关于递归、完全性检查和折叠容器类型的接"
"口：`Foldable`。"
