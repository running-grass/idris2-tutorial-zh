# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 20:00+0800\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "练习第 1 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "练习第 2 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "练习第 3 部分"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:645
msgid "And at the REPL:"
msgstr "在 REPL 里试一下："

#. type: Title #
#: ../src/Tutorial/Prim.md:1
#, no-wrap
msgid "Primitives"
msgstr "原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:7
msgid ""
"In the topics we covered so far, we hardly ever talked about primitive types "
"in Idris. They were around and we used them in some computations, but I "
"never really explained how they work and where they come from, nor did I "
"show in detail what we can and can't do with them."
msgstr ""
"到目前为止，在我们讨论的主题中，我们几乎从未讨论过 Idris 中的原始类型。它们在"
"哪里，我们在一些计算中使用它们，但我从来没有真正解释过它们是如何工作的以及它"
"们来自哪里，我也没有详细说明我们可以用它们做什么和不能做什么。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:8
#, no-wrap
msgid ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Prim.md:17
#, no-wrap
msgid "How Primitives are Implemented"
msgstr "原语是如何实现的"

#. type: Title ###
#: ../src/Tutorial/Prim.md:19
#, no-wrap
msgid "A Short Note on Backends"
msgstr "关于后端的简短说明"

#. type: Plain text
#: ../src/Tutorial/Prim.md:30
msgid ""
"According to [Wikipedia](https://en.wikipedia.org/wiki/Compiler), a compiler "
"is \"a computer program that translates computer code written in one "
"programming language (the source language) into another language (the target "
"language)\". The Idris compiler is exactly that: A program translating "
"programs written in Idris into programs written in Chez Scheme. This scheme "
"code is then parsed and interpreted by a Chez Scheme interpreter, which must "
"be installed on the computers we use to run compiled Idris programs."
msgstr ""
"根据 [Wikipedia](https://en.wikipedia.org/wiki/Compiler)，编译器是“一种计算机"
"程序，它将以一种编程语言（源语言）编写的计算机代码翻译成另一种语言（目标语"
"言） ”。 Idris 编译器就是这样：一个将 Idris 编写的程序翻译成 Chez Scheme 编写"
"的程序的程序。然后这个 Scheme 代码由 Chez Scheme 解释器解析和解释，它必须安装"
"在我们用来运行已编译 Idris 程序的计算机上。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:37
msgid ""
"But that's only part of the story. Idris 2 was from the beginning designed "
"to support different code generators (so called *backends*), which allows us "
"to write Idris code to target different platforms, and your Idris "
"installation comes with several additional backends available. You can "
"specify the backend to use with the `--cg` command line argument (`cg` "
"stands for *code generator*). For instance:"
msgstr ""
"但这只是故事的一部分。 Idris 2 从一开始就设计为支持不同的代码生成器（所谓的 *"
"后端*），这允许我们编写 Idris 代码以针对不同的平台，并且您的 Idris 安装附带了"
"几个可用的附加后端。您可以指定要与 `--cg` 命令行参数一起使用的后端（`cg` 代"
"表 *代码生成器*）。例如："

#. type: Fenced code block (sh)
#: ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "idris2 --cg racket\n"
msgstr "idris2 --cg racket\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:45
msgid ""
"Here is a non-comprehensive list of the backends available with a standard "
"Idris installation (the name to be used in the command line argument is "
"given in parentheses):"
msgstr ""
"以下是标准 Idris 安装可用的后端的非全面列表（在括号中给出命令行参数中使用的名"
"称）："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Racket Scheme (`racket`): This is a different flavour of the scheme "
"programming language, which can be useful to use when Chez Scheme is not "
"available on your operating system."
msgstr ""
"Racket Scheme (`racket`)：这是 Scheme 编程语言的另一种方言，当 Chez Scheme 在"
"您的操作系统上不可用时，它很有用。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid "Node.js (`node`): This converts an Idris program to JavaScript."
msgstr "Node.js (`node`)：这会将 Idris 程序转换为 JavaScript。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Browser (`javascript`): Another JavaScript backend which allows you to write "
"web applications which run in the browser in Idris."
msgstr ""
"浏览器 (`javascript`)：另一个 JavaScript 后端，允许您编写在 Idris 的浏览器中"
"运行的 Web 应用程序。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"RefC (`refc`): A backend compiling Idris to C code, which is then further "
"compiled by a C compiler."
msgstr "RefC (`refc`)：后端将 Idris 编译为 C 代码，然后由 C 编译器进一步编译。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:57
msgid ""
"I plan to at least cover the JavaScript backends in some more detail in "
"another part of this Idris guide, as I use them pretty often myself."
msgstr ""
"我计划至少在本 Idris 指南的另一部分中更详细地介绍 JavaScript 后端，因为我自己"
"也经常使用它们。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:62
msgid ""
"There are also several external backends not officially supported by the "
"Idris project, amongst which are backends for compiling Idris code to Java "
"and Python. You can find a list of external backends on the [Idris Wiki]"
"(https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-"
"backends)."
msgstr ""
"Idris 项目还没有正式支持几个外部后端，其中包括将 Idris 代码编译为 Java 和 "
"Python 的后端。您可以在 [Idris Wiki](https://github.com/idris-lang/Idris2/"
"wiki/1-%5BLanguage%5D-External-backends) 上找到外部后端列表。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:63
#, no-wrap
msgid "The Idris Primitives"
msgstr "Idris 原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:69
msgid ""
"A *primitive data type* is a type that is built into the Idris compiler "
"together with a set of *primitive functions*, which are used to perform "
"calculations on the primitives. You will therefore not find a definition of "
"a primitive type or function in the source code of the *Prelude*."
msgstr ""
"*原语数据类型* 是与一组 *原语函数* 一起内置到 Idris 编译器中的类型，这些函数"
"用于对原始数据执行计算。因此，您不会在 *Prelude* 的源代码中找到原语类型或函数"
"的定义。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:71
msgid "Here is again the list of primitive types in Idris:"
msgstr "这是 Idris 中的原语类型列表："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "Signed, fixed precision integers:"
msgstr "有符号、固定精度的整数："

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Int8`: Integer in the range [-128,127]"
msgstr "`Int8`：[-128,127] 范围内的整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Int16`: Integer in the range [-32768,32767]"
msgstr "`Int16`：[-32768,32767] 范围内的整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Int32`: Integer in the range [-2147483648,2147483647]"
msgstr "`Int32`：[-2147483648,2147483647] 范围内的整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid ""
"`Int64`: Integer in the range [-9223372036854775808,9223372036854775807]"
msgstr "`Int64`：[-9223372036854775808,9223372036854775807] 范围内的整数"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "Unsigned, fixed precision integers:"
msgstr "无符号整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits8`: Integer in the range [0,255]"
msgstr "`Bits8`：[0,255] 范围内的整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits16`: Integer in the range [0,65535]"
msgstr "`Bits16`：[0,65535] 范围内的整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits32`: Integer in the range [0,4294967295]"
msgstr "`Bits32`：[0,4294967295] 范围内的整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits64`: Integer in the range [0,18446744073709551615]"
msgstr "`Bits64`：[0,18446744073709551615] 范围内的整数"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`Integer`: A signed, arbitrary precision integer."
msgstr "`Integer`：带符号的任意精度整数。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`Double`: A double precision (64 bit) floating point number."
msgstr "`Double`：双精度（64 位）浮点数。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`Char`: A unicode character."
msgstr "`Char`：Unicode 字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`String`: A sequence of unicode characters."
msgstr "`String`：Unicode 字符序列。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid ""
"`%World`: A symbolic representation of the current world state.  We learned "
"about this when I showed you how `IO` is implemented.  Most of the time, you "
"will not handle values of this type in your own code."
msgstr ""
"`%World`：当前世界状态的符号表示。\n"
"当我向您展示如何实现 `IO` 时，我们了解了这一点。\n"
"大多数时候，您不会在自己的代码中处理这种类型的值。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid ""
"* `Int`: This one is special. It is a fixed precision, signed integer,\n"
"   but the bit size is somewhat dependent on the backend and\n"
"   (maybe) platform we use.\n"
"   For instance, if you use the default Chez Scheme backend, `Int` is\n"
"   a 64 bit signed integer, while on the JavaScript backends it is a\n"
"   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
"   with very few guarantees, and you should use one of the well\n"
"   specified integer types listed above whenever possible.\n"
msgstr ""
"* `Int`：这个比较特殊。它是一个固定精度的有符号整数，\n"
"   但位大小在某种程度上取决于后端和\n"
"   （也许）我们使用的平台。\n"
"   例如，如果您使用默认的 Chez Scheme 后端，则 `Int` 是\n"
"   一个 64 位有符号整数，而在 JavaScript 后端它是一个\n"
"   出于性能原因，32 位有符号整数。所以，`Int` 带有很少的保证，\n"
"   你应该尽可能使用上面列出的整数类型的其中一个。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:104
msgid ""
"It can be instructive to learn, where in the compiler's source code the "
"primitive types and functions are defined. This source code can be found in "
"folder `src` of the [Idris project](https://github.com/idris-lang/Idris2)  "
"and the primitive types are the constant constructors of data type `Core.TT."
"Constant`."
msgstr ""
"学习在编译器源代码中定义原语类型和函数的位置可能具有指导意义。此源代码可以在 "
"[Idris 项目](https://github.com/idris-lang/Idris2) 的文件夹 `src` 中找到，原"
"语类型是数据类型 `Core.TT.Constant` 的常量构造函数。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:105
#, no-wrap
msgid "Primitive Functions"
msgstr "原语函数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:112
msgid ""
"All calculations operating on primitives are based on two kinds of primitive "
"functions: The ones built into the compiler (see below) and the ones defined "
"by programmers via the foreign function interface (FFI), about which I'll "
"talk in another chapter."
msgstr ""
"所有对原语进行的计算都基于两种原语函数：编译器内置的（见下文）和程序员通过外"
"部函数接口（FFI）定义的函数，我将在另一章中讨论。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:119
msgid ""
"Built-in primitive functions are functions known to the compiler the "
"definition of which can not be found in the *Prelude*. They define the core "
"functionality available for the primitive types. Typically, you do not "
"invoke these directly (although it is perfectly fine to do so in most cases) "
"but via functions and interfaces exported by the *Prelude* or the *base* "
"library."
msgstr ""
"内置原语函数是编译器已知的函数，其定义在 *Prelude* 中找不到。它们定义了可用于"
"原语类型的核心函数。通常，您不会直接调用它们（尽管在大多数情况下这样做非常"
"好），而是通过 *Prelude* 或 *base* 库导出的函数和接口。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:123
msgid ""
"For instance, the primitive function for adding two eight bit unsigned "
"integers is `prim__add_Bits8`. You can inspect its type and behavior at the "
"REPL:"
msgstr ""
"例如，将两个八位无符号整数相加的原语函数是 `prim__add_Bits8`。您可以在 REPL "
"中检查其类型和行为："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:124
#, no-wrap
msgid ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"
msgstr ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:148
msgid ""
"If you look at the source code implementing interface `Num` for `Bits8`, you "
"will see that the plus operator just invokes `prim__add_Bits8` internally. "
"The same goes for most of the other functions in primitive interface "
"implementations.  For instance, every primitive type with the exception of "
"`%World` comes with primitive comparison functions.  For `Bits8`, these are: "
"`prim__eq_Bits8`, `prim__gt_Bits8`, `prim__lt_Bits8`, `prim__gte_Bits8`, and "
"`prim__lte_Bits8`.  Note, that these functions do not return a `Bool` (which "
"is *not* a primitive type in Idris), but an `Int`. They are therefore not as "
"safe or convenient to use as the corresponding operator implementations from "
"interfaces `Eq` and `Comp`.  On the other hand, they do not go via a "
"conversion to `Bool` and might therefore perform slightly better in "
"performance critical code (which you can only identify after some serious "
"profiling)."
msgstr ""
"如果查看 `Bits8` 的实现接口 `Num` 的源代码，您会看到加号运算符只是在内部调用 "
"`prim__add_Bits8`。原语接口实现中的大多数其他函数也是如此。例如，除了 "
"`%World` 之外的每个原语类型都带有原语比较函数。对于 `Bits8`，它们是："
"`prim__eq_Bits8`、`prim__gt_Bits8`、`prim__lt_Bits8`、`prim__gte_Bits8` 和 "
"`prim__lte_Bits8`。请注意，这些函数不返回 `Bool`（在 Idris 中 *不是* 原语类"
"型），而是 `Int`。因此，它们不像接口 `Eq` 和 `Comp` 中的相应运算符实现那样安"
"全或方便。另一方面，它们不会通过转换为 `Bool` 并且因此在性能关键代码中的性能"
"可能会稍好一些（您只能在经过一些认真的分析后才能识别）。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:152
msgid ""
"As with primitive types, the primitive functions are listed as constructors "
"in a data type (`Core.TT.PrimFn`) in the compiler sources. We will look at "
"most of these in the following sections."
msgstr ""
"与原语类型一样，原语函数在编译器源代码中被列为数据类型 (`Core.TT.PrimFn`) 中"
"的构造函数。我们将在以下部分中介绍其中的大部分内容。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:153
#, no-wrap
msgid "Consequences of being Primitive"
msgstr "原语的重要性"

#. type: Plain text
#: ../src/Tutorial/Prim.md:163
msgid ""
"Primitive functions and types are opaque to the compiler in most regards: "
"They have to be defined and implemented by each backend individually, "
"therefore, the compiler knows nothing about the inner structure of a "
"primitive value nor about the inner workings of primitive functions. For "
"instance, in the following recursive function, *we* know that the argument "
"in the recursive call must be converging towards the base case (unless there "
"is a bug in the backend we use), but the compiler does not:"
msgstr ""
"在大多数情况下，原语函数和类型对编译器是不透明的：它们必须由每个后端单独定义"
"和实现，因此，编译器对原语值的内部结构和原语函数的内部工作一无所知。例如，在"
"下面的递归函数中，*我们* 知道递归调用中的参数必须收敛到基本情况（除非我们使用"
"的后端存在错误），但编译器不知道："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:164
#, no-wrap
msgid ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"
msgstr ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:174
msgid ""
"In these cases, we either must be content with just a *covering* function, "
"or we use `assert_smaller` to convince the totality checker (the preferred "
"way):"
msgstr ""
"在这些情况下，我们要么只满足于 *covering* 函数，要么使用 `assert_smaller` 来"
"说服整体检查器（首选方式）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:175
#, no-wrap
msgid ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"
msgstr ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:184
msgid ""
"I have shown you the risks of using `assert_smaller` before, so we must be "
"extra careful in making sure that the new function argument is indeed "
"smaller with relation to the base case."
msgstr ""
"我之前已经向您展示了使用 `assert_smaller` 的风险，因此我们必须格外小心，以确"
"保新函数参数相对于基本情况确实更小。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:189
msgid ""
"While Idris knows nothing about the internal workings of primitives and "
"related functions, most of these functions still reduce during evaluation "
"when fed with values known at compile time. For instance, we can trivially "
"proof that for `Bits8` the following equation holds:"
msgstr ""
"虽然 Idris 对原语和相关函数的内部工作原理一无所知，但当输入编译时已知的值时，"
"这些函数中的大多数在求值期间仍然会减少。例如，我们可以简单地证明对于 "
"`Bits8`，以下等式成立："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:190
#, no-wrap
msgid ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"
msgstr ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:200
msgid ""
"Having no clue about the internal structure of a primitive nor about the "
"implementations of primitive functions, Idris can't help us proofing any "
"*general* properties of such functions and values. Here is an example to "
"demonstrate this. Assume we'd like to wrap a list in a data type indexed by "
"the list's length:"
msgstr ""
"由于不了解原语的内部结构或原语函数的实现，Idris 无法帮助我们证明此类函数和值"
"的任何 *泛型* 属性。这是一个例子来证明这一点。假设我们想将一个列表包装在一个"
"由列表长度索引的数据类型中："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:201
#, no-wrap
msgid ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
msgstr ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:209
msgid ""
"When we concatenate two `LenList`s, the length indices should be added. "
"That's how list concatenation affects the length of lists. We can safely "
"teach Idris that this is true:"
msgstr ""
"当我们连接两个 `LenList` 时，应该累加长度索引。这就是列表连接影响列表长度的方"
"式。我们可以安全地告诉伊德里斯这是真的："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:210
#, no-wrap
msgid ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
msgstr ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:217
msgid "With the above lemma, we can implement concatenation of `LenList`:"
msgstr "通过上述引理，我们可以实现 `LenList` 的串联："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:218
#, no-wrap
msgid ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"
msgstr ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:231
msgid ""
"The same is not possible for strings. There are applications where pairing a "
"string with its length would be useful (for instance, if we wanted to make "
"sure that strings are getting strictly shorter during parsing and will "
"therefore eventually be wholly consumed), but Idris cannot help us getting "
"these things right.  There is no way to implement and thus proof the "
"following lemma in a safe way:"
msgstr ""
"字符串也是不可能的。在某些应用程序中，将字符串与其长度配对会很有用（例如，如"
"果我们想确保字符串在解析过程中严格缩短，因此最终会被完全消耗掉），但 Idris 无"
"法帮助我们正确处理这些事情。没有办法以安全的方式实现并证明以下引理："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:232
#, no-wrap
msgid "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"
msgstr "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "<!-- markdownlint-disable MD026 -->\n"
msgstr "<!-- markdownlint-disable MD026 -->\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "Believe Me!"
msgstr "相信我！"

#. type: Plain text
#: ../src/Tutorial/Prim.md:239
#, no-wrap
msgid "<!-- markdownlint-enable MD026 -->\n"
msgstr "<!-- markdownlint-enable MD026 -->\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:245
msgid ""
"In order to implement `concatLenStr`, we have to abandon all safety and use "
"the ten ton wrecking ball of type coercion: `believe_me`. This primitive "
"function allows us to freely coerce a value of any type into a value of any "
"other type.  Needless to say, this is only safe if we *really* know what we "
"are doing:"
msgstr ""
"为了实现 `concatLenStr`，我们必须放弃所有安全，使用强制类型的十吨破坏球："
"`believe_me`。这个原语函数允许我们自由地将任何类型的值强制转换为任何其他类型"
"的值。不用说，只有当我们 *真的* 知道我们在做什么时，这才是安全的："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:246
#, no-wrap
msgid "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"
msgstr "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:257
msgid ""
"The explicit assignment of variable `x` in `{x = length a + length b}` is "
"necessary, because otherwise Idris will complain about an *unsolved hole*: "
"It can't infer the type of parameter `x` in the `Refl` constructor. We could "
"assign any type to `x` here, because we are passing the result to "
"`believe_me` anyway, but I consider it to be good practice to assign one of "
"the two sides of the equality to make our intention clear."
msgstr ""
"在 `x = length a + length b}` 中显式分配变量 `x` 是必要的，否则 Idris 会抱怨 "
"*未解决的孔*：它可以在 `Refl` 构造函数中推断参数 `x` 的类型。我们可以在这里"
"为 `x` 分配任何类型，因为无论如何我们都将结果传递给 `believe_me`，但我认为将"
"等式的两侧之一分配给明确我们的意图。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:262
msgid ""
"The higher the complexity of a primitive type, the riskier it is to assume "
"even the most basic properties for it to hold.  For instance, we might act "
"under the delusion that floating point addition is associative:"
msgstr ""
"原始类型的复杂性越高，假设它拥有最基本的属性的风险就越大。例如，我们可能会误"
"以为浮点加法具有结合性："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:263
#, no-wrap
msgid ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"
msgstr ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:270
msgid ""
"Well, guess what: That's a lie. And lies lead us straight into the `Void`:"
msgstr "好吧，你猜怎么着：那是个谎言。谎言将我们直接带入 `Void`："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:271
#, no-wrap
msgid ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"
msgstr ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:291
msgid ""
"Here's what happens in the code above: The call to `doubleAddAssoc` returns "
"a proof that `One + (Tiny + Tiny)` is equal to `(One + Tiny) + Tiny`. But "
"`One + (Tiny + Tiny)` equals `1.0000000000000002`, while `(One + Tiny) + "
"Tiny` equals `1.0`.  We can therefore pass our (wrong) proof to `wrong`, "
"because it is of the correct type, and from this follows a proof of `Void`."
msgstr ""
"下面是上面代码中发生的情况：对 `doubleAddAssoc` 的调用返回一个证明 `One + "
"(Tiny + Tiny)` 等于 `(One + Tiny) + Tiny`。但是 `One + (Tiny + Tiny)` 等于 "
"`1.0000000000000002`，而 `(One + Tiny) + Tiny` 等于 `1.0`。因此，我们可以将我"
"们的（错误的）证明传递给 `wrong`，因为它是正确的类型，并由此得出 `Void` 的证"
"明。"

#. type: Title ##
#: ../src/Tutorial/Prim.md:292
#, no-wrap
msgid "Working with Strings"
msgstr "使用字符串"

#. type: Plain text
#: ../src/Tutorial/Prim.md:297
msgid ""
"Module `Data.String` in *base* offers a rich set of functions for working "
"with strings. All these are based on the following primitive operations "
"built into the compiler:"
msgstr ""
"*base* 中的模块 `Data.String` 提供了一组丰富的函数来处理字符串。所有这些都基"
"于编译器内置的以下原语操作："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strLength`: Returns the length of a string."
msgstr "`prim__strLength`：返回字符串的长度。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strHead`: Extracts the first character from a string."
msgstr "`prim__strHead`：从字符串中提取第一个字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strTail`: Removes the first character from a string."
msgstr "`prim__strTail`：从字符串中删除第一个字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strCons`: Prepends a character to a string."
msgstr "`prim__strCons`：在字符串前面添加一个字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strAppend`: Appends two strings."
msgstr "`prim__strAppend`：追加两个字符串。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid ""
"`prim__strIndex`: Extracts a character at the given position from a string."
msgstr "`prim__strIndex`：从字符串中提取给定位置的字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strSubstr`: Extracts the substring between the given positions."
msgstr "`prim__strSubstr`：提取给定位置之间的子字符串。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:311
msgid ""
"Needless to say, not all of these functions are total. Therefore, Idris must "
"make sure that invalid calls do not reduce during compile time, as otherwise "
"the compiler would crash. If, however we force the evaluation of a partial "
"primitive function by compiling and running the corresponding program, this "
"program will crash with an error:"
msgstr ""
"不用说，并非所有这些功能都是完整的。因此，Idris 必须确保在编译期间不会减少无"
"效调用，否则编译器会崩溃。但是，如果我们通过编译和运行相应的程序来强制对部分"
"原语函数求值，则该程序将崩溃并出现错误："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:312
#, no-wrap
msgid ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"
msgstr ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:323
msgid ""
"Note, how `prim__strTail \"\"` is not reduced at the REPL and how the same "
"expression leads to a runtime exception if we compile and execute the "
"program. Valid calls to `prim__strTail` are reduced just fine, however:"
msgstr ""
"请注意，`prim__strTail \"\"` 在 REPL 中没有减少，以及如果我们编译和执行程序，"
"相同的表达式如何导致运行时异常。对 `prim__strTail` 的有效调用减少得很好，但"
"是："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:324
#, no-wrap
msgid ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"
msgstr ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:329
#, no-wrap
msgid "Pack and Unpack"
msgstr "打包和解包"

#. type: Plain text
#: ../src/Tutorial/Prim.md:339
msgid ""
"Two of the most important functions for working with strings are `unpack` "
"and `pack`, which convert a string to a list of characters and vice versa. "
"This allows us to conveniently implement many string operations by iterating "
"or folding over the list of characters instead. This might not always be the "
"most efficient thing to do, but unless you plan to handle very large amounts "
"of text, they work and perform reasonably well."
msgstr ""
"处理字符串的两个最重要的函数是 `unpack` 和 `pack`，它们将字符串转换为字符列"
"表，以及反过来。这允许我们通过迭代或折叠字符列表来方便地实现许多字符串操作。"
"这可能并不总是最有效的做法，但除非您计划处理大量文本，否则它们的工作和性能相"
"当不错。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:340
#, no-wrap
msgid "String Interpolation"
msgstr "字符串插值"

#. type: Plain text
#: ../src/Tutorial/Prim.md:345
msgid ""
"Idris allows us to include arbitrary string expressions in a string literal "
"by wrapping them in curly braces, the first of which has to be escaped with "
"a backslash. For instance:"
msgstr ""
"Idris 允许我们将任意字符串表达式包含在字符串文字中，方法是将它们包裹在花括号"
"中，第一个必须用反斜杠转义。例如："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:346
#, no-wrap
msgid ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"
msgstr ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:356
msgid ""
"This is a very convenient way to assemble complex strings from values of "
"different types.  In addition, there is interface `Interpolation`, which "
"allows us to use values in interpolated strings without having to convert "
"them to strings first:"
msgstr ""
"这是从不同类型的值组装复杂字符串的一种非常方便的方法。此外，还有接口"
"`Interpolation`，它允许我们在插值字符串中使用值，而不必先将它们转换为字符串："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:357
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"
msgstr ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:384
#, no-wrap
msgid "Raw and Multiline String Literals"
msgstr "原始和多行字符串字面量"

#. type: Plain text
#: ../src/Tutorial/Prim.md:388
msgid ""
"In string literals, we have to escape certain characters like quotes, "
"backslashes or new line characters. For instance:"
msgstr "在字符串文字中，我们必须转义某些字符，如引号、反斜杠或换行符。例如："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:389
#, no-wrap
msgid ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: \\\\\"\n"
msgstr ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: \\\\\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:398
msgid ""
"Idris allows us to enter raw string literals, where there is no need to "
"escape quotes and backslashes, by pre- and postfixing the wrapping quote "
"characters with the same number of hash characters. For instance:"
msgstr ""
"Idris 允许我们输入原始字符串文字，无需转义引号和反斜杠，方法是在引号前后使用"
"相同数量的井号进行包裹。例如："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:399
#, no-wrap
msgid ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"
msgstr ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:411
msgid ""
"With raw string literals, it is still possible to use string interpolation, "
"but the opening curly brace has to be prefixed with a backslash and the same "
"number of hashes as are being used for opening and closing the string "
"literal:"
msgstr ""
"对于原始字符串字面量，仍然可以使用字符串插值，但开始的花括号必须以反斜杠为前"
"缀，并且加上和用于打开关闭字符串字面量的相同数据的井号："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:412
#, no-wrap
msgid ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"
msgstr ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:424
msgid ""
"Finally, Idris also allows us to conveniently write multiline strings. These "
"can be pre- and postfixed with hashes if we want raw multiline string "
"literals, and they also can be combined with string interpolation. Multiline "
"literals are opened and closed with triple quote characters. Indenting the "
"closing triple quotes allows us to indent the whole multiline literal. "
"Whitespace used for indentation will not appear in the resulting string. For "
"instance:"
msgstr ""
"最后，Idris 还允许我们方便地编写多行字符串。如果我们想要原始的多行字符串字面"
"量，这些可以用井号前缀和后缀，它们也可以与字符串插值结合使用。多行文字用三引"
"号字符打开和关闭。缩进结束的三引号允许我们缩进整个多行文字。用于缩进的空格不"
"会出现在结果字符串中。例如："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:425
#, no-wrap
msgid ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"
msgstr ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:447
msgid ""
"Make sure to look at the example strings at the REPL to see the effect of "
"interpolation and raw string literals and compare it with the syntax we used."
msgstr ""
"请务必查看 REPL 中的示例字符串，以了解插值和原始字符串文字的效果，并将其与我"
"们使用的语法进行比较。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:454
msgid ""
"In these exercises, you are supposed to implement a bunch of utility "
"functions for consuming and converting strings.  I don't give the expected "
"types here, because you are supposed to come up with those yourself."
msgstr ""
"在这些练习中，你应该实现一堆用于消费和转换字符串的实用函数。我在这里没有给出"
"预期的类型，因为你应该自己想出那些。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:458
msgid ""
"Implement functions similar to `map`, `filter`, and `mapMaybe` for strings. "
"The output type of these should always be a string."
msgstr ""
"为字符串实现类似于 `map`、`filter` 和 `mapMaybe` 的函数。这些的输出类型应该始"
"终是一个字符串。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:461
msgid "Implement functions similar to `foldl` and `foldMap` for strings."
msgstr "为字符串实现类似于 `foldl` 和 `foldMap` 的函数。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:464
msgid ""
"Implement a function similar to `traverse` for strings. The output type "
"should be a wrapped string."
msgstr "为字符串实现类似于 `traverse` 的函数。输出类型应该是一个包装的字符串。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:467
msgid ""
"Implement the bind operator for strings. The output type should again be a "
"string."
msgstr "为字符串实现绑定运算符。输出类型应该再次是字符串。"

#. type: Title ##
#: ../src/Tutorial/Prim.md:468
#, no-wrap
msgid "Integers"
msgstr "整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:475
msgid ""
"As listed at the beginning of this chapter, Idris provides different fixed-"
"precision signed and unsigned integer types as well as `Integer`, an "
"arbitrary precision signed integer type.  All of them come with the "
"following primitive functions (given here for `Bits8` as an example):"
msgstr ""
"正如本章开头所列出的，Idris 提供了不同的固定精度有符号和无符号整数类型以及 "
"`Integer`，一种任意精度的有符号整数类型。它们都带有以下原语函数（此处以 "
"`Bits8` 为例）："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__add_Bits8`: Integer addition."
msgstr "`prim__add_Bits8`：整数加法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__sub_Bits8`: Integer subtraction."
msgstr "`prim__sub_Bits8`：整数减法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mul_Bits8`: Integer multiplication."
msgstr "`prim__mul_Bits8`：整数乘法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__div_Bits8`: Integer division."
msgstr "`prim__div_Bits8`：整数除法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mod_Bits8`: Modulo function."
msgstr "`prim__mod_Bits8`：模函数。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shl_Bits8`: Bitwise left shift."
msgstr "`prim__shl_Bits8`：按位左移。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shr_Bits8`: Bitwise right shift."
msgstr "`prim__shr_Bits8`：按位右移。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__and_Bits8`: Bitwise *and*."
msgstr "`prim__and_Bits8`：按位*与*。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__or_Bits8`: Bitwise *or*."
msgstr "`prim__or_Bits8`：按位*或*。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__xor_Bits8`: Bitwise *xor*."
msgstr "`prim__xor_Bits8`：按位*异或*。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:493
msgid ""
"Typically, you use the functions for addition and multiplication through the "
"operators from interface `Num`, the function for subtraction through "
"interface `Neg`, and the functions for division (`div` and `mod`) through "
"interface `Integral`.  The bitwise operations are available through "
"interfaces `Data.Bits.Bits` and `Data.Bits.FiniteBits`."
msgstr ""
"通常，您可以通过接口 `Num` 中的运算符使用加法和乘法函数，通过接口 `Neg` 使用"
"减法函数，以及除法函数 (`div`和 `mod`) 通过接口 `Integral`。位运算可通过接口 "
"`Data.Bits.Bits` 和 `Data.Bits.FiniteBits` 获得。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:497
msgid ""
"For all integral types, the following laws are assumed to hold for numeric "
"operations (`x`, `y`, and `z` are arbitrary value of the same primitive "
"integral type):"
msgstr ""
"对于所有整数类型，假设以下定律适用于数值运算（`x`、`y` 和 `z` 是相同原始整数"
"类型的任意值） ："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + y = y + x`: Addition is commutative."
msgstr "`x + y = y + x`：加法是可交换的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + (y + z) = (x + y) + z`: Addition is associative."
msgstr "`x + (y + z) = (x + y) + z`：加法是结合的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + 0 = x`: Zero is the neutral element of addition."
msgstr "`x + 0 = x`：零是加法的中性元素。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x - x = x + (-x) = 0`: `-x` is the additive inverse of `x`."
msgstr "`x - x = x + (-x) = 0`：`-x` 是 `x` 的加法逆。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * y = y * x`: Multiplication is commutative."
msgstr "`x * y = y * x`：乘法是可交换的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y * z) = (x * y) * z`: Multiplication is associative."
msgstr "`x * (y * z) = (x * y) * z`：乘法是结合的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * 1 = x`: One is the neutral element of multiplication."
msgstr "`x * 1 = x`：1 是乘法的中性元素。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y + z) = x * y + x * z`: The distributive law holds."
msgstr "`x * (y + z) = x * y + x * z`：分配律成立。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "``y * (x `div` y) + (x `mod` y) = x`` (for `y /= 0`)."
msgstr "``y * (x `div` y) + (x `mod` y) = x``（对于 `y /= 0`）。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:515
msgid ""
"Please note, that the officially supported backends use *Euclidian modulus* "
"for calculating `mod`: For `y /= 0`, ``x `mod` y`` is always a non-negative "
"value strictly smaller than `abs y`, so that the law given above does hold. "
"If `x` or `y` are negative numbers, this is different to what many other "
"languages do but for good reasons as explained in the following [article]"
"(https://www.microsoft.com/en-us/research/publication/division-and-modulus-"
"for-computer-scientists/)."
msgstr ""
"请注意，官方支持的后端使用 *欧几里得模数* 来计算 `mod`： For `y /= 0`, ``x "
"`mod` y``始终是严格小于 `abs y` 的非负值，因此上面给出的定律确实成立。如果 "
"`x` 或 `y` 是负数，这与许多其他语言所做的不同，但出于以下 [文章](https://www."
"microsoft.com/en-us/research/publication/division-and-modulus-for-computer-"
"scientists/) 。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:516
#, no-wrap
msgid "Unsigned Integers"
msgstr "无符号整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:526
msgid ""
"The unsigned fixed precision integer types (`Bits8`, `Bits16`, `Bits32`, and "
"`Bits64`) come with implementations of all integral interfaces (`Num`, "
"`Neg`, and `Integral`) and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  All functions with the exception of `div` and `mod` are "
"total. Overflows are handled by calculating the remainder modulo "
"`2^bitsize`. For instance, for `Bits8`, all operations calculate their "
"results modulo 256:"
msgstr ""
"无符号固定精度整数类型（`Bits8`、`Bits16`、`Bits32` 和 `Bits64`）带有所有整数"
"接口的实现（`Num`、`Neg` 和 `Integral`）以及用于按位运算的两个接口（`Bits` "
"和 `FiniteBits`）。除了 `div` 和 `mod` 之外的所有函数都是总计的。通过计算余数"
"模 `2^bitsize` 来处理溢出。例如，对于 `Bits8`，所有操作都以 256 为模计算其结"
"果："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:527
#, no-wrap
msgid ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"
msgstr ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:538
#, no-wrap
msgid "Signed Integers"
msgstr "有符号整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:548
msgid ""
"Like the unsigned integer types, the signed fixed precision integer types "
"(`Int8`, `Int16`, `Int32`, and `Int64`) come with implementations of all "
"integral interfaces and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  Overflows are handled by calculating the remainder "
"modulo `2^bitsize` and subtracting `2^bitsize` if the result is still out of "
"range. For instance, for `Int8`, all operations calculate their results "
"modulo 256, subtracting 256 if the result is still out of bounds:"
msgstr ""
"与无符号整数类型一样，有符号固定精度整数类型（`Int8`、`Int16`、`Int32` 和 "
"`Int64`）具有以下实现所有整数接口和用于按位运算的两个接口（`Bits` 和 "
"`FiniteBits`）。如果结果仍然超出范围，则通过计算余数模 `2^bitsize` 并添加下限"
"（负数）来处理溢出。例如，对于 `Int8`，所有操作都以 256 为模计算结果，如果结"
"果仍然超出范围，则减去 128："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:549
#, no-wrap
msgid ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"
msgstr ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:556
#, no-wrap
msgid "Bitwise Operations"
msgstr "位运算"

#. type: Plain text
#: ../src/Tutorial/Prim.md:567
msgid ""
"Module `Data.Bits` exports interfaces for performing bitwise operations on "
"integral types. I'm going to show a couple of examples on unsigned 8-bit "
"numbers (`Bits8`) to explain the concept to readers new to bitwise "
"arithmetics. Note, that this is much easier to grasp for unsigned integer "
"types than for the signed versions.  Those have to include information about "
"the *sign* of numbers in their bit pattern, and it is assumed that signed "
"integers in Idris use a [two's complement representation](https://en."
"wikipedia.org/wiki/Two%27s_complement), about which I will not go into the "
"details here."
msgstr ""
"模块 `Data.Bits` 导出用于对整数类型执行按位运算的接口。我将展示几个关于无符"
"号 8 位数字 (`Bits8`) 的示例，以向不熟悉按位算术的读者解释这个概念。请注意，"
"对于无符号整数类型，这比有符号版本更容易掌握。那些必须在其位模式中包含有关数"
"字的 *符号* 的信息，并且假设 Idris 中的有符号整数使用 [二进制补码表示]"
"(https://en.wikipedia.org/wiki/2%27s_complement) ，这里不再赘述。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:572
msgid ""
"An unsigned 8-bit binary number is represented internally as a sequence of "
"eight bits (with values 0 or 1), each of which corresponds to a power of 2. "
"For instance, the number 23 (= 16 + 4 + 2 + 1) is represented as `0001 0111`:"
msgstr ""
"无符号 8 位二进制数在内部表示为 8 位序列（值为 0 或 1），每个位对应于 2 的"
"幂。例如，数字 23 (= 16 + 4 + 2 + 1)表示为 `0001 0111`："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:573
#, no-wrap
msgid ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"
msgstr ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:582
msgid ""
"We can use function `testBit` to check if the bit at the given position is "
"set or not:"
msgstr "我们可以使用函数 `testBit` 来检查给定位置的位是否已设置："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:583
#, no-wrap
msgid ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"
msgstr ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:594
msgid ""
"Likewise, we can use functions `setBit` and `clearBit` to set or unset a bit "
"at a certain position:"
msgstr ""
"同样，我们可以使用函数 `setBit` 和 `clearBit` 在某个位置设置或取消设置位："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:595
#, no-wrap
msgid ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"
msgstr ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:609
msgid ""
"There are also operators `(.&.)` (bitwise *and*) and `(.|.)` (bitwise *or*) "
"as well as function `xor` (bitwise *exclusive or*)  for performing boolean "
"operations on integral values.  For instance `x .&. y` has exactly those "
"bits set, which both `x` and `y` have set, while `x .|. y` has all bits set "
"that are either set in `x` or `y` (or both), and ``x `xor` y`` has those "
"bits set that are set in exactly one of the two values:"
msgstr ""
"还有运算符 `(.&.)`（按位 *与*）和 `(.|.)`（按位 *或*）以及用于对整数值执行布"
"尔运算的函数 `xor`（按位 *异或*）。例如 `x .&. y` 正好设置了那些位，`x` 和 "
"`y` 都设置了，而 `x .|. y` 设置了在 `x` 或 `y`（或两者）中设置的所有位，并且 "
"``x `xor` y`` 设置了那些位设置为以下两个值之一："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:610
#, no-wrap
msgid ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"
msgstr ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:620
msgid "And here are the examples at the REPL:"
msgstr "以下是 REPL 上的示例："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:621
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"
msgstr ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:636
msgid ""
"Finally, it is possible to shift all bits to the right or left by a certain "
"number of steps by using functions `shiftR` and `shiftL`, respectively "
"(overflowing bits will just be dropped).  A left shift can therefore be "
"viewed as a multiplication by a power of two, while a right shift can be "
"seen as a division by a power of two:"
msgstr ""
"最后，可以分别使用函数 `shiftR` 和 `shiftL` 将所有位向右或向左移动一定步数"
"（溢出的位将被丢弃）。因此，左移可以看作是乘以 2 的幂，而右移可以看作是除以 "
"2 的幂："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:637
#, no-wrap
msgid ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"
msgstr ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:646
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"
msgstr ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:656
msgid ""
"Bitwise operations are often used in specialized code or certain high-"
"performance applications. As programmers, we have to know they exist and how "
"they work."
msgstr ""
"按位运算通常用于专用代码或某些高性能应用程序中。作为程序员，我们必须知道它们"
"的存在以及它们是如何工作的。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:657
#, no-wrap
msgid "Integer Literals"
msgstr "整数字面量"

#. type: Plain text
#: ../src/Tutorial/Prim.md:665
msgid ""
"So far, we always required an implementation of `Num` in order to be able to "
"use integer literals for a given type. However, it is actually only "
"necessary to implement a function `fromInteger` converting an `Integer` to "
"the type in question. As we will see in the last section, such a function "
"can even restrict the values allowed as valid literals."
msgstr ""
"到目前为止，我们总是需要 `Num` 的实现，以便能够对给定类型使用整数文字。然而，"
"实际上只需要实现一个函数 `fromInteger` 将 `Integer` 转换为相关类型。正如我们"
"将在最后一节中看到的，这样的函数甚至可以限制允许作为有效字面量的值。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:670
msgid ""
"For instance, assume we'd like to define a data type for representing the "
"charge of a chemical molecule. Such a value can be positive or negative and "
"(theoretically) of almost arbitrary magnitude:"
msgstr ""
"例如，假设我们想定义一个数据类型来表示化学分子的电荷。这样的值可以是正值或负"
"值，并且（理论上）几乎是任意大小："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:671
#, no-wrap
msgid ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"
msgstr ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:682
msgid ""
"It makes sense to be able to sum up charges, but not to multiply them. They "
"should therefore have an implementation of `Monoid` but not of `Num`. Still, "
"we'd like to have the convenience of integer literals when using constant "
"charges at compile time. Here's how to do this:"
msgstr ""
"能够对费用求和是有意义的，但不能将它们相乘。因此，它们应该有 `Monoid` 的实"
"现，而不是 `Num` 的实现。尽管如此，我们还是希望在编译时使用常量费用时能够方便"
"地使用整数字面量。以下是如何执行此操作："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:683
#, no-wrap
msgid ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"
msgstr ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"

#. type: Title ####
#: ../src/Tutorial/Prim.md:694
#, no-wrap
msgid "Alternative Bases"
msgstr "可供选择的基础"

#. type: Plain text
#: ../src/Tutorial/Prim.md:701
msgid ""
"In addition to the well known decimal literals, it is also possible to use "
"integer literals in binary, octal, or hexadecimal representation. These have "
"to be prefixed with a zero following by a `b`, `o`, or `x` for binary, "
"octal, and hexadecimal, respectively:"
msgstr ""
"除了众所周知的十进制文字外，还可以使用二进制、八进制或十六进制表示的整数文"
"字。对于二进制、八进制和十六进制，它们必须以零为前缀，后跟 `b`、`o` 或 `x`："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:702
#, no-wrap
msgid ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"
msgstr ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:715
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.&.)`."
msgstr "定义整数值的包装记录并实现 `Monoid` 以便 `(<+>)` 对应于 `(.&.)`。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:718
#, no-wrap
msgid ""
"   Hint: Have a look at the functions available from interface\n"
"   `Bits` to find a value suitable as the neutral element.\n"
msgstr ""
"   提示：查看 `Bits` 接口中可用的函数\n"
"   找到适合作为中性元素的值。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:721
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.|.)`."
msgstr "定义整数值的包装记录并实现 `Monoid` 以便 `(<+>)` 对应于 `(.|.)`。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:724
msgid ""
"Use bitwise operations to implement a function, which tests if a given value "
"of type `Bits64` is even or not."
msgstr ""
"使用按位运算来实现一个函数，该函数测试 `Bits64` 类型的给定值是否为偶数。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:726
msgid "Convert a value of type `Bits64` to a string in binary representation."
msgstr "将 `Bits64` 类型的值转换为二进制表示的字符串。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:728
msgid ""
"Convert a value of type `Bits64` to a string in hexadecimal representation."
msgstr "将 `Bits64` 类型的值转换为十六进制表示的字符串。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:731
#, no-wrap
msgid ""
"   Hint: Use `shiftR` and `(.&. 15)` to access subsequent packages of\n"
"   four bits.\n"
msgstr "   提示：使用 `shiftR` 和 `(.&. 15)` 访问四位的后续包。\n"

#. type: Title ##
#: ../src/Tutorial/Prim.md:732
#, no-wrap
msgid "Refined Primitives"
msgstr "精炼原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:740
msgid ""
"We often do not want to allow all values of a type in a certain context. For "
"instance, `String` as an arbitrary sequence of UTF-8 characters (several of "
"which are not even printable), is too general most of the time. Therefore, "
"it is usually advisable to rule out invalid values early on, by pairing a "
"value with an erased proof of validity."
msgstr ""
"我们通常不希望在某个上下文中允许某个类型的所有值。例如，`String` 作为 UTF-8 "
"字符的任意序列（其中有几个甚至无法打印），在大多数情况下都过于笼统。因此，通"
"常建议通过将值与已擦除的有效性证明配对，尽早排除无效值。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:748
msgid ""
"We have learned how we can write elegant predicates, with which we can proof "
"our functions to be total, and from which we can - in the ideal case - "
"derive other, related predicates. However, when we define predicates on "
"primitives they are to a certain degree doomed to live in isolation, unless "
"we come up with a set of primitive axioms (implemented most likely using "
"`believe_me`), with which we can manipulate our predicates."
msgstr ""
"我们已经学会了如何编写优雅的谓词，用它我们可以证明我们的函数是完全的，并且我"
"们可以从它——在理想情况下——推导出其他相关的谓词。然而，当我们在原语上定义谓词"
"时，它们在某种程度上注定要孤立存在，除非我们提出一组原语公理（最有可能使用 "
"`believe_me` 实现），我们可以用它来操纵我们的谓词。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:749
#, no-wrap
msgid "Use Case: ASCII Strings"
msgstr "用例：ASCII 字符串"

#. type: Plain text
#: ../src/Tutorial/Prim.md:755
msgid ""
"String encodings is a difficult topic, so in many low level routines it "
"makes sense to rule out most characters from the beginning. Assume "
"therefore, we'd like to make sure the strings we accept in our application "
"only consist of ASCII characters:"
msgstr ""
"字符串编码是一个困难的话题，因此在许多低级例程中，从一开始就排除大多数字符是"
"有意义的。因此，假设我们希望确保我们在应用程序中接受的字符串仅包含 ASCII 字"
"符："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:756
#, no-wrap
msgid ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"
msgstr ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:766
msgid ""
"We can now *refine* a string value by pairing it with an erased proof of "
"validity:"
msgstr "我们现在可以 *细化* 一个字符串值，方法是将其与已擦除的有效性证明配对："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:767
#, no-wrap
msgid ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"
msgstr ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:778
msgid ""
"It is now *impossible* to at runtime or compile time create a value of type "
"`Ascii` without first validating the wrapped string. With this, it is "
"already pretty easy to safely wrap strings at compile time in a value of "
"type `Ascii`:"
msgstr ""
"现在在运行时或编译时创建 `Ascii` 类型的值，而无需首先验证包装的字符串是 *不可"
"能* 的。有了这个，在编译时将字符串安全地包装成 `Ascii` 类型的值已经很容易了："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:779
#, no-wrap
msgid ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"
msgstr ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:799
msgid ""
"And yet, it would be much more convenient to still use string literals for "
"this, without having to sacrifice the comfort of safety. To do so, we can't "
"use interface `FromString`, as its function `fromString` would force us to "
"convert *any* string, even an invalid one. However, we actually don't need "
"an implementation of `FromString` to support string literals, just like we "
"didn't require an implementation of `Num` to support integer literals.  What "
"we really need is a function named `fromString`. Now, when string literals "
"are desugared, they are converted to invocations of `fromString` with the "
"given string value as its argument.  For instance, literal `\"Hello\"` gets "
"desugared to `fromString \"Hello\"`.  This happens before type checking and "
"filling in of (auto) implicit values. It is therefore perfectly fine, to "
"define a custom `fromString` function with an erased auto implicit argument "
"as a proof of validity:"
msgstr ""
"然而，为此仍然使用字符串字面量会更方便，而不必牺牲安全的舒适性。为此，我们不"
"能使用接口 `FromString`，因为它的函数 `fromString` 会强制我们转换 *任意* 字符"
"串，即使是无效字符串。但是，我们实际上不需要实现 `FromString` 来支持字符串文"
"字，就像我们不需要实现 `Num` 来支持整数字面量一样。我们真正需要的是一个名为 "
"`fromString` 的函数。现在，当字符字面量字被脱糖时，它们被转换为以给定字符串值"
"作为参数的 `fromString` 的调用。例如，文字 `\"Hello\"` 被脱糖为 `fromString "
"\"Hello\"`。这发生在类型检查和填充（自动）隐式值之前。因此，使用已擦除的自动"
"隐式参数定义自定义 `fromString` 函数作为有效性证明是非常好的："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:800
#, no-wrap
msgid ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> Ascii\n"
"fromString s = MkAscii s prf\n"
msgstr ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> Ascii\n"
"fromString s = MkAscii s prf\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:807
msgid ""
"With this, we can use (valid) string literals for coming up with values of "
"type `Ascii` directly:"
msgstr "有了这个，我们可以使用（有效的）字符串文字直接得出 `Ascii` 类型的值："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:808
#, no-wrap
msgid ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"
msgstr ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:816
msgid ""
"In order to at runtime create values of type `Ascii` from strings of an "
"unknown source, we can use a refinement function returning some kind of "
"failure type:"
msgstr ""
"为了在运行时从未知来源的字符串中创建 `Ascii` 类型的值，我们可以使用返回某种故"
"障类型的细化函数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:817
#, no-wrap
msgid ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"
msgstr ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"

#. type: Title ####
#: ../src/Tutorial/Prim.md:828
#, no-wrap
msgid "Disadvantages of Boolean Proofs"
msgstr "布尔证明的缺点"

#. type: Plain text
#: ../src/Tutorial/Prim.md:833
msgid ""
"For many use cases, what we described above for ASCII strings can take us "
"very far. However, one drawback of this approach is that we can't safely "
"perform any computations with the proofs at hand."
msgstr ""
"对于许多用例，我们上面描述的 ASCII 字符串可以让我们走得很远。然而，这种方法的"
"一个缺点是我们不能使用手头的证明安全地执行任何计算。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:838
msgid ""
"For instance, we know it will be perfectly fine to concatenate two ASCII "
"strings, but in order to convince Idris of this, we will have to use "
"`believe_me`, because we will not be able to proof the following lemma "
"otherwise:"
msgstr ""
"例如，我们知道连接两个 ASCII 字符串会非常好，但是为了让 Idris 相信这一点，我"
"们必须使用 `believe_me`，否则我们将无法证明以下引理："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:839
#, no-wrap
msgid ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
msgstr ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:860
msgid ""
"The same goes for all operations extracting a substring from a given string: "
"We will have to implement according rules using `believe_me`. Finding a "
"reasonable set of axioms to conveniently deal with refined primitives can "
"therefore be challenging at times, and whether such axioms are even required "
"very much depends on the use case at hand."
msgstr ""
"从给定字符串中提取子字符串的所有操作也是如此：我们必须使用 `believe_me` 来实"
"现相应的规则。因此，找到一组合理的公理来方便地处理精炼的原语有时可能具有挑战"
"性，而且是否需要这样的公理在很大程度上取决于手头的用例。"

#. type: Title ###
#: ../src/Tutorial/Prim.md:861
#, no-wrap
msgid "Use Case: Sanitized HTML"
msgstr "用例：净化的 HTML"

#. type: Plain text
#: ../src/Tutorial/Prim.md:868
msgid ""
"Assume you write a simple web application for scientific discourse between "
"registered users. To keep things simple, we only consider unformatted text "
"input here. Users can write arbitrary text in a text field and upon hitting "
"Enter, the message is displayed to all other registered users."
msgstr ""
"假设您为注册用户之间的科学讨论编写了一个简单的 Web 应用程序。为了简单起见，我"
"们在这里只考虑未格式化的文本输入。用户可以在文本字段中写入任意文本，然后按 "
"Enter 键，该消息将显示给所有其他注册用户。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:870
msgid "Assume now a user decides to enter the following text:"
msgstr "假设现在用户决定输入以下文本："

#. type: Fenced code block (html)
#: ../src/Tutorial/Prim.md:871
#, no-wrap
msgid "<script>alert(\"Hello World!\")</script>\n"
msgstr "<script>alert(\"Hello World!\")</script>\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:883
msgid ""
"Well, it could have been (much) worse. Still, unless we take measures to "
"prevent this from happening, this might embed a JavaScript program in our "
"web page we never intended to have there! What I described here, is a well "
"known security vulnerability called [cross-site scripting](https://en."
"wikipedia.org/wiki/Cross-site_scripting).  It allows users of web pages to "
"enter malicious JavaScript code in text fields, which will then be included "
"in the page's HTML structure and executed when it is being displayed to "
"other users."
msgstr ""
"好吧，它本来可以（非常）更糟。尽管如此，除非我们采取措施防止这种情况发生，否"
"则这可能会在我们的网页中嵌入我们从未打算拥有的 JavaScript 程序！我在这里描述"
"的是一个众所周知的安全漏洞，称为 [cross-site scripting](https://en.wikipedia."
"org/wiki/Cross-site_scripting)。它允许网页用户在文本字段中输入恶意 "
"JavaScript 代码，然后这些代码将包含在页面的 HTML 结构中，并在向其他用户显示时"
"执行。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:890
#, no-wrap
msgid ""
"We want to make sure, that this cannot happen on our own web page.\n"
"In order to protect us from this attack, we could for instance disallow\n"
"certain characters like `'<'` or `'>'` completely (although this might not\n"
"be enough!), but if our chat service is targeted at programmers,\n"
"this will be overly restrictive. An alternative\n"
"is to escape certain characters before rendering them on the page.\n"
msgstr "我们想确保这不会发生在我们自己的网页上。为了保护我们免受这种攻击，我们可以例如完全禁止某些字符，例如 `'<'` 或 `'>'`（尽管这可能还不够！），但是如果我们的聊天服务是针对程序员的，这将是过度限制。另一种方法是在将某些字符呈现在页面上之前对其进行转义。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:891
#, no-wrap
msgid ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"
msgstr ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:909
msgid ""
"What we now want to do is to store a string together with a proof that is "
"was properly escaped. This is another form of existential quantification: "
"\"Here is a string, and there once existed another string, which we passed "
"to `escape` and arrived at the string we have now\". Here's how to encode "
"this:"
msgstr ""
"我们现在要做的是将字符串与正确转义的证明一起存储。这是存在量化的另一种形"
"式：“这是一个字符串，曾经存在另一个字符串，我们将其传递给 `escape` 并到达我们"
"现在拥有的字符串”。以下是如何对此进行编码："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:910
#, no-wrap
msgid ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"
msgstr ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:924
msgid ""
"Whenever we now embed a string of unknown origin in our web page, we can "
"request a value of type `Escaped` and have the very strong guarantee that we "
"are no longer vulnerable to cross-site scripting attacks. Even better, it is "
"also possible to safely embed string literals known at compile time without "
"the need to escape them first:"
msgstr ""
"每当我们现在在我们的网页中嵌入一个未知来源的字符串时，我们都可以请求一个类型"
"为 `Escaped` 的值，并且非常有力地保证我们不再容易受到跨站点脚本攻击。更好的"
"是，还可以安全地嵌入编译时已知的字符串文字，而无需先转义它们："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:925
#, no-wrap
msgid ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"
msgstr ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:940
msgid ""
"In this massive set of exercises, you are going to build a small library for "
"working with predicates on primitives.  We want to keep the following goals "
"in mind:"
msgstr ""
"在这组庞大的练习中，您将构建一个小型库，用于处理原语上的谓词。我们要牢记以下"
"目标："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:954
msgid ""
"We want to use the usual operations of propositional logic to combine "
"predicates: Negation, conjuction (logical *and*), and disjunction (logical "
"*or*)."
msgstr ""
"我们想使用命题逻辑的常用运算来组合谓词：否定、合取（逻辑*与*）和析取（逻辑*或"
"*）。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:954
msgid ""
"All predicates should be erased at runtime. If we proof something about a "
"primitive number, we want to make sure not to carry around a huge proof of "
"validity."
msgstr ""
"所有谓词都应在运行时擦除。如果我们证明一些关于原语数字的东西，我们要确保不携"
"带大量的有效性证明。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:954
msgid ""
"Calculations on predicates should make no appearance at runtime (with the "
"exception of `decide`; see below)."
msgstr "谓词的计算不应在运行时出现（`decide` 除外；见下文）。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:954
msgid ""
"Recursive calculations on predicates should be tail recursive if they are "
"used in implementations of `decide`. This might be tough to achieve. If you "
"can't find a tail recursive solution for a given problem, use what feels "
"most natural instead."
msgstr ""
"如果谓词用于 `decide` 的实现，则谓词的递归计算应该是尾递归的。这可能很难实"
"现。如果您找不到给定问题的尾递归解决方案，请改用感觉最自然的方法。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:979
msgid ""
"A note on efficiency: In order to be able to run computations on our "
"predicates, we try to convert primitive values to algebraic data types as "
"often and as soon as possible: Unsigned integers will be converted to `Nat` "
"using `cast`, and strings will be converted to `List Char` using `unpack`.  "
"This allows us to work with proofs on `Nat` and `List` most of the time, and "
"such proofs can be implemented without resorting to `believe_me` or other "
"cheats. However, the one advantage of primitive types over algebraic data "
"types is that they often perform much better. This is especially critical "
"when comparing integral types with `Nat`: Operations on natural numbers "
"often run with `O(n)` time complexity, where `n` is the size of one of the "
"natural numbers involved, while with `Bits64`, for instance, many operations "
"run in fast constant time (`O(1)`). Luckily, the Idris compiler optimizes "
"many functions on natural number to use the corresponding `Integer` "
"operations at runtime. This has the advantage that we can still use proper "
"induction to proof stuff about natural numbers at compile time, while "
"getting the benefit of fast integer operations at runtime. However, "
"operations on `Nat` do run with `O(n)` time complexity and *compile time*. "
"Proofs working on large natural number will therefore drastically slow down "
"the compiler. A way out of this is discussed at the end of this section of "
"exercises."
msgstr ""
"关于效率的说明：为了能够在我们的谓词上运行计算，我们尝试尽快将原语值转换为代"
"数数据类型：无符号整数将转换为 `Nat` 使用 `cast`，字符串将使用 `unpack` 转换"
"为 `List Char`。这使我们大部分时间都可以在 `Nat` 和 `List` 上使用证明，并且可"
"以在不借助 `believe_me` 或其他作弊手段的情况下实现此类证明。然而，原语类型相"
"对于代数数据类型的一个优势是它们通常执行得更好。在将整数类型与 `Nat` 进行比较"
"时，这一点尤其重要：对自然数的运算通常以 `O(n)` 时间复杂度运行，其中 `n` 是所"
"涉及的自然数其中之一的大小，而对于 `Bits64`，例如，许多操作在常数时间内"
"（`O(1)`）快速运行。幸运的是，Idris 编译器优化了许多自然数函数，以便在运行时"
"使用相应的 `Integer` 操作。这样做的好处是我们仍然可以在编译时使用适当的归纳来"
"证明关于自然数的东西，同时在运行时获得快速整数运算的好处。但是，`Nat` 上的操"
"作确实以 `O(n)` 时间复杂度在 *编译期* 运行。因此，在大自然数上工作的证明将大"
"大减慢编译器的速度。在本节练习的末尾讨论了解决此问题的方法。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:982
msgid ""
"Enough talk, let's begin! To start with, you are given the following "
"utilities:"
msgstr "废话不多说，开始吧！首先，您将获得以下实用程序："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:983
#, no-wrap
msgid ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"
msgstr ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1024
msgid ""
"We also want to run decidable computations at compile time. This is often "
"much more efficient than running a direct proof search on an inductive type. "
"We therefore come up with a predicate witnessing that a `Dec0` value is "
"actually a `Yes0` together with two utility functions:"
msgstr ""
"我们还希望在编译时运行可判定的计算。这通常比在归纳类型上运行直接证明搜索更有"
"效。因此，我们提出了一个谓词，证明 `Dec0` 值实际上是 `Yes0` 以及两个实用函"
"数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1025
#, no-wrap
msgid ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : {0 prf : _} -> IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"
msgstr ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1044
msgid ""
"Finally, as we are planning to refine mostly primitives, we will at times "
"require some sledge hammer to convince Idris that we know what we are doing:"
msgstr ""
"最后，由于我们计划主要改进原语，我们有时需要一些大锤来说服 Idris 我们知道我们"
"在做什么："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1045
#, no-wrap
msgid ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in `unsafeRefineOn`\"\n"
msgstr ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in `unsafeRefineOn`\"\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:1057
msgid "We start with equality proofs. Implement `Decidable` for `Equal v`."
msgstr "我们从等式证明开始。为 `Equal v` 实现 `Decidable`。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1060
#, no-wrap
msgid ""
"   Hint: Use `DecEq` from module `Decidable.Equality` as a constraint\n"
"         and make sure that `v` is available at runtime.\n"
msgstr ""
"   提示：使用模块 `Decidable.Equality` 中的 `DecEq` 作为约束\n"
"         并确保 `v` 在运行时可用。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:1062
msgid "We want to be able to negate a predicate:"
msgstr "我们希望能够否定一个谓词："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1063
#, no-wrap
msgid ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
msgstr ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1069
#, no-wrap
msgid "   Implement `Decidable` for `Neg p` using a suitable constraint.\n"
msgstr "   使用合适的约束为 `Neg p` 实现 `Decidable`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:1071
msgid "We want to describe the conjunction of two predicates:"
msgstr "我们要描述两个谓词的合取："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1072
#, no-wrap
msgid ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q v\n"
msgstr ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1078
#, no-wrap
msgid "   Implement `Decidable` for `(p && q)` using suitable constraints.\n"
msgstr "   使用合适的约束为 `(p && q)` 实现 `Decidable`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:1082
msgid ""
"Come up with a data type called `(||)` for the disjunction (logical *or*) of "
"two predicates and implement `Decidable` using suitable constraints."
msgstr ""
"提出一个名为 `(||)` 的数据类型，用于两个谓词的析取（逻辑*或*），并使用合适的"
"约束实现 `Decidable`。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:1085
msgid ""
"Proof [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)  "
"by implementing the following propositions:"
msgstr ""
"通过实施以下命题证明 [德摩根定律](https://en.wikipedia.org/wiki/"
"De_Morgan%27s_laws)："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1086
#, no-wrap
msgid ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
msgstr ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1099
#, no-wrap
msgid ""
"   The last of De Morgan's implications is harder to type and proof\n"
"   as we need a way to come up with values of type `p v` and `q v`\n"
"   and show that not both can exist. Here is a way to encode this\n"
"   (annotated with quantity 0 as we will need to access an erased\n"
"   contraposition):\n"
msgstr ""
"   德摩根的最后一个含义更难输入和证明\n"
"   因为我们需要一种方法来得出 `p v` 和 `q v` 类型的值\n"
"   并表明并非两者都可以存在。这是一种对此进行编码的方法\n"
"   （用定量 0 注释，因为我们需要访问已擦除的\n"
"   对偶）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1100
#, no-wrap
msgid ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"
msgstr ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1110
#, no-wrap
msgid ""
"   When you implement `negAnd`, remember that you can freely access\n"
"   erased (implicit) arguments, because `negAnd` itself can only be\n"
"   used in an erased context.\n"
msgstr ""
"   当你实现`negAnd`时，记住你可以自由访问\n"
"   擦除（隐式）参数，因为 `negAnd` 本身只能是\n"
"   在已删除的上下文中使用。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1116
msgid ""
"So far, we implemented the tools to algebraically describe and combine "
"several predicate. It is now time to come up with some examples. As a first "
"use case, we will focus on limiting the valid range of natural numbers. For "
"this, we use the following data type:"
msgstr ""
"到目前为止，我们实现了代数描述和组合几个谓词的工具。现在是提出一些例子的时候"
"了。作为第一个用例，我们将专注于限制自然数的有效范围。为此，我们使用以下数据"
"类型："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1117
#, no-wrap
msgid ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"
msgstr ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1127
msgid ""
"This is similar to `Data.Nat.LTE` but I find operator notation often to be "
"clearer.  We also can define and use the following aliases:"
msgstr ""
"这类似于 `Data.Nat.LTE` 但我发现运算符符号通常更清晰。我们还可以定义和使用以"
"下别名："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:1128
#, no-wrap
msgid ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"
msgstr ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Prim.md:1170
msgid ""
"Coming up with a value of type `m <= n` by pattern matching on `m` and `n` "
"is highly inefficient for large values of `m`, as it will require `m` "
"iterations to do so. However, while in an erased context, we don't need to "
"hold a value of type `m <= n`. We only need to show, that such a value "
"follows from a more efficient computation. Such a computation is `compare` "
"for natural numbers: Although this is implemented in the *Prelude* with a "
"pattern match on its arguments, it is optimized by the compiler to a "
"comparison of integers which runs in constant time even for very large "
"numbers.  Since `Prelude.(<=)` for natural numbers is implemented in terms "
"of `compare`, it runs just as efficiently."
msgstr ""
"通过在 `m` 和 `n` 上进行模式匹配来得出 `m <= n` 类型的值对于较大的 `m` 值非常"
"低效，因为这样做需要 `m` 次迭代。但是，在擦除上下文中，我们不需要保存 `m <= "
"n` 类型的值。我们只需要证明，这样的值来自更有效的计算。对于自然数，这样的计算"
"是 `compare`：尽管这是在 *Prelude* 中实现的，其参数的模式匹配，但编译器将其优"
"化为运行在即使对于非常大的数字也是恒定的时间。由于自然数的 `Prelude.(<=)` 是"
"根据 `compare` 实现的，因此它的运行效率同样高。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1174
#, no-wrap
msgid ""
"   We therefore need to proof the following two lemmas (make\n"
"   sure to not confuse `Prelude.(<=)` with `Prim.(<=)` in\n"
"   these declarations):\n"
msgstr ""
"   因此，我们需要证明以下两个引理（使\n"
"   确保不要将 `Prelude.(<=)` 与 `Prim.(<=)` 混淆\n"
"   这些声明）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1175
#, no-wrap
msgid ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
msgstr ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1184
#, no-wrap
msgid ""
"   They come with a quantity of 0, because they are just as inefficient\n"
"   as the other computations we discussed above. We therefore want\n"
"   to make absolutely sure that they will never be used at runtime!\n"
msgstr ""
"   它们的定量为 0，因为它们同样低效\n"
"   正如我们上面讨论的其他计算。因此我们想要\n"
"   绝对确保它们永远不会在运行时使用！\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1189
#, no-wrap
msgid ""
"   Now, implement `Decidable Nat (<= n)`, making use of `test0`,\n"
"   `fromLTE`, and `toLTE`.\n"
"   Likewise, implement `Decidable Nat (m <=)`, because we require\n"
"   both kinds of predicates.\n"
msgstr ""
"   现在，利用 `test0` 实现 `Decidable Nat (<= n)`，\n"
"   `从LTE` 和 `到LTE`。\n"
"   同样，实现 `Decidable Nat (m <=)`，因为我们需要\n"
"   两种谓词。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1192
#, no-wrap
msgid ""
"   Note: You should by now figure out yourself that `n` must be\n"
"   available at runtime and how to make sure that this is the case.\n"
msgstr ""
"   注意：您应该自己知道 `n` 必须是\n"
"   在运行时可用以及如何确保是这种情况。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Prim.md:1197
msgid ""
"Proof that `(<=)` is reflexive and transitive by declaring and implementing "
"corresponding propositions. As we might require the proof of transitivity to "
"chain several values of type `(<=)`, it makes sense to also define a short "
"operator alias for this."
msgstr ""
"通过声明和实现相应的命题证明 `(<=)` 是自反和传递的。由于我们可能需要传递性证"
"明来链接多个类型为 `(<=)` 的值，因此也可以为此定义一个简短的运算符别名。"

#. type: Bullet: '8. '
#: ../src/Tutorial/Prim.md:1199
msgid "Proof that from `n > 0` follows `IsSucc n` and vise versa."
msgstr "证明从 `n > 0` 遵循 `IsSucc n`，反之亦然。"

#. type: Bullet: '9. '
#: ../src/Tutorial/Prim.md:1206
msgid ""
"Declare and implement safe division and modulo functions for `Bits64`, by "
"requesting an erased proof that the denominator is strictly positive when "
"cast to a natural number. In case of the modulo function, return a refined "
"value carrying an erased proof that the result is strictly smaller than the "
"modulus:"
msgstr ""
"声明并实现 `Bits64` 的安全除法和模函数，方法是请求删除证明，证明分母在转换为"
"自然数时严格为正。在模函数的情况下，返回一个精确的值，带有一个删除的证明，证"
"明结果严格小于模数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1207
#, no-wrap
msgid ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"
msgstr ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"

#. type: Bullet: '10. '
#: ../src/Tutorial/Prim.md:1217
msgid ""
"We will use the predicates and utilities we defined so far to convert a "
"value of type `Bits64` to a string of digits in base `b` with `2 <= b && b "
"<= 16`.  To do so, implement the following skeleton definitions:"
msgstr ""
"我们将使用到目前为止定义的谓词和实用程序将 `Bits64` 类型的值转换为基数 `b` 中"
"的数字字符串，其中 `2 <= b && b <= 16`。为此，请实现以下骨架定义："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1222
#, no-wrap
msgid ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"
msgstr ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1227
#, no-wrap
msgid ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"
msgstr ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1229
#, no-wrap
msgid "    base : Bits64 -> Maybe Base\n"
msgstr "    base : Bits64 -> Maybe Base\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1234
#, no-wrap
msgid ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> Base\n"
"    ```\n"
msgstr ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> Base\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1240
#, no-wrap
msgid ""
"    Finally, implement `digits`, using `safeDiv` and `safeMod`\n"
"    in your implementation. This might be challenging, as you will\n"
"    have to manually transform some proofs to satisfy the type\n"
"    checker. You might also require `assert_smaller` in the\n"
"    recursive step.\n"
msgstr ""
"    最后，使用 `safeDiv` 和 `safeMod` 实现 `digits`\n"
"    在您的实现中。这可能具有挑战性，因为您将\n"
"    必须手动转换一些证明以满足类型\n"
"    检查器。您可能还需要 `assert_smaller` 在\n"
"    递归步骤。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1244
#, no-wrap
msgid ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1254
msgid ""
"We will now turn our focus on strings. Two of the most obvious ways in which "
"we can restrict the strings we accept are by limiting the set of characters "
"and limiting their lengths. More advanced refinements might require strings "
"to match a certain pattern or regular expression. In such cases, we might "
"either go for a boolean check or use a custom data type representing the "
"different parts of the pattern, but we will not cover these topics here."
msgstr ""
"我们现在将注意力转向字符串。我们可以限制我们接受的字符串的两种最明显的方法是"
"限制字符集和限制它们的长度。更高级的改进可能需要字符串匹配某个模式或正则表达"
"式。在这种情况下，我们可能会进行布尔检查或使用自定义数据类型来表示模式的不同"
"部分，但我们不会在这里讨论这些主题。"

#. type: Bullet: '11. '
#: ../src/Tutorial/Prim.md:1257
msgid "Implement the following aliases for useful predicates on characters."
msgstr "为字符上的有用谓词实现以下别名。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1261
#, no-wrap
msgid ""
"    Hint: Use `cast` to convert characters to natural numbers,\n"
"    use `(<=)` and `InRange` to specify regions of characters,\n"
"    and use `(||)` to combine regions of characters.\n"
msgstr ""
"    提示：使用 `cast` 将字符转换为自然数，\n"
"    使用 `(<=)` 和 `InRange` 指定字符区域，\n"
"    并使用 `(||)` 组合字符区域。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1265
#, no-wrap
msgid ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"
msgstr ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1268
#, no-wrap
msgid ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"
msgstr ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1271
#, no-wrap
msgid ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"
msgstr ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1274
#, no-wrap
msgid ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"
msgstr ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1277
#, no-wrap
msgid ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"
msgstr ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1280
#, no-wrap
msgid ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"
msgstr ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1283
#, no-wrap
msgid ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"
msgstr ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1286
#, no-wrap
msgid ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"
msgstr ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1289
#, no-wrap
msgid ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"
msgstr ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1293
#, no-wrap
msgid ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"
msgstr ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"

#. type: Bullet: '12. '
#: ../src/Tutorial/Prim.md:1300
msgid ""
"The advantage of this more modular approach to predicates on primitives is "
"that we can safely run calculations on our predicates and get the strong "
"guarantees from the existing proofs on inductive types like `Nat` and "
"`List`. Here are some examples of such calculations and conversions, all of "
"which can be implemented without cheating:"
msgstr ""
"这种更模块化的原语谓词方法的优势在于，我们可以安全地对谓词运行计算，并从现有"
"的关于归纳类型（如 `Nat` 和 `List`）的证明中获得强有力的保证。以下是此类计算"
"和转换的一些示例，所有这些都可以在不作弊的情况下实现："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1303
#, no-wrap
msgid ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"
msgstr ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1305
#, no-wrap
msgid "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"
msgstr "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1307
#, no-wrap
msgid "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"
msgstr "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1309
#, no-wrap
msgid "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"
msgstr "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1311
#, no-wrap
msgid "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"
msgstr "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1313
#, no-wrap
msgid "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"
msgstr "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1316
#, no-wrap
msgid ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"
msgstr ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1323
#, no-wrap
msgid ""
"    The following (`asciiToLatin`) is trickier. Remember that\n"
"    `(<=)` is transitive. However, in your invocation of the proof\n"
"    of transitivity, you will not be able to apply direct proof search using\n"
"    `%search` because the search depth is too small. You could\n"
"    increase the search depth, but it is much more efficient\n"
"    to use `safeDecideOn` instead.\n"
msgstr ""
"    以下 (`asciiToLatin`) 比较棘手。请记住\n"
"    `(<=)` 是传递的。但是，在您调用证明时\n"
"    传递性，您将无法使用直接证明搜索\n"
"    `%search` 因为搜索深度太小。你可以\n"
"    增加搜索深度，但\n"
"    改为使用 `safeDecideOn` 效率更高。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1326
#, no-wrap
msgid ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"
msgstr ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1329
#, no-wrap
msgid ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"
msgstr ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1333
msgid ""
"Before we turn our full attention to predicates on strings, we have to cover "
"lists first, because we will often treat strings as lists of characters."
msgstr ""
"在我们将全部注意力转向字符串谓词之前，我们必须先介绍列表，因为我们经常将字符"
"串视为字符列表。"

#. type: Bullet: '13. '
#: ../src/Tutorial/Prim.md:1335
msgid "Implement `Decidable` for `Head`:"
msgstr "为 `Head` 实现 `Decidable`："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1340
#, no-wrap
msgid ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"

#. type: Bullet: '14. '
#: ../src/Tutorial/Prim.md:1342
msgid "Implement `Decidable` for `Length`:"
msgstr "为 `Length` 实现 `Decidable`："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1349
#, no-wrap
msgid ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"

#. type: Bullet: '15. '
#: ../src/Tutorial/Prim.md:1353
msgid ""
"The following predicate is a proof that all values in a list of values "
"fulfill the given predicate. We will use this to limit the valid set of "
"characters in a string."
msgstr ""
"以下谓词证明值列表中的所有值都满足给定谓词。我们将使用它来限制字符串中的有效"
"字符集。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1362
#, no-wrap
msgid ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1364
#, no-wrap
msgid "    Implement `Decidable` for `All`.\n"
msgstr "    为 `All` 实现 `Decidable`。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1372
#, no-wrap
msgid ""
"    For a real challenge, try to make your implementation of\n"
"    `decide` tail recursive. This will be important for real world\n"
"    applications on the JavaScript backends, where we might want to\n"
"    refine strings of thousands of characters without overflowing the\n"
"    stack at runtime. In order to come up with a tail recursive implementation,\n"
"    you will need an additional data type `AllSnoc` witnessing that a predicate\n"
"    holds for all elements in a `SnocList`.\n"
msgstr ""
"    对于真正的挑战，请尝试使您的\n"
"    `decide`  实现尾递归。这对JavaScript 后端上的现实世界应用程序很重要，我们可能想要精炼数千个字符的字符串的地方\n"
"    而不会在运行时堆栈溢出。为了提出尾递归实现，\n"
"    您将需要一个额外的数据类型 `AllSnoc` 来见证谓词\n"
"    适用于 `SnocList` 中的所有元素。\n"

#. type: Bullet: '16. '
#: ../src/Tutorial/Prim.md:1378
msgid ""
"It's time to come to an end here. An identifier in Idris is a sequence of "
"alphanumeric characters, possibly separated by underscore characters (`_`). "
"In addition, all identifiers must start with a letter.  Given this "
"specification, implement predicate `IdentChar`, from which we can define a "
"new wrapper type for identifiers:"
msgstr ""
"是时候在这里结束了。 Idris 中的标识符是一系列字母数字字符，可能由下划线字符 "
"(`_`) 分隔。此外，所有标识符都必须以字母开头。给定这个规范，实现谓词 "
"`IdentChar`，我们可以从中为标识符定义一个新的包装器类型："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1381
#, no-wrap
msgid ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"
msgstr ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1387
#, no-wrap
msgid ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"
msgstr ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1390
#, no-wrap
msgid ""
"    Implement a factory method `identifier` for converting strings\n"
"    of unknown source at runtime:\n"
msgstr "    实现一个工厂方法 `identifier` 来转换运行时未知来源的字符串 ：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1394
#, no-wrap
msgid ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1397
#, no-wrap
msgid ""
"    In addition, implement `fromString` for `Identifier` and verify,\n"
"    that the following is a valid identifier:\n"
msgstr ""
"    此外，为 `Identifier` 实现 `fromString` 并验证，\n"
"    以下是有效的标识符：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1402
#, no-wrap
msgid ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1408
msgid ""
"Final remarks: Proofing stuff about the primitives can be challenging, both "
"when deciding on what axioms to use and when trying to make things perform "
"well at runtime and compile time. I'm experimenting with a library, which "
"deals with these issues. It is not yet finished, but you can have a look at "
"it [here](https://github.com/stefan-hoeck/idris2-prim)."
msgstr ""
"最后的评论：在决定使用什么公理以及试图使事情在运行时和编译时表现良好时，证明"
"关于原语的东西可能具有挑战性。我正在尝试一个处理这些问题的库。它尚未完成，但"
"您可以在 [这里](https://github.com/stefan-hoeck/idris2-prim) 看看它。"
