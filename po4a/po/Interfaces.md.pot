# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Stefan HÃ¶ck
# This file is distributed under the same license as the Functional Programming in Idris 2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Idris 2 1.0\n"
"POT-Creation-Date: 2025-05-15 07:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:645
msgid "And at the REPL:"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Interfaces.md:1
#, no-wrap
msgid "Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:9
msgid ""
"Function overloading - the definition of functions with the same name but "
"different implementations - is a concept found in many programming "
"languages. Idris natively supports overloading of functions: Two functions "
"with the same name can be defined in different modules or namespaces, and "
"Idris will try to disambiguate between these based on the types involved. "
"Here is an example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:10
#, no-wrap
msgid ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:35
msgid ""
"Here, we defined three different functions called `size`, each in its own "
"namespace. We can disambiguate between these by prefixing them with their "
"namespace:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:36
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:42
msgid "However, this is usually not necessary:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:43
#, no-wrap
msgid ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:51
msgid ""
"As you can see, Idris can disambiguate between the different `size` "
"functions, since `xs` is of type `List Integer`, which unifies only with "
"`List a`, the argument type of `List.size`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:52
#, no-wrap
msgid "Interface Basics"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:57
msgid ""
"While function overloading as described above works well, there are use "
"cases, where this form of overloaded functions leads to a lot of code "
"duplication."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:61
msgid ""
"As an example, consider a function `cmp` (short for *compare*, which is "
"already exported by the *Prelude*), for describing an ordering for the "
"values of type `String`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:62
#, no-wrap
msgid "cmp : String -> String -> Ordering\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:70
msgid ""
"We'd also like to have similar functions for many other data types.  "
"Function overloading allows us to do just that, but `cmp` is not an isolated "
"piece of functionality. From it, we can derive functions like "
"`greaterThan'`, `lessThan'`, `minimum'`, `maximum'`, and many others:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:71
#, no-wrap
msgid ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:94
msgid ""
"We'd need to implement all of these again for the other types with a `cmp` "
"function, and most if not all of these implementations would be identical to "
"the ones written above. That's a lot of code repetition."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:99
msgid ""
"One way to solve this is to use higher-order functions.  For instance, we "
"could define function `minimumBy`, which takes a comparison function as its "
"first argument and returns the smaller of the two remaining arguments:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:100
#, no-wrap
msgid ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:114
msgid ""
"This solution is another proof of how higher-order functions allow us to "
"reduce code duplication. However, the need to explicitly pass around the "
"comparison function all the time can get tedious as well.  It would be nice, "
"if we could teach Idris to come up with such a function on its own."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:116
msgid "Interfaces solve exactly this issue. Here's an example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:117
#, no-wrap
msgid ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:133
msgid ""
"The code above defines *interface* `Comp` providing function `comp` for "
"calculating the ordering for two values of a type `a`, followed by two "
"*implementations* of this interface for types `Bits8` and `Bits16`. Note, "
"that the `implementation` keyword is optional."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:137
msgid ""
"The `comp` implementations for `Bits8` and `Bits16` both use function "
"`compare`, which is part of a similar interface from the *Prelude* called "
"`Ord`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:139
msgid "The next step is to look at the type of `comp` at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:140
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:154
#, no-wrap
msgid ""
"The interesting part in the type signature of `comp` is\n"
"the initial `Comp a =>` argument. Here, `Comp` is a *constraint* on\n"
"type parameter `a`. This signature can be read as:\n"
"\"For any type `a`, given an implementation\n"
"of interface `Comp` for `a`, we can compare two values\n"
"of type `a` and return an `Ordering` for these.\"\n"
"Whenever we invoke `comp`, we expect Idris to come up with a\n"
"value of type `Comp a` on its own, hence the new `=>` arrow.\n"
"If Idris fails to do so, it will answer with a type error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:158
msgid ""
"We can now use `comp` in the implementations of related functions.  All we "
"have to do is to also prefix these derived functions with a `Comp` "
"constraint:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:159
#, no-wrap
msgid ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:185
msgid ""
"Note, how the definition of `minimum` is almost identical to `minimumBy`. "
"The only difference being that in case of `minimumBy` we had to pass the "
"comparison function as an explicit argument, while for `minimum` it is "
"provided as part of the `Comp` implementation, which is passed around by "
"Idris for us."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:188
msgid ""
"Thus, we have defined all these utility functions once and for all for every "
"type with an implementation of interface `Comp`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:195
#, no-wrap
msgid ""
"1. Implement function `anyLarger`, which should return `True`,\n"
"if and only if a list of values contains at least one element larger\n"
"than a given reference value. Use interface `Comp` in your\n"
"implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:200
#, no-wrap
msgid ""
"2. Implement function `allLarger`, which should return `True`,\n"
"if and only if a list of values contains *only* elements larger\n"
"than a given reference value. Note, that this is trivially true\n"
"for the empty list. Use interface `Comp` in your implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:206
#, no-wrap
msgid ""
"3. Implement function `maxElem`, which tries to extract the\n"
"largest element from a list of values with a `Comp` implementation.\n"
"Likewise for `minElem`, which tries to extract the smallest element.\n"
"Note, that the possibility of the list being empty must be considered\n"
"when deciding on the output type.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:210
#, no-wrap
msgid ""
"4. Define an interface `Concat` for values like lists or\n"
"strings, which can be concatenated. Provide implementations\n"
"for lists and strings.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:215
#, no-wrap
msgid ""
"5. Implement function `concatList` for concatenating the\n"
"values in a list holding values with a `Concat` implementation.\n"
"Make sure to reflect the possibility of the list being empty in your\n"
"output type.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:216
#, no-wrap
msgid "More about Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:224
msgid ""
"In the last section, we learned about the very basics of interfaces: Why "
"they are useful and how to define and implement them.  In this section, we "
"will learn about some slightly advanced concepts: Extending interfaces, "
"interfaces with constraints, and default implementations."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:225
#, no-wrap
msgid "Extending Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:233
msgid ""
"Some interfaces form a kind of hierarchy. For instance, for the `Concat` "
"interface used in exercise 4, there might be a child interface called "
"`Empty`, for those types, which have a neutral element with relation to "
"concatenation.  In such a case, we make an implementation of `Concat` a "
"prerequisite for implementing `Empty`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:234
#, no-wrap
msgid ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:254
#, no-wrap
msgid ""
"`Concat a => Empty a` should be read as: \"An implementation\n"
"of `Concat` for type `a` is a *prerequisite* for there being\n"
"an implementation of `Empty` for `a`.\"\n"
"But this also means that, whenever we have an implementation\n"
"of interface `Empty`, we *must* also have an implementation of `Concat`\n"
"and can invoke the corresponding functions:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:255
#, no-wrap
msgid ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:264
msgid ""
"Note, how in the type of `concatListE` we only used an `Empty` constraint, "
"and how in the implementation we were still able to invoke both `empty` and "
"`concat`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:265
#, no-wrap
msgid "Constrained Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:273
msgid ""
"Sometimes, it is only possible to implement an interface for a generic type, "
"if its type parameters implement this interface as well. For instance, "
"implementing interface `Comp` for `Maybe a` makes sense only if type `a` "
"itself implements `Comp`. We can constrain interface implementations with "
"the same syntax we use for constrained functions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:274
#, no-wrap
msgid ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:292
msgid ""
"This is not the same as extending an interface, although the syntax looks "
"very similar. Here, the constraint lies on a *type parameter* instead of the "
"full type.  The last line in the implementation of `Comp (Maybe a)` compares "
"the values stored in the two `Just`s. This is only possible, if there is a "
"`Comp` implementation for these values as well. Go ahead, and remove the "
"`Comp a` constraint from the above implementation. Learning to read and "
"understand Idris' type errors is important for fixing them."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:295
msgid "The good thing is, that Idris will solve all these constraints for us:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:296
#, no-wrap
msgid ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:305
msgid ""
"Here, Idris tries to find an implementation for `Comp (Maybe Bits8)`.  In "
"order to do so, it needs an implementation for `Comp Bits8`.  Go ahead, and "
"replace `Bits8` in the type of `maxTest` with `Bits64`, and have a look at "
"the error message Idris produces."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:306
#, no-wrap
msgid "Default Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:320
msgid ""
"Sometimes, we'd like to pack several related functions in an interface to "
"allow programmers to implement each in the most efficient way, although they "
"*could* be implemented in terms of each other. For instance, consider an "
"interface `Equals` for comparing two values for equality, with functions "
"`eq` returning `True` if two values are equal and `neq` returning `True` if "
"they are not. Surely, we can implement `neq` in terms of `eq`, so most of "
"the time when implementing `Equals`, we will only implement the latter.  In "
"this case, we can give an implementation for `neq` already in the definition "
"of `Equals`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:321
#, no-wrap
msgid ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:332
msgid ""
"If in an implementation of `Equals` we only implement `eq`, Idris will use "
"the default implementation for `neq` as shown above:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:333
#, no-wrap
msgid ""
"Equals String where\n"
"  eq = (==)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:340
msgid ""
"If on the other hand we'd like to provide explicit implementations for both "
"functions, we can do so as well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:341
#, no-wrap
msgid ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:358
#, no-wrap
msgid ""
"1. Implement interfaces `Equals`, `Comp`, `Concat`, and\n"
"  `Empty` for pairs, constraining your implementations as necessary.\n"
"  (Note, that multiple constraints can be given sequentially like\n"
"  other function arguments: `Comp a => Comp b => Comp (a,b)`.)\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:361
msgid ""
"Below is an implementation of a binary tree. Implement interfaces `Equals` "
"and `Concat` for this type."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:362
#, no-wrap
msgid ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:368
#, no-wrap
msgid "Interfaces in the *Prelude*"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:374
msgid ""
"The Idris *Prelude* provides several interfaces plus implementations that "
"are useful in almost every non-trivial program. I'll introduce the basic "
"ones here. The more advanced ones will be discussed in later chapters."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:378
msgid ""
"Most of these interfaces come with associated mathematical laws, and "
"implementations are assumed to adhere to these laws. These laws will be "
"given here as well."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:379
#, no-wrap
msgid "`Eq`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:389
msgid ""
"Probably the most often used interface, `Eq` corresponds to interface "
"`Equals` we used above as an example. Instead of `eq` and `neq`, `Eq` "
"provides two operators `(==)` and `(/=)` for comparing two values of the "
"same type for being equal or not. Most of the data types defined in the "
"*Prelude* come with an implementation of `Eq`, and whenever programmers "
"define their own data types, `Eq` is typically one of the first interfaces "
"they implement."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:390
#, no-wrap
msgid "`Eq` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:393
msgid "We expect the following laws to hold for all implementations of `Eq`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:396
#, no-wrap
msgid ""
"* `(==)` is *reflexive*: `x == x = True` for all `x`. This means, that\n"
"every value is equal to itself.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:399
#, no-wrap
msgid ""
"* `(==)` is *symmetric*: `x == y = y == x` for all `x` and `y`.\n"
"This means, that the order of arguments passed to `(==)` does not matter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:402
#, no-wrap
msgid ""
"* `(==)` is *transitive*: From `x == y = True` and `y == z = True` follows\n"
"`x == z = True`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:405
#, no-wrap
msgid ""
"* `(/=)` is the negation of `(==)`: `x == y = not (x /= y)`\n"
"for all `x` and `y`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:410
msgid ""
"In theory, Idris has the power to verify these laws at compile time for many "
"non-primitive types. However, out of pragmatism this is not required when "
"implementing `Eq`, since writing such proofs can be quite involved."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:411
#, no-wrap
msgid "`Ord`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:419
#, no-wrap
msgid ""
"The pendant to `Comp` in the *Prelude* is interface `Ord`. In addition\n"
"to `compare`, which is identical to our own `comp` it provides comparison\n"
"operators `(>=)`, `(>)`, `(<=)`, and `(<)`, as well as utility functions\n"
"`max` and `min`. Unlike `Comp`, `Ord` extends `Eq`,\n"
"so whenever there is an `Ord` constraint, we also have access to operators\n"
"`(==)` and `(/=)` and related functions.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:420
#, no-wrap
msgid "`Ord` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:423
msgid "We expect the following laws to hold for all implementations of `Ord`:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:433
msgid "`(<=)` is *reflexive* and *transitive*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:433
#, no-wrap
msgid ""
"* `(<=)` is *antisymmetric*: From `x <= y = True` and `y <= x = True`\n"
"follows `x == y = True`.\n"
"* `x <= y = y >= x`.\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:434
#, no-wrap
msgid "`Semigroup` and `Monoid`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:439
#, no-wrap
msgid ""
"`Semigroup` is the pendant to our example interface `Concat`,\n"
"with operator `(<+>)` (also called *append*) corresponding\n"
"to function `concat`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:442
msgid ""
"Likewise, `Monoid` corresponds to `Empty`, with `neutral` corresponding to "
"`empty`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:449
msgid ""
"These are incredibly important interfaces, which can be used to combine two "
"or more values of a data type into a single value of the same type. Examples "
"include but are not limited to addition or multiplication of numeric types, "
"concatenation of sequences of data, or sequencing of computations."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:455
msgid ""
"As an example, consider a data type for representing distances in a "
"geometric application. We could just use `Double` for this, but that's not "
"very type safe. It would be better to use a single field record wrapping "
"values type `Double`, to give such values clear semantics:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:456
#, no-wrap
msgid ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:465
msgid ""
"There is a natural way for combining two distances: We sum up the values "
"they hold. This immediately leads to an implementation of `Semigroup`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:466
#, no-wrap
msgid ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:474
msgid ""
"It is also immediately clear, that zero is the neutral element of this "
"operation: Adding zero to any value does not affect the value at all.  This "
"allows us to implement `Monoid` as well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:475
#, no-wrap
msgid ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:480
#, no-wrap
msgid "`Semigroup` and `Monoid` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:484
msgid ""
"We expect the following laws to hold for all implementations of `Semigroup` "
"and `Monoid`:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`(<+>)` is *associative*: `x <+> (y <+> z) = (x <+> y) <+> z`, for all "
"values `x`, `y`, and `z`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`neutral` is the *neutral element* with relation to `(<+>)`: `neutral <+> x "
"= x <+> neutral = x`, for all `x`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:490
#, no-wrap
msgid "`Show`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:497
msgid ""
"The `Show` interface is mainly used for debugging purposes, and is supposed "
"to display values of a given type as a string, typically closely resembling "
"the Idris code used to create the value. This includes the proper wrapping "
"of arguments in parentheses where necessary. For instance, experiment with "
"the output of the following function at the REPL:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:498
#, no-wrap
msgid ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:505
#, no-wrap
msgid ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:511
msgid "We will learn how to implement instances of `Show` in an exercise."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:512
#, no-wrap
msgid "Overloaded Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:524
msgid ""
"Literal values in Idris, such as integer literals (`12001`), string literals "
"(`\"foo bar\"`), floating point literals (`12.112`), and character literals "
"(`'$'`) can be overloaded. This means, that we can create values of types "
"other than `String` from just a string literal. The exact workings of this "
"has to wait for another section, but for many common cases, it is sufficient "
"for a value to implement interfaces `FromString` (for using string "
"literals), `FromChar` (for using character literals), or `FromDouble` (for "
"using floating point literals).  The case of integer literals is special, "
"and will be discussed in the next section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:531
msgid ""
"Here is an example of using `FromString`. Assume, we write an application "
"where users can identify themselves with a username and password. Both "
"consist of strings of characters, so it is pretty easy to confuse and mix up "
"the two things, although they clearly have very different semantics.  In "
"these cases, it is advisable to come up with new types for the two, "
"especially since getting these things wrong is a security concern."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:533
msgid "Here are three example record types to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:534
#, no-wrap
msgid ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:551
msgid ""
"In order to create a value of type `User`, even for testing, we'd have to "
"wrap all strings using the given constructors:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:552
#, no-wrap
msgid ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:560
msgid ""
"This is rather cumbersome, and some people might think this to be too high a "
"price to pay just for an increase in type safety (I'd tend to disagree).  "
"Luckily, we can get the convenience of string literals back very easily:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:561
#, no-wrap
msgid ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:572
#, no-wrap
msgid "Numeric Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:577
msgid ""
"The *Prelude* also exports several interfaces providing the usual arithmetic "
"operations. Below is a comprehensive list of the interfaces and the "
"functions each provides:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:582
msgid "`Num`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`(+)` : Addition"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`(*)` : Multiplication"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`fromInteger` : Overloaded integer literals"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:586
msgid "`Neg`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
msgid "`negate` : Negation"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
msgid "`(-)` : Subtraction"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:590
msgid "`Integral`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
msgid "`div` : Integer division"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
msgid "`mod` : Modulo operation"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:594
msgid "`Fractional`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
msgid "`(/)` : Division"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
msgid "`recip` : Calculates the reciprocal of a value"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:599
msgid ""
"As you can see: We need to implement interface `Num` to use integer literals "
"for a given type. In order to use negative integer literals like `-12`, we "
"also have to implement interface `Neg`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:600
#, no-wrap
msgid "`Cast`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:607
msgid ""
"The last interface we will quickly discuss in this section is `Cast`. It is "
"used to convert values of one type to values of another via function `cast`. "
"`Cast` is special, since it is parameterized over *two* type parameters "
"unlike the other interfaces we looked at so far, with only one type "
"parameter."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:614
msgid ""
"So far, `Cast` is mainly used for interconversion between primitive types in "
"the standard libraries, especially numeric types. When you look at the "
"implementations exported from the *Prelude* (for instance, by invoking `:doc "
"Cast` at the REPL), you'll see that there are dozens of implementations for "
"most pairings of primitive types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:623
msgid ""
"Although `Cast` would also be useful for other conversions (for going from "
"`Maybe` to `List` or for going from `Either e` to `Maybe`, for instance), "
"the *Prelude* and *base* seem not to introduce these consistently. For "
"instance, there are `Cast` implementations from going from `SnocList` to "
"`List` and vice versa, but not for going from `Vect n` to `List`, or for "
"going from `List1` to `List`, although these would be just as feasible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:629
msgid ""
"These exercises are meant to make you comfortable with implementing "
"interfaces for your own data types, as you will have to do so regularly when "
"writing Idris code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:635
msgid ""
"While it is immediately clear why interfaces like `Eq`, `Ord`, or `Num` are "
"useful, the usability of `Semigroup` and `Monoid` may be harder to "
"appreciate at first.  Therefore, there are several exercises where you'll "
"implement different instances for these."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Interfaces.md:639
msgid ""
"Define a record type `Complex` for complex numbers, by pairing two values of "
"type `Double`.  Implement interfaces `Eq`, `Num`, `Neg`, and `Fractional` "
"for `Complex`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:643
msgid ""
"Implement interface `Show` for `Complex`. Have a look at data type `Prec` "
"and function `showPrec` and how these are used in the *Prelude* to implement "
"instances for `Either` and `Maybe`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:647
#, no-wrap
msgid ""
"   Verify the correct behavior of your implementation by wrapping\n"
"   a value of type `Complex` in a `Just` and `show` the result at\n"
"   the REPL.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Interfaces.md:649
msgid "Consider the following wrapper for optional values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:650
#, no-wrap
msgid ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:660
#, no-wrap
msgid ""
"   Implement interfaces `Eq`, `Ord`, `Show`, `FromString`, `FromChar`, `FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, and `Fractional` for `First a`. All of these will require\n"
"   corresponding constraints on type parameter `a`. Consider implementing and\n"
"   using the following utility functions where they make sense:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:661
#, no-wrap
msgid ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Interfaces.md:673
msgid ""
"Implement interfaces `Semigroup` and `Monoid` for `First a` in such a way, "
"that `(<+>)` will return the first non-nothing argument and `neutral` is the "
"corresponding neutral element. There must be no constraints on type "
"parameter `a` in these implementations."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Interfaces.md:676
msgid ""
"Repeat exercises 3 and 4 for record `Last`. The `Semigroup` implementation "
"should return the last non-nothing value."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:677
#, no-wrap
msgid ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Interfaces.md:687
msgid ""
"Function `foldMap` allows us to map a function returning a `Monoid` over a "
"list of values and accumulate the result using `(<+>)` at the same time.  "
"This is a very powerful way to accumulate the values stored in a list.  Use "
"`foldMap` and `Last` to extract the last element (if any) from a list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:692
#, no-wrap
msgid ""
"   Note, that the type of `foldMap` is more general and not specialized\n"
"   to lists only. It works also for `Maybe`, `Either` and other container\n"
"   types we haven't looked at so far. We will learn about\n"
"   interface `Foldable` in a later section.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Interfaces.md:694
msgid "Consider record wrappers `Any` and `All` for boolean values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:695
#, no-wrap
msgid ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:708
#, no-wrap
msgid ""
"   Implement `Semigroup` and `Monoid` for `Any`, so that the result of\n"
"   `(<+>)` is `True`, if and only if at least one of the arguments is `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:712
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup` and `Monoid` for `All`, so that the result of\n"
"   `(<+>)` is `True`, if and only if both of the arguments are `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Interfaces.md:715
msgid ""
"Implement functions `anyElem` and `allElems` using `foldMap` and `Any` or "
"`All`, respectively:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:716
#, no-wrap
msgid ""
"   -- True, if the predicate holds for at least one element\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- True, if the predicate holds for all elements\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Interfaces.md:726
msgid ""
"Record wrappers `Sum` and `Product` are mainly used to hold numeric types."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:727
#, no-wrap
msgid ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:739
#, no-wrap
msgid ""
"   Given an implementation of `Num a`, implement `Semigroup (Sum a)`\n"
"   and `Monoid (Sum a)`, so that `(<+>)` corresponds to addition.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:742
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup (Product a)` and `Monoid (Product a)`,\n"
"   so that `(<+>)` corresponds to multiplication.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:745
#, no-wrap
msgid ""
"   When implementing `neutral`, remember that you can use integer\n"
"   literals when working with numeric types.\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Interfaces.md:748
msgid ""
"Implement `sumList` and `productList` by using `foldMap` together with the "
"wrappers from Exercise 9:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:751
#, no-wrap
msgid ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:754
#, no-wrap
msgid ""
"    productList : Num a => List a -> a\n"
"    ```\n"
msgstr ""

#. type: Bullet: '11. '
#: ../src/Tutorial/Interfaces.md:760
msgid ""
"To appreciate the power and versatility of `foldMap`, after solving "
"exercises 6 to 10 (or by loading `Solutions.Inderfaces` in a REPL session), "
"run the following at the REPL, which will - in a single list traversal! - "
"calculate the first and last element of the list as well as the sum and "
"product of all values."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:765
#, no-wrap
msgid ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) [3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:772
#, no-wrap
msgid ""
"    Note, that there are also `Semigroup` implementations for\n"
"    types with an `Ord` implementation, which will return\n"
"    the smaller or larger of two values. In case of types\n"
"    with an absolute minimum or maximum (for instance, 0 for\n"
"    natural numbers, or 0 and 255 for `Bits8`), these can even\n"
"    be extended to `Monoid`.\n"
msgstr ""

#. type: Bullet: '12. '
#: ../src/Tutorial/Interfaces.md:778
msgid ""
"In an earlier exercise, you implemented a data type representing chemical "
"elements and wrote a function for calculating their atomic masses. Define a "
"new single field record type for representing atomic masses, and implement "
"interfaces `Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, and `Monoid` for "
"this."
msgstr ""

#. type: Bullet: '13. '
#: ../src/Tutorial/Interfaces.md:782
msgid ""
"Use the new data type from exercise 12 to calculate the atomic mass of an "
"element and compute the molecular mass of a molecule given by its formula."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:785
#, no-wrap
msgid ""
"    Hint: With a suitable utility function, you can use `foldMap`\n"
"    once again for this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:791
msgid ""
"Final notes: If you are new to functional programming, make sure to give "
"your implementations of exercises 6 to 10 a try at the REPL.  Note, how we "
"can implement all of these functions with a minimal amount of code and how, "
"as shown in exercise 11, these behaviors can be combined in a single list "
"traversal."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces allow us to implement the same function with different behavior "
"for different types."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Functions taking one or more interface implementations as arguments are "
"called *constrained functions*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces can be organized hierarchically by *extending* other interfaces."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces implementations can themselves be *constrained* requiring other "
"implementations to be available."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interface functions can be given a *default implementation*, which can be "
"overridden by implementers, for instance for reasons of efficiency."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Certain interfaces allow us to use literal values such as string or integer "
"literals for our own data types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:812
msgid ""
"Note, that I did not yet tell the whole story about literal values in this "
"section. More details for using literals with types that accept only a "
"restricted set of values can be found in the chapter about [primitives]"
"(Prim.md)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:819
msgid ""
"In the [next chapter](Functions2.md), we have a closer look at functions and "
"their types. We will learn about named arguments, implicit arguments, and "
"erased arguments as well as some constructors for implementing more complex "
"functions."
msgstr ""
