# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "练习第 1 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "练习第 2 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "练习第 3 部分"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr "下一步是什么"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, fuzzy, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:90
#, no-wrap
msgid "Dependent Types"
msgstr "依赖类型"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:9
#, no-wrap
msgid ""
"The ability to calculate types from values, pass them as arguments\n"
"to functions, and return them as results from functions - in\n"
"short, being a dependently typed language - is one of the\n"
"most distinguishing features of Idris. Many of the more advanced\n"
"type level extensions of languages like Haskell (and quite a\n"
"bit more) can be treated in one fell swoop with dependent types.\n"
msgstr "从值计算类型、将它们作为参数传递给函数并将它们作为函数结果返回的能力——简而言之，作为一种依赖类型的语言——是 Idris 最显着的特征之一。许多更高级的语言的类型级别扩展，如 Haskell（以及更多）都可以使用依赖类型来处理。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:10
#, no-wrap
msgid ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:17
#, no-wrap
msgid "Consider the following functions:\n"
msgstr "考虑以下函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:18
#, no-wrap
msgid ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"
msgstr ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:35
#, no-wrap
msgid ""
"The implementations type check, and still, they are obviously not\n"
"what users of our library would expect. In the first example, we'd expect\n"
"the implementation to apply the function argument to all values stored\n"
"in the list, without dropping any of them or changing their order.\n"
"The second is trickier: The two list arguments might be of different length.\n"
"What are we supposed to do when that's the case? Return a list of the same\n"
"length as the smaller of the two? Return an empty list? Or shouldn't\n"
"we in most use cases expect the two lists to be of the same length?\n"
"How could we even describe such a precondition?\n"
msgstr "实现可以通过类型检查，但它们显然不是我们库的用户所期望的。在第一个示例中，我们希望实现将函数参数应用于存储在列表中的所有值，而不会删除它们中的任何一个或更改它们的顺序。第二个比较棘手：两个列表参数的长度可能不同。遇到这种情况我们该怎么办？返回与两者中较小的长度相同的列表？返回一个空列表？或者在大多数用例中我们不应该期望两个列表具有相同的长度吗？我们怎么能描述这样的前提条件呢？\n"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:36
#, no-wrap
msgid "Length-Indexed Lists"
msgstr "长度索引列表"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:41
#, no-wrap
msgid ""
"The answer to the issues described above is of course: Dependent types.\n"
"And the most common introductory example is the *vector*: A list indexed\n"
"by its length:\n"
msgstr "上述问题的答案当然是：依赖类型。最常见的介绍性示例是 *向量*：按长度索引的列表：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:42
#, no-wrap
msgid ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"
msgstr ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:58
#, no-wrap
msgid ""
"Before we move on, please compare this with the implementation of `Seq` in\n"
"the [section about algebraic data types](DataTypes.md). The constructors\n"
"are exactly the same: `Nil` and `(::)`. But there is an important difference:\n"
"`Vect`, unlike `Seq` or `List`, is not a function from `Type` to `Type`, it is\n"
"a function from `Nat` to `Type` to `Type`. Go ahead! Open the REPL and\n"
"verify this! The `Nat` argument (also called an *index*) represents\n"
"the *length* of the vector here.\n"
"`Nil` has type `Vect 0 a`: A vector of length\n"
"zero. *Cons* has type `a -> Vect n a -> Vect (S n) a`: It is exactly one\n"
"element longer (`S n`) than its second argument, which is of length `n`.\n"
msgstr "在我们继续之前，请将此与 [关于代数数据类型的部分](DataTypes.md) 中的 `Seq` 的实现进行比较。构造函数完全相同：`Nil` 和 `(::)`。但是有一个重要的区别：`Vect` 不像`Seq`或`List`，不是从`Type`到`Type` 的函数，它是从 `Nat` 到 `Type` 到 `Type` 的函数。前进！打开 REPL 并验证这一点！ `Nat` 参数（也称为 *索引*）在这里表示向量的 *长度*。 `Nil` 的类型为 `Vect 0 a`：长度为零的向量。 `Cons` 的类型为 `a -> Vect n a -> Vect (S n) a`：它恰好比其长度为 `n` 的第二个参数多一个元素 (`S n`)，。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:61
#, no-wrap
msgid ""
"Let's experiment with this idea to gain a better understanding.\n"
"There is only one way to come up with a vector of length zero:\n"
msgstr "让我们尝试这个想法以获得更好的理解。只有一种方法可以得出长度为零的向量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:62
#, no-wrap
msgid ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"
msgstr ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:69
#, no-wrap
msgid ""
"The following, on the other hand, leads to a type error (a pretty complicated\n"
"one, actually):\n"
msgstr "另一方面，以下会导致类型错误（实际上是一个非常复杂的错误）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:70
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"
msgstr ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:80
#, no-wrap
msgid ""
"The problem: `[12]` gets desugared to `12 :: Nil`, but this has the wrong\n"
"type! Since `Nil` has type `Vect 0 Integer` here, `12 :: Nil` has type\n"
"`Vect (S 0) Integer`, which is identical to `Vect 1 Integer`. Idris verifies,\n"
"at compile time, that our vector is of the correct length!\n"
msgstr "问题：`[12]` 被脱糖为 `12 :: Nil`，但这类型错误！由于此处 `Nil` 的类型为 `Vect 0 Integer`，因此 `12 :: Nil` 的类型为 `Vect (S 0) Integer`，也就是 `Vect 1 Integer `。 Idris 在编译时验证我们的向量的长度是否正确！\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:81
#, no-wrap
msgid ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"
msgstr ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:93
#, no-wrap
msgid ""
"So, we found a way to encode the *length* of a list-like data structure in\n"
"its *type*, and it is a *type error* if the number of elements in\n"
"a vector does not agree with then length given in its type. We will\n"
"shortly see several use cases, where this additional piece of information\n"
"allows us to be more precise in the types and rule out additional\n"
"programming mistakes. But first, we need to quickly clarify some\n"
"terminology.\n"
msgstr "因此，我们找到了一种方法，将类列表数据结构的 *长度* 编码为 *类型*，如果在向量中的元素个数与其类型中给出的长度不一致，会得到一个 *类型错误*，我们很快就会看到几个用例，这些额外的信息使我们能够更精确地确定类型并排除额外的编程错误。但首先，我们需要快速澄清一些术语。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:94
#, no-wrap
msgid "Type Indices versus Type Parameters"
msgstr "类型索引与类型参数"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:101
#, no-wrap
msgid ""
"`Vect` is not only a generic type, parameterized over the type\n"
"of elements it holds, it is actually a *family of types*, each\n"
"of them associated with a natural number representing it's\n"
"length. We also say, the type family `Vect` is *indexed* by\n"
"its length.\n"
msgstr "`Vect` 不仅是一个泛型类型，参数化了它所拥有的元素的类型，它实际上是一个 *类型族*，它们中的每一个都与一个代表它的长度的自然数相关联。我们也说，类型族 `Vect` 按其长度 *被索引*。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:108
#, no-wrap
msgid ""
"The difference between a type parameter and an index is, that\n"
"the latter can and does change across data constructors, while\n"
"the former is the same for all data constructors. Or, put differently,\n"
"we can learn about the *value* of an index by pattern matching\n"
"on a *value* of the type family, while this is not possible\n"
"with a type parameter.\n"
msgstr "类型参数和索引之间的区别在于，后者可以并且确实在数据构造函数中发生变化，而前者对于所有数据构造函数都是相同的。或者，换句话说，我们可以通过对类型族的*值*进行模式匹配来了解索引的*值*，而对于类型参数，这是不可能的。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:110
#, no-wrap
msgid "Let's demonstrate this with a contrived example:\n"
msgstr "让我们用一个人为的例子来证明这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:111
#, no-wrap
msgid ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"
msgstr ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:124
#, no-wrap
msgid ""
"Here, `Indexed` is indexed over its `Nat` argument, as\n"
"values of the index changes across constructors (I chose some\n"
"arbitrary value for each constructor), and we\n"
"can learn about these values by pattern matching on `Indexed` values.\n"
"We can use this, for instance, to create a `Vect` of the same length\n"
"as the index of `Indexed`:\n"
msgstr "在这里，`Indexed` 在它的 `Nat` 参数上进行索引，因为索引的值在构造函数之间发生变化（我为每个构造函数选择了一些任意值），我们可以通过模式匹配了解这些 `Indexed` 值。例如，我们可以使用它来创建与 `Indexed` 的索引长度相同的 `Vect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:125
#, no-wrap
msgid "fromIndexed : Indexed n -> a -> Vect n a\n"
msgstr "fromIndexed : Indexed n -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:133
#, no-wrap
msgid ""
"Go ahead, and try implementing this yourself! Work with\n"
"holes, pattern match on the `Indexed` argument, and\n"
"learn about the expected output type in each case by\n"
"inspecting the holes and their context.\n"
msgstr "来吧，尝试自己实现它！使用孔，对 `Indexed` 参数进行模式匹配，并通过检查孔及其上下文了解每种情况下的预期输出类型。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:135
#, no-wrap
msgid "Here is my implementation:\n"
msgstr "这是我的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:136
#, no-wrap
msgid ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"
msgstr ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:146
#, no-wrap
msgid ""
"As you can see, by pattern matching on the value of the\n"
"`Indexed n` argument, we learned about the value of\n"
"the `n` index itself, which was necessary to return a\n"
"`Vect` of the correct length.\n"
msgstr "如您所见，通过对 `Indexed n` 参数的值进行模式匹配，我们了解了 `n` 索引本身的值，这是返回 `Vect` 所必需的正确长度。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:147
#, no-wrap
msgid "Length-Preserving `map`"
msgstr "长度保持的 `map`"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:154
#, no-wrap
msgid ""
"Function `bogusMapList` behaved unexpectedly, because it always\n"
"returned the empty list. With `Vect`, we need to be true to the\n"
"types here. If we map over a `Vect`, the argument *and* output type\n"
"contain a length index, and these length indices will tell us\n"
"*exactly*, if and how the lengths of our vectors are modified:\n"
msgstr "函数 `bogusMapList` 表现异常，因为它总是返回空列表。对于 `Vect`，我们需要忠实于这里的类型。如果我们在 `Vect` 上映射，参数 *和* 输出类型包含一个长度索引，这些长度索引将*确切的* 告诉我们，我们的向量长度如何被修改：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:155
#, no-wrap
msgid ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"
msgstr ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:173
#, no-wrap
msgid ""
"While these examples are quite interesting,\n"
"they are not really useful, are they? That's because they are too\n"
"specialized. We'd like to have a *general* function for mapping\n"
"vectors of any length.\n"
"Instead of using concrete lengths in type signatures,\n"
"we can also use *variables* as already seen in the definition of `Vect`.\n"
"This allows us to declare the general case:\n"
msgstr "虽然这些例子很有趣，但它们并不是真的有用，不是吗？那是因为他们太专业了。我们想要一个 *通用* 函数来映射任意长度的向量。除了在类型签名中使用具体的长度，我们还可以使用*变量*，正如在 `Vect` 的定义中已经看到的那样。这允许我们声明一般情况：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:174
#, no-wrap
msgid "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"
msgstr "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:181
#, no-wrap
msgid ""
"This type describes a length-preserving map. It is actually\n"
"more instructive (but not necessary) to include the\n"
"implicit arguments as well:\n"
msgstr "这种类型描述了一个长度保持映射。包含隐式参数实际上更有指导意义（但不是必需的）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:182
#, no-wrap
msgid "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"
msgstr "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:196
#, no-wrap
msgid ""
"We ignore the two type parameters `a`, and `b`, as these just\n"
"describe a generic function (note, however, that we can group arguments\n"
"of the same type and quantity in a single pair of curly braces; this\n"
"is optional, but it sometimes helps making type signatures a bit\n"
"shorter). The implicit argument of type `Nat`, however, tells us that the\n"
"input and output `Vect` are of the same length. It is a type error\n"
"to not uphold to this contract. When implementing `mapVect`, it\n"
"is very instructive to follow along and use some holes. In order\n"
"to get *any* information about the length of the `Vect` argument,\n"
"we need to pattern match on it:\n"
msgstr "我们忽略了两个类型参数 `a` 和 `b`，因为它们只是描述了一个泛型函数（但是请注意，我们可以将相同类型和定量的参数组合成一对大括号；这是可选的，但有时有助于使类型签名更短）。然而，`Nat` 类型的隐式参数告诉我们输入和输出 `Vect` 的长度相同。不遵守本合约属于类型错误。在实现 `mapVect` 时，遵循并使用一些孔非常有指导意义。为了获得关于 `Vect` 参数长度的 *任何* 信息，我们需要对其进行模式匹配：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:197
#, no-wrap
msgid ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"
msgstr ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:203
#, no-wrap
msgid "At the REPL, we learn the following:\n"
msgstr "在 REPL，我们学到以下内容：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:204
#, no-wrap
msgid ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"
msgstr ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:226
#, no-wrap
msgid ""
"The first hole, `impl_0` is of type `Vect 0 b`. There is only one such\n"
"value, as discussed above:\n"
msgstr "第一个孔 `impl_0` 的类型为 `Vect 0 b`。如上所述，只有一个这样的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:227
#, no-wrap
msgid "mapVect _ Nil       = Nil\n"
msgstr "mapVect _ Nil       = Nil\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:238
#, no-wrap
msgid ""
"The second case is again more interesting. We note, that `xs` is\n"
"of type `Vect n a`, for an arbitrary length `n` (given as an erased\n"
"argument), while the result is of type `Vect (S n) b`. So, the\n"
"result has to be one element longer than `xs`. Luckily, we already\n"
"have a value of type `a` (bound to variable `x`) and a function\n"
"from `a` to `b` (bound to variable `f`), so we can apply `f`\n"
"to `x` and prepend the result to a yet unknown remainder:\n"
msgstr "第二种情况更有趣。我们注意到，`xs` 是 `Vect n a` 类型，对于任意长度 `n`（作为已擦除参数给出），而结果是类型 `Vect (S n) b`。因此，结果必须比 `xs` 长一个元素。幸运的是，我们已经有了一个 `a` 类型的值（绑定到变量 `x`）和一个从 `a` 到 `b` 的函数（绑定到变量 `f`)，因此我们可以将 `f` 应用于 `x` 并将结果添加到未知的余数：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:239
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: ?rest\n"
msgstr "mapVect f (x :: xs) = f x :: ?rest\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:244
#, no-wrap
msgid "Let's inspect the new hole at the REPL:\n"
msgstr "让我们在 REPL 检查一下新的孔：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:245
#, no-wrap
msgid ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"
msgstr ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:265
#, no-wrap
msgid ""
"Now, we have a `Vect n a` and need a `Vect n b`, without knowing anything\n"
"else about `n`. We *could* learn more about `n` by pattern matching further\n"
"on `xs`, but this would quickly lead us down a rabbit hole, since after\n"
"such a pattern match, we'd end up with another `Nil` case and another\n"
"*cons* case, with a new tail of unknown length. Instead, we can invoke\n"
"`mapVect` recursively to convert the remainder (`xs`) to a `Vect n b`.\n"
"The type checker guarantees, that the lengths of `xs` and `mapVect f xs`\n"
"are the same, so the whole expression type checks and we are done:\n"
msgstr "现在，我们有一个 `Vect n a` 并且需要一个 `Vect n b`，而不知道关于 `n` 的任何其他信息。我们 *可以* 通过在 `xs` 上进一步进行模式匹配来了解更多关于 `n` 的信息，但这会很快将我们引向一个兔子洞，因为在这样的模式匹配之后，我们'最终会出现另一个 `Nil` 分支和另一个 `cons` 分支，新的尾巴长度未知。相反，我们可以递归调用 `mapVect` 以将余数 (`xs`) 转换为 `Vect n b`。类型检查器保证 `xs` 和 `mapVect f xs` 的长度是相同的，所以整个表达式类型检查，我们就完成了：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:266
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: mapVect f xs\n"
msgstr "mapVect f (x :: xs) = f x :: mapVect f xs\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:270
#, no-wrap
msgid "Zipping Vectors"
msgstr "向量压缩"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:277
#, no-wrap
msgid ""
"Let us now have a look at `bogusZipList`: We'd like to pairwise merge\n"
"two lists holding elements of (possibly) distinct types through a\n"
"given binary function. As discussed above, the most reasonable thing\n"
"to do is to expect the two lists as well as the result to be of equal length.\n"
"With `Vect`, this can be expressed and implemented as follows:\n"
msgstr "现在让我们看一下 `bogusZipList`：我们希望通过给定的二元函数成对合并两个包含（可能）不同类型的元素的列表。如上所述，最合理的做法是期望两个列表以及结果的长度相等。使用 `Vect` 可以表达和实现如下：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:278
#, no-wrap
msgid ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"
msgstr ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:295
#, no-wrap
msgid ""
"Now, here is an interesting thing: The totality checker (activated\n"
"throughout this source file due to the initial `%default total` pragma)\n"
"accepts the above implementation as being total, although it is\n"
"missing two more cases. This works, because Idris\n"
"can figure out on its own, that the other two cases are *impossible*.\n"
"From the pattern match on the first `Vect` argument, Idris learns\n"
"whether `n` is zero or the successor of another natural number. But\n"
"from this it can derive, whether the second vector, being also\n"
"of length `n`, is a `Nil` or a *cons*. Still, it can be informative to add the\n"
"impossible cases explicitly. We can use keyword `impossible` to\n"
"do so:\n"
msgstr "现在，这是一件有趣的事情：完全性检查器（由于初始 `%default total` 杂注而在整个源文件中激活）接受上述实现作为全函数，尽管它缺少另外两个分支。这行得通，因为 Idris 可以自己弄清楚，其他两种情况是 *不可能的*。从第一个 `Vect` 参数的模式匹配中，Idris 了解 `n` 是零还是另一个自然数的后继。但由此可以得出，长度也为 `n` 的第二个向量是 `Nil` 还是 `cons`。尽管如此，明确添加不可能的情况仍然可以提供信息。我们可以使用关键字 `impossible` 来做到这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:296
#, no-wrap
msgid ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"
msgstr ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:306
#, no-wrap
msgid ""
"It is - of course - a type error to annotate a case in a pattern\n"
"match with `impossible`, if Idris cannot verify that this case is\n"
"indeed impossible. We will learn in a later section what to do,\n"
"when we think we are right about an impossible case\n"
"and Idris is not.\n"
msgstr "如果 Idris 无法验证这种情况确实是不可能的，那么用 `impossible` 注释模式匹配中的情况当然是类型错误。当我们认为我们对不可能的情况是正确的而 Idris 不是时，我们将在后面的部分中学习该怎么做。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:308
#, no-wrap
msgid "Let's give `zipWith` a spin at the REPL:\n"
msgstr "让我们在 REPL 上给 `zipWith` 一个旋转：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:309
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... Nasty type error ...\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... Nasty type error ...\n"

#. type: Title ####
#: ../src/Tutorial/Dependent.md:318
#, no-wrap
msgid "Simplifying Type Errors"
msgstr "简化类型错误"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:329
#, no-wrap
msgid ""
"It is amazing to experience the amount of work Idris can do\n"
"for us and the amount of things it can infer on its own when\n"
"things go well. When things don't go well, however, the\n"
"error messages we get from Idris can\n"
"be quite long and hard to understand, especially\n"
"for programmers new to the language. For instance, the error\n"
"message in the last REPL example above was pretty long, listing\n"
"different things Idris tried to do together with the reason\n"
"why each of them failed.\n"
msgstr "体验 Idris 可以为我们做的大量工作以及当事情进展顺利时它可以自行推断出的事情的数量，真是令人惊叹。然而，当事情进展不顺利时，我们从 Idris 收到的错误消息可能会很长且难以理解，尤其是对于刚接触该语言的程序员而言。例如，上面最后一个 REPL 示例中的错误消息很长，列出了 Idris 尝试做的不同事情以及每件事失败的原因。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:341
#, no-wrap
msgid ""
"If this happens, it often means that a combination of a type error\n"
"and an ambiguity resulting from overloaded function names is\n"
"at work. In the example above, the two vectors are of distinct\n"
"length, which leads to a type error if we interpret the list\n"
"literals as vectors. However, list literals are overloaded to work\n"
"with all data types with constructors `Nil` and `(::)`, so Idris\n"
"will now try other data constructors than those of `Vect` (the\n"
"ones of `List` and `Stream` from the *Prelude* in this case),\n"
"each of which will again fail with a type error since `zipWith`\n"
"expects arguments of type `Vect`, and neither `List` nor `Stream`\n"
"will work.\n"
msgstr "如果发生这种情况，通常意味着类型错误和函数名重载导致的歧义在起作用。在上面的示例中，两个向量的长度不同，如果我们将列表字面量解释为向量，则会导致类型错误。但是，列表字面量被重载以使用构造函数 `Nil` 和 `(::)` 的所有数据类型，因此 Idris 现在将尝试除 `Vect` 之外的其他数据构造函数]（在这种情况下，来自 *Prelude* 的 `List` 和 `Stream` ），由于 `zipWith` 需要 `Vect` 类型的参数，所以 `List` 和 `Stream` 都不起作用。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:345
#, no-wrap
msgid ""
"If this happens, prefixing overloaded function names with\n"
"their namespaces can often simplify things, as Idris no\n"
"longer needs to disambiguate these functions:\n"
msgstr "如果发生这种情况，在重载函数名称前加上它们的命名空间通常可以简化事情，因为 Idris 不再需要消除这些函数的歧义：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:346
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:360
#, no-wrap
msgid ""
"Here, the message is much clearer: Idris can't *unify* the lengths of the\n"
"two vectors. *Unification* means: Idris tries to at compile time convert\n"
"two expressions to the same normal form. If this succeeds,\n"
"the two expressions are considered to be equivalent,\n"
"if it doesn't, Idris fails with a unification error.\n"
msgstr "在这里，信息更加清晰：Idris 无法 *统一* 两个向量的长度。 *Unification* 表示：Idris 尝试在编译时将两个表达式转换为相同的范式。如果成功，则认为这两个表达式是等价的，否则，Idris 将失败并出现统一错误。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:363
#, no-wrap
msgid ""
"As an alternative to prefixing overloaded functions with their\n"
"namespace, we can use `the` to help with type inference:\n"
msgstr "作为使用名称空间作为重载函数前缀的替代方法，我们可以使用 `the` 来帮助进行类型推断：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:364
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) [10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) [10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:379
#, no-wrap
msgid ""
"It is interesting to note, that the error above is not \"Mismatch between: 2 and 3\"\n"
"but \"Mismatch between: 0 and 1\" instead. Here's what's going on: Idris tries to\n"
"unify integer literals `2` and `3`, which are first converted to the\n"
"corresponding `Nat` values `S (S Z)` and `S (S (S Z))`, respectively.\n"
"The two patterns match until we arrive at `Z` vs `S Z`, corresponding\n"
"to values `0` and `1`, which is the discrepancy reported in the error message.\n"
msgstr "有趣的是，上面的错误不是“不匹配：2 和 3”，而是“不匹配：0 和 1”。这是发生了什么：Idris 尝试统一整数字面量 `2` 和 `3`，它们首先转换为相应的 `Nat` 值 `S (S Z)[` 和 `S (S (S Z))`。这两个模式匹配，直到我们到达 `Z` vs `S Z`，对应于值 `0` 和 `1`，这是报告中报告的差异错误信息。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:380
#, no-wrap
msgid "Creating Vectors"
msgstr "创建向量"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:387
#, no-wrap
msgid ""
"So far, we were able to learn something about the lengths\n"
"of vectors by pattern matching on them. In the `Nil`\n"
"case, it was clear that the length is 0, while in the *cons*\n"
"case the length was the successor of another natural number.\n"
"This is not possible when we want to create a new vector:\n"
msgstr "到目前为止，我们能够通过对向量进行模式匹配来了解向量的长度。在 `Nil` 的情况下，很明显长度为 0，而在 *cons* 的情况下，长度是另一个自然数的后继。当我们要创建一个新向量时，这是不可能的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:388
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"
msgstr ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:395
#, no-wrap
msgid ""
"You will have a hard time implementing `fill`. The following,\n"
"for instance, leads to a type error:\n"
msgstr "您将很难实现 `fill`。例如，以下内容会导致类型错误：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:396
#, no-wrap
msgid "  fill va = [va,va]\n"
msgstr "  fill va = [va,va]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:403
#, no-wrap
msgid ""
"The problem is, that *the callers of our function decide about\n"
"the length of the resulting vector*. The full type of `fill` is\n"
"actually the following:\n"
msgstr "问题是，*我们函数的调用者决定了结果向量的长度*。 `fill`的完整类型其实如下：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:404
#, no-wrap
msgid "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"
msgstr "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:415
#, no-wrap
msgid ""
"You can read this type as follows: For every type `a` and for\n"
"every natural number `n` (about which I know *nothing* at runtime,\n"
"since it has quantity zero), given a value of type `a`, I'll give\n"
"you a vector holding exactly `n` elements of type `a`. This is\n"
"like saying: \"Think about a natural number `n`, and\n"
"I'll give you `n` apples without you telling me the value of `n`\".\n"
"Idris is powerful, but it is not a clairvoyant.\n"
msgstr "您可以按如下方式阅读此类型：对于每个类型 `a` 和每个自然数 `n` （我知道在运行时 *什么都没有* ，因为它的定量为零)，给定一个 `a` 类型的值，我会给你一个向量，它正好包含 `a` 类型的 `n` 个元素。这就像说：“想想一个自然数 `n`，我会给你 `n` 个苹果，而你却不告诉我 `n` 的值”。Idris 很强大，但不是千里眼。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:420
#, no-wrap
msgid ""
"In order to implement `fill`, we need to know what\n"
"`n` actually is: We need to pass `n` as an explicit, unerased argument, which\n"
"will allow us to pattern match on it and decide - based on this pattern\n"
"match - which constructors of `Vect` to use:\n"
msgstr "为了实现 `fill`，我们需要知道 `n` 实际上是什么：我们需要将 `n` 作为显式的、未擦除的参数传递，这将允许我们对其进行模式匹配并决定 - 基于此模式匹配 - 使用 `Vect` 的哪些构造函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:421
#, no-wrap
msgid "replicate : (n : Nat) -> a -> Vect n a\n"
msgstr "replicate : (n : Nat) -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:428
#, no-wrap
msgid ""
"Now, `replicate` is a *dependent function type*: The output type\n"
"*depends* on the value of one of the arguments. It is straight forward\n"
"to implement `replicate` by pattern matching on `n`:\n"
msgstr "现在，`replicate` 是一个 *依赖函数类型 *：输出类型 *取决于* 参数的一个值。通过 `n` 上的模式匹配来实现 `replicate` 很简单：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:429
#, no-wrap
msgid ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"
msgstr ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:443
#, no-wrap
msgid ""
"This is a pattern that comes up often when working with\n"
"indexed types: We can learn about the values of the indices\n"
"by pattern matching on the values of the type family. However,\n"
"in order to return a value of the type family from a function,\n"
"we need to either know the values of the indices at compile\n"
"time (see constants `ex1` or `ex3`, for instance), or we\n"
"need to have access to the values of the indices at runtime, in\n"
"which case we can pattern match on them and learn from\n"
"this, which constructor(s) of the type family to use.\n"
msgstr "这是使用索引类型时经常出现的模式：我们可以通过对类型族的值进行模式匹配来了解索引的值。但是，为了从函数返回类型族的值，我们需要在编译时知道索引的值（参见常量 `ex1` 或 `ex3`，例如)，或者我们需要在运行时访问索引的值，在这种情况下，我们可以对它们进行模式匹配并从中学习使用类型族的构造函数。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:447
#, no-wrap
msgid "Implement function `head` for non-empty vectors:\n"
msgstr "为非空向量实现函数 `head`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:448
#, no-wrap
msgid "   head : Vect (S n) a -> a\n"
msgstr "   head : Vect (S n) a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:457
#, no-wrap
msgid ""
"   Note, how we can describe non-emptiness by using a *pattern*\n"
"   in the length of `Vect`. This rules out the `Nil` case, and we can\n"
"   return a value of type `a`, without having to wrap it in\n"
"   a `Maybe`! Make sure to add an `impossible` clause for the `Nil`\n"
"   case (although this is not strictly necessary here).\n"
msgstr "   请注意，我们如何使用 *模式* 来描述在 `Vect` 的长度上的非空性。这排除了 `Nil` 的情况，我们可以返回一个 `a` 类型的值，而不必将其包装在一个`Maybe` 中！确保为 `Nil` 添加一个 `impossible` 子句分支（尽管这不是绝对必要的）。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:461
#, no-wrap
msgid ""
"Using `head` as a reference, declare and implement function `tail`\n"
"for non-empty vectors. The types should reflect that the output\n"
"is exactly one element shorter than the input.\n"
msgstr "以 `head` 为参考，为非空向量声明并实现函数 `tail`。类型应该反映输出恰好比输入短一个元素。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:464
#, no-wrap
msgid ""
"Implement `zipWith3`. If possible, try to doing so without looking at\n"
"the implementation of `zipWith`:\n"
msgstr "实现 `zipWith3`。如果可能，请尝试在不查看 `zipWith` 的实现的情况下这样做：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:465
#, no-wrap
msgid "   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d\n"
msgstr "   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:474
#, no-wrap
msgid ""
"Declare and implement a function `foldSemi`\n"
"for accumulating the values stored\n"
"in a `List` through `Semigroup`s append operator (`(<+>)`).\n"
"(Make sure to only use a `Semigroup` constraint, as opposed to\n"
"a `Monoid` constraint.)\n"
msgstr "声明并实现一个函数 `foldSemi` 用于通过 `Semigroup` 的附加运算符 (`(<+>)`) 累加存储在 `List` 中的值. （确保只使用 `Semigroup` 约束，而不是 `Monoid` 约束。）\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:477
#, no-wrap
msgid ""
"Do the same as in Exercise 4, but for non-empty vectors. How\n"
"does a vector's non-emptiness affect the output type?\n"
msgstr "做与练习 4 相同的操作，但对于非空向量。向量的非空性如何影响输出类型？\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:482
#, no-wrap
msgid ""
"Given an initial value of type `a` and a function `a -> a`,\n"
"we'd like to generate `Vect`s of `a`s, the first value of\n"
"which is `a`, the second value being `f a`, the third\n"
"being `f (f a)` and so on.\n"
msgstr "给定 `a` 类型的初始值和函数 `a -> a`，我们想生成 `a`s 的 `Vect`s ，其中第一个值为 `a`，第二个值为 `f a`，第三个值为 `f (fa)`，以此类推。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:485
#, no-wrap
msgid ""
"   For instance, if `a` is 1 and `f` is `(* 2)`, we'd like\n"
"   to get results similar to the following: `[1,2,4,8,16,...]`.\n"
msgstr ""
"   例如，如果 `a` 是 1 并且 `f` 是 `(* 2)`，我们希望\n"
"   获得类似于以下的结果：`[1,2,4,8,16,...]`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:489
#, no-wrap
msgid ""
"   Declare and implement function `iterate`, which should\n"
"   encapsulate this behavior. Get some inspiration from `replicate`\n"
"   if you don't know where to start.\n"
msgstr "   声明并实现函数 `iterate`，它应该封装这种行为。如果你不知道从哪里开始，可以从 `replicate` 中获得一些灵感。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:495
#, no-wrap
msgid ""
"Given an initial value of a state type `s` and\n"
"a function `fun : s -> (s,a)`,\n"
"we'd like to generate `Vect`s of `a`s. Declare and implement\n"
"function `generate`, which should encapsulate this behavior. Make sure to use\n"
"the updated state in every new invocation of `fun`.\n"
msgstr "给定状态类型 `s` 的初始值和函数 `fun : s -> (s,a)`，我们希望生成 `a` 的 `Vect`。声明并实现函数 `generate`，它应该封装这个行为。确保在每次新调用 `fun` 时使用更新后的状态。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:498
#, no-wrap
msgid ""
"   Here's an example how this can be used to generate the first\n"
"   `n` Fibonacci numbers:\n"
msgstr "   这是一个示例，它被用来生成前 `n` 个斐波那契数列：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:499
#, no-wrap
msgid ""
"   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
"   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
msgstr ""
"   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
"   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:507
#, no-wrap
msgid ""
"Implement function `fromList`, which converts a list of\n"
"values to a `Vect` of the same length. Use holes if you\n"
"get stuck:\n"
msgstr "实现函数 `fromList`，它将值列表转换为相同长度的 `Vect`。如果卡住，请使用孔：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:508
#, no-wrap
msgid "   fromList : (as : List a) -> Vect (length as) a\n"
msgstr "   fromList : (as : List a) -> Vect (length as) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:515
#, no-wrap
msgid ""
"   Note how, in the type of `fromList`, we can *calculate* the\n"
"   length of the resulting vector by passing the list argument\n"
"   to function *length*.\n"
msgstr "   请注意，在 `fromList` 的类型中，我们如何通过 `length` 函数*计算* list 参数得到向量的长度。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Dependent.md:517
#, no-wrap
msgid "Consider the following declarations:\n"
msgstr "考虑以下声明：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:518
#, no-wrap
msgid ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"
msgstr ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:526
#, no-wrap
msgid ""
"   Choose a reasonable implementation for `maybeSize` and\n"
"   implement `fromMaybe` afterwards.\n"
msgstr ""
"   为 `maybeSize` 选择一个合理的实现，\n"
"   然后执行 `fromMaybe` 。\n"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:527
#, no-wrap
msgid "`Fin`: Safe Indexing into Vectors"
msgstr "`Fin`：向量的安全索引"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:531
#, no-wrap
msgid ""
"Consider function `index`, which tries to extract a value from\n"
"a `List` at the given position:\n"
msgstr "考虑函数 `index`，它试图从给定位置的 `List` 中提取一个值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:532
#, no-wrap
msgid ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"
msgstr ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:553
#, no-wrap
msgid ""
"Now, here is a thing to consider when writing functions like `indexList`:\n"
"Do we want to express the possibility of failure in the output type,\n"
"or do we want to restrict the accepted arguments,\n"
"so the function can no longer fail? These are important design decisions,\n"
"especially in larger applications.\n"
"Returning a `Maybe` or `Either` from a function forces client code to eventually\n"
"deal with the `Nothing` or `Left` case, and until this happens, all intermediary\n"
"results will carry the `Maybe` or `Either` stain, which will make it more\n"
"cumbersome to run calculations with these intermediary results.\n"
"On the other hand, restricting the\n"
"values accepted as input will complicate the argument types\n"
"and will put the burden of input validation on our functions' callers,\n"
"(although, at compile time we can get help from Idris, as we will\n"
"see when we talk about auto implicits) while keeping the output pure and clean.\n"
msgstr "现在，在编写 `indexList` 之类的函数时要考虑的一点是：我们是要表达输出类型失败的可能性，还是要限制接受的参数，所以函数不能再失败？这些都是重要的设计决策，尤其是在较大的应用程序中。从函数返回 `Maybe` 或 `Either` 会强制客户端代码最终处理 `Nothing` 或 `Left` 情况，直到发生这种情况，所有中间结果都将带有 `Maybe` 或 `Either` 污点，这将使使用这些中间结果运行计算变得更加麻烦。另一方面，限制作为输入接受的值会使参数类型复杂化，并将输入验证的负担放在我们函数的调用者身上，（尽管在编译时我们可以从 Idris 获得帮助，正如我们将在讨论时看到的那样关于自动隐式），同时保持输出纯净和干净。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:558
#, no-wrap
msgid ""
"Languages without dependent types (like Haskell), can often only take\n"
"the route described above: To wrap the result in a `Maybe` or `Either`.\n"
"However, in Idris we can often *refine* the input types to restrict the\n"
"set of accepted values, thus ruling out the possibility of failure.\n"
msgstr "没有依赖类型的语言（如 Haskell）通常只能采用上述路线：将结果包装在 `Maybe` 或 `Either` 中。但是，在 Idris 中，我们通常可以 *细化* 输入类型以限制接受值的集合，从而排除失败的可能性。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:564
#, no-wrap
msgid ""
"Assume, as an example, we'd like to extract a value from a `Vect n a`\n"
"at (zero-based) index `k`. Surely, this can succeed if and only if\n"
"`k` is a natural number strictly smaller than the length `n` of\n"
"the vector. Luckily, we can express this precondition in an indexed\n"
"type:\n"
msgstr "假设，作为一个例子，我们想从 `Vect n a` 的（从零开始的）索引 `k` 处的中提取一个值。当然，当且仅当 `k` 是一个严格小于向量长度 `n` 的自然数时，这才能成功。幸运的是，我们可以用索引类型来表达这个前提条件：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:565
#, no-wrap
msgid ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"
msgstr ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:577
#, no-wrap
msgid ""
"`Fin n` is the type of natural numbers strictly smaller than `n`.\n"
"It is defined inductively: `FZ` corresponds to natural number *zero*,\n"
"which, as can be seen in its type, is strictly smaller than\n"
"`S n` for any natural number `n`. `FS` is the inductive case:\n"
"If `k` is strictly smaller than `n` (`k` being of type `Fin n`),\n"
"then `FS k` is strictly smaller than `S n`.\n"
msgstr "`Fin n` 是严格小于 `n` 的自然数类型。它是归纳定义的：`FZ` 对应于自然数 *0*，从其类型中可以看出，对于任何自然数，`n` 都严格小于 `S n`。 `FS` 是归纳情况：如果 `k` 严格小于 `n` （`k` 属于 `Fin n` 类型)，则 `FS k` 严格小于 `S n`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:579
#, no-wrap
msgid "Let's come up with some values of type `Fin`:\n"
msgstr "让我们想出一些 `Fin` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:580
#, no-wrap
msgid ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"
msgstr ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:597
#, no-wrap
msgid ""
"Note, that there is no value of type `Fin 0`. We will learn\n"
"in a later session, how to express \"there is no value of type `x`\"\n"
"in a type.\n"
msgstr "请注意，没有 `Fin 0` 类型的值。我们将在后面的课程中学习，如何在类型中表达“没有类型 `x` 的值”。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:600
#, no-wrap
msgid ""
"Let us now check, whether we can use `Fin` to safely index\n"
"into a `Vect`:\n"
msgstr "现在让我们检查一下，是否可以使用 `Fin` 安全地索引到 `Vect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:601
#, no-wrap
msgid "index : Fin n -> Vect n a -> a\n"
msgstr "index : Fin n -> Vect n a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:607
#, no-wrap
msgid ""
"Before you continue, try to implement `index` yourself, making use\n"
"of holes if you get stuck.\n"
msgstr "在继续之前，请尝试自己实现 `index`，如果遇到困难，请充分利用孔。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:608
#, no-wrap
msgid ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"
msgstr ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:617
#, no-wrap
msgid ""
"Note, how there is no `Nil` case and the totality checker is still\n"
"happy. That's because `Nil` is of type `Vect 0 a`, but there is no\n"
"value of type `Fin 0`! We can verify this by adding the missing\n"
"impossible clauses:\n"
msgstr "请注意，如何没有 `Nil` 分支，并且总体检查器仍然很高兴。那是因为 `Nil` 的类型是 `Vect 0 a`，但是没有 `Fin 0` 类型的值！我们可以通过添加缺失的不可能子句来验证这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:618
#, no-wrap
msgid ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"
msgstr ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:627
#, no-wrap
msgid ""
"Implement function `update`, which, given a function of\n"
"type `a -> a`, updates the value in a`Vect n a` at position `k < n`.\n"
msgstr "实现函数 `update`，给定一个类型为 `a -> a` 的函数，在 `Vect n a` 中 `k < n` 处的位置更新值。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:631
#, no-wrap
msgid ""
"Implement function `insert`, which inserts a value of type `a`\n"
"at position `k <= n` in a `Vect n a`. Note, that `k` is the\n"
"index of the freshly inserted value, so that the following holds:\n"
msgstr "实现函数 `insert`，它在 `Vect n a` 中的 `k <= n` 位置插入 `a` 类型的值。请注意，`k` 是新插入值的索引，因此以下成立：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:632
#, no-wrap
msgid "   index k (insert k v vs) = v\n"
msgstr "   index k (insert k v vs) = v\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:638
#, no-wrap
msgid ""
"Implement function `delete`, which deletes a value from a\n"
"vector at the given index.\n"
msgstr "实现函数 `delete`，它从向量中的给定索引处删除一个值。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:641
#, no-wrap
msgid ""
"   This is trickier than Exercises 1 and 2, as we have to properly\n"
"   encode in the types that the vector is getting one element shorter.\n"
msgstr "   这比练习 1 和练习 2 更棘手，因为我们必须正确编码向量正在缩短一个元素的类型。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:644
#, no-wrap
msgid ""
"We can use `Fin` to implement safe indexing into `List`s as well. Try to\n"
"come up with a type and implementation for `safeIndexList`.\n"
msgstr "我们也可以使用 `Fin` 来实现对 `List` 的安全索引。尝试为 `safeIndexList` 提出一个类型和实现。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:648
#, no-wrap
msgid ""
"   Note: If you don't know how to start, look at the type of `fromList`\n"
"   for some inspiration. You might also need give the arguments in\n"
"   a different order than for `index`.\n"
msgstr "   注意：如果不知道怎么下手，看`fromList`的类型找一些灵感。您可能还需要与 `index`  不同的顺序给出参数。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:653
#, no-wrap
msgid ""
"Implement function `finToNat`, which converts a `Fin n` to the\n"
"corresponding natural number, and use this to declare and\n"
"implement function `take` for splitting of the first `k`\n"
"elements of a `Vect n a` with `k <= n`.\n"
msgstr "实现函数 `finToNat`，将一个`Fin n`转换为对应的自然数，并用它来声明和实现函数 `take` ，通过对 `Vect n a` 的前 `k` 个元素进行拆分 ，其中 `k <= n`。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:656
#, no-wrap
msgid ""
"Implement function `minus` for subtracting a value `k` from\n"
"a natural number `n` with `k <= n`.\n"
msgstr "实现函数 `minus` 用于从 `k <= n` 的自然数 `n` 中减去值 `k`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:660
#, no-wrap
msgid ""
"Use `minus` from Exercise 6 to declare and implement function\n"
"`drop`, for dropping the first `k` values from a `Vect n a`,\n"
"with `k <= n`.\n"
msgstr "使用练习 6 中的 `minus` 声明和实现函数 `drop`，用于从 `Vect n a` 中删除第一个 `k` 值，其中 `k <= n`。\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:664
#, no-wrap
msgid ""
"Implement function `splitAt` for splitting a `Vect n a` at\n"
"position `k <= n`, returning the prefix and suffix of the\n"
"vector wrapped in a pair.\n"
msgstr "实现函数 `splitAt` 用于在位置 `k <= n` 处拆分 `Vect n a`，返回包装成对的向量的前缀和后缀。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:666
#, no-wrap
msgid "   Hint: Use `take` and `drop` in your implementation.\n"
msgstr "   提示：在你的实现中使用 `take` 和 `drop`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:670
#, no-wrap
msgid ""
"Hint: Since `Fin n` consists of the values strictly smaller\n"
"than `n`, `Fin (S n)` consists of the values smaller than\n"
"or equal to `n`.\n"
msgstr "提示：由于 `Fin n` 由严格小于 `n` 的值组成，因此 `Fin (S n)` 由小于或等于 `n 的值组成`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:675
#, no-wrap
msgid ""
"Note: Functions `take`, `drop`, and `splitAt`, while correct and\n"
"provably total, are rather cumbersome to type.\n"
"There is an alternative way to declare their types,\n"
"as we will see in the next section.\n"
msgstr "注意：函数 `take`、`drop` 和 `splitAt` 虽然正确且可证明是完全的，但键入起来相当麻烦。正如我们将在下一节中看到的，还有另一种声明它们的类型的方法。\n"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:676
#, no-wrap
msgid "Compile-Time Computations"
msgstr "编译时计算"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:683
#, no-wrap
msgid ""
"In the last section - especially in some of the exercises - we\n"
"started more and more to use compile time computations to\n"
"describe the types of our functions and values.\n"
"This is a very powerful concept, as it allows us to\n"
"compute output types from input types. Here's an example:\n"
msgstr "在上一节中——尤其是在一些练习中——我们开始越来越多地使用编译时计算来描述函数和值的类型。这是一个非常强大的概念，因为它允许我们根据输入类型计算输出类型。这是一个例子：\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:690
#, no-wrap
msgid ""
"It is possible to concatenate two `List`s with the `(++)`\n"
"operator. Surely, this should also be possible for\n"
"`Vect`. But `Vect` is indexed by its length, so we have\n"
"to reflect in the types exactly how the lengths of the\n"
"inputs affect the lengths of the output. Here's how to\n"
"do this:\n"
msgstr "可以使用 `(++)` 运算符连接两个 `List`。当然，这对于 `Vect` 也应该是可能的。但是 `Vect` 是由它的长度索引的，所以我们必须在类型中准确地反映输入的长度如何影响输出的长度。以下是如何执行此操作：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:691
#, no-wrap
msgid ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"
msgstr ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:700
#, no-wrap
msgid ""
"Note, how we keep track of the lengths at the type-level, again\n"
"ruling out certain common programming errors like inadvertently dropping\n"
"some values.\n"
msgstr "请注意，我们如何在类型级别跟踪长度，再次排除某些常见的编程错误，例如无意中删除某些值。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:705
#, no-wrap
msgid ""
"We can also use type-level computations as patterns\n"
"on the input types. Here is an alternative type and implementation\n"
"for `drop`, which you implemented in the exercises by\n"
"using a `Fin n` argument:\n"
msgstr "我们还可以使用类型级计算作为输入类型的模式。这是 `drop` 的另一种类型和实现，您在练习中使用 `Fin n` 参数实现了它：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:706
#, no-wrap
msgid ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"
msgstr ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:712
#, no-wrap
msgid "Limitations"
msgstr "限制"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:718
#, no-wrap
msgid ""
"After all the examples and exercises in this section\n"
"you might have come to the conclusion that we can\n"
"use arbitrary expressions in the types and Idris\n"
"will happily evaluate and unify all of them for us.\n"
msgstr "在本节中的所有示例和练习之后，您可能已经得出结论，我们可以在类型中使用任意表达式，并且 Idris 会很乐意为我们评估和统一所有这些表达式。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:724
#, no-wrap
msgid ""
"I'm afraid that's not even close to the truth. The examples\n"
"in this section were hand-picked because they are known\n"
"to *just work*. The reason being, that there was always\n"
"a direct link between our own pattern matches and the\n"
"implementations of functions we used at compile time.\n"
msgstr "恐怕这甚至不接近事实。本节中的示例是精心挑选的，因为它们已知 *可以正常工作*。原因是，我们自己的模式匹配和我们在编译时使用的函数的实现之间总是存在直接联系。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:727
#, no-wrap
msgid ""
"For instance, here is the implementation of addition of\n"
"natural numbers:\n"
msgstr "例如，这里是自然数加法的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:728
#, no-wrap
msgid ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"
msgstr ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:745
#, no-wrap
msgid ""
"As you can see, `add` is implemented via a pattern match\n"
"on its *first* argument, while the second argument is never\n"
"inspected. Note, how this is exactly how `(++)` for `Vect`\n"
"is implemented: There, we also pattern match on the first\n"
"argument, returning the second unmodified in the `Nil`\n"
"case, and prepending the head to the result of appending\n"
"the tail in the *cons* case. Since there is a direct\n"
"correspondence between the two pattern matches, it\n"
"is possible for Idris to unify `0 + n` with `n` in the\n"
"`Nil` case, and `(S k) + n` with `S (k + n)` in the\n"
"*cons* case.\n"
msgstr "如您所见， `add` 是通过对其 *第一个* 参数的模式匹配来实现的，而第二个参数从未被检查过。请注意，这正是 `(++)` 在 `Vect` 上的实现方式：在那里，我们还对第一个参数进行模式匹配，在 `Nil` 分支中返回未修改的第二个参数，并将头部添加到 *cons* 分支中追加尾部的结果。由于两个模式匹配之间存在直接对应关系，因此 Idris 可以在 `Nil` 的情况下将 `0 + n` 与 `n` 统一起来，而在 *cons* 的情况下 `(S k) + n` 与 `S (k + n)` 统一起来。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:748
#, no-wrap
msgid ""
"Here is a simple example, where Idris will not longer\n"
"be convinced without some help from us:\n"
msgstr "这是一个简单的例子，如果没有我们的帮助，Idris 将不再相信：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:749
#, no-wrap
msgid ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"
msgstr ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:768
#, no-wrap
msgid ""
"When we type-check the above,\n"
"Idris will fail with the following error message:\n"
"\"Can't solve constraint between: plus n 1 and S n.\"\n"
"Here's what's going on: From the pattern match on the\n"
"left hand side, Idris knows that the length of the\n"
"vector is `S n`, for some natural number `n`\n"
"corresponding to the length of `xs`. The length\n"
"of the vector on the right hand side is `n + 1`,\n"
"according to the type of `(++)` and the lengths\n"
"of `xs` and `[x]`. Overloaded operator `(+)`\n"
"is implemented via function `Prelude.plus`, that's\n"
"why Idris replaces `(+)` with `plus` in the error message.\n"
msgstr "当我们对上述内容进行类型检查时，Idris 将失败并显示以下错误消息：“无法解决之间的约束：加plus n 1 和 S n。”这是发生了什么：从左侧的模式匹配中，Idris 知道向量的长度是 `S n`，对于某个自然数 `n` 对应于 `xs`。右边向量的长度是`n + 1`，根据 `(++)` 的类型和 `xs` 和 `[x]` 的长度。重载运算符 `(+)` 是通过函数 `Prelude.plus` 实现的，这就是 Idris 在错误消息中将 `(+)` 替换为 `plus` 的原因.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:780
#, no-wrap
msgid ""
"As you can see from the above, Idris can't verify on\n"
"its own that `1 + n` is the same thing as `n + 1`.\n"
"It can accept some help from us, though. If we come\n"
"up with a *proof* that the above equality holds\n"
"(or - more generally - that our implementation of\n"
"addition for natural numbers is *commutative*),\n"
"we can use this proof to *rewrite* the types on\n"
"the right hand side of `reverse`. Writing proofs and\n"
"using `rewrite` will require some in-depth explanations\n"
"and examples. Therefore, these things will have to wait\n"
"until another chapter.\n"
msgstr "从上面可以看出，Idris 自己无法验证 `1 + n` 与 `n + 1` 是一回事。不过，它可以接受我们的一些帮助。如果我们提出上述等式成立的 *证明*（或者更一般地说，我们对自然数加法的实现是 *可交换的*），我们可以将此证明用于 *重写* `reverse` 右侧的类型。编写证明和使用 `rewrite` 需要一些深入的解释和示例。所以，这些事情还得等到下一章再说。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:781
#, no-wrap
msgid "Unrestricted Implicits"
msgstr "不受限制的隐式"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:789
#, no-wrap
msgid ""
"In functions like `replicate`, we pass a natural number `n`\n"
"as an explicit, unrestricted argument from which we infer\n"
"the length of the vector to return.\n"
"In some circumstances, `n` can be inferred from the context.\n"
"For instance, in the following example it is tedious to\n"
"pass `n` explicitly:\n"
msgstr "在像 `replicate` 这样的函数中，我们传递一个自然数 `n` 作为一个明确的、不受限制的参数，我们从中推断要返回的向量的长度。在某些情况下，可以从上下文中推断出 `n`。例如，在以下示例中，显式传递 `n` 是很乏味的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:790
#, no-wrap
msgid ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"
msgstr ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:797
#, no-wrap
msgid ""
"The value `n` is clearly derivable from the context, which\n"
"can be confirmed by replacing it with underscores:\n"
msgstr "`n` 的值显然可以从上下文中推导出来，可以通过将其替换为下划线来确认：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:798
#, no-wrap
msgid ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"
msgstr ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:806
#, no-wrap
msgid ""
"We therefore can implement an alternative version of `replicate`,\n"
"where we pass `n` as an implicit argument of *unrestricted*\n"
"quantity:\n"
msgstr "因此，我们可以实现 `replicate` 的替代版本，其中我们将 `n` 作为 *无限制* 定量的隐式参数传递：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:807
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"
msgstr ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:814
#, no-wrap
msgid ""
"Note how, in the implementation of `replicate'`, we can refer to `n`\n"
"and pass it as an explicit argument to `replicate`.\n"
msgstr "请注意，在 `replicate'` 的实现中，我们可以引用 `n` 并将其作为显式参数传递给 `replicate`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:820
#, no-wrap
msgid ""
"Deciding whether to pass potentially inferable arguments to a function implicitly\n"
"or explicitly is a question of how often the arguments actually *are* inferable\n"
"by Idris. Sometimes it might even be useful to have both versions\n"
"of a function. Remember, however, that even in case of an implicit argument\n"
"we can still pass the value explicitly:\n"
msgstr "决定是否将潜在的可推断参数隐式或显式传递给函数是一个问题，即 Idris 实际 *是* 可推断参数的使用频率。有时，同时拥有一个函数的两个版本甚至可能很有用。但是请记住，即使是隐式参数，我们仍然可以显式传递值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:821
#, no-wrap
msgid ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"
msgstr ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:829
#, no-wrap
msgid ""
"In the type signature above, the question mark (`?`) means, that Idris\n"
"should try and figure out the value on its own by unification. This\n"
"forces us to specify `n` explicitly on the right hand side of `ex6`.\n"
msgstr "在上面的类型签名中，问号 (`?`) 的意思是，Idris 应该尝试通过统一自己找出值。这迫使我们在 `ex6` 的右侧明确指定 `n`。\n"

#. type: Title ####
#: ../src/Tutorial/Dependent.md:830
#, no-wrap
msgid "Pattern Matching on Implicits"
msgstr "隐式模式匹配"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:836
#, no-wrap
msgid ""
"The implementation of `replicate'` makes use of function `replicate`,\n"
"where we could pattern match on the explicit argument `n`. However, it\n"
"is also possible to pattern match on implicit, named arguments of\n"
"non-zero quantity:\n"
msgstr "`replicate'` 的实现使用了函数 `replicate`，我们可以在显式参数 `n` 上进行模式匹配。但是，也可以对非零数量的隐式命名参数进行模式匹配：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:837
#, no-wrap
msgid ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"
msgstr ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:846
#, no-wrap
msgid "Here is a function declaration for flattening a `List` of `List`s:\n"
msgstr "这是一个用于扁平化 `List` 中的 `List` 的函数声明：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:847
#, no-wrap
msgid "   flattenList : List (List a) -> List a\n"
msgstr "   flattenList : List (List a) -> List a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:853
#, no-wrap
msgid ""
"   Implement `flattenList` and declare and implement a similar\n"
"   function `flattenVect` for flattening vectors of vectors.\n"
msgstr "   实现 `flattenList` 并声明和实现一个类似的函数 `flattenVect` 用于扁平化向量的向量。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:857
#, no-wrap
msgid ""
"Implement functions `take'` and `splitAt'` like in\n"
"the exercises of the previous section but using the\n"
"technique shown for `drop'`.\n"
msgstr "像上一节的练习一样实现函数 `take'` 和 `splitAt'`，但使用 `drop'` 所示的技术。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:861
#, no-wrap
msgid ""
"Implement function `transpose` for converting an\n"
"`m x n`-matrix (represented as a `Vect m (Vect n a)`)\n"
"to an `n x m`-matrix.\n"
msgstr "实现函数 `transpose` 用于将 `m x n` 矩阵（表示为 `Vect m (Vect n a)`）转换为 `n x m` 矩阵。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:864
#, no-wrap
msgid ""
"   Note: This might be a challenging exercise, but make sure\n"
"   to give it a try. As usual, make use of holes if you get stuck!\n"
msgstr "   注意：这可能是一项具有挑战性的练习，但请确保试一试。像往常一样，如果你被卡住了，就利用洞！\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:866
#, no-wrap
msgid "   Here is an example how this should work in action:\n"
msgstr "   这是一个示例，它应该如何在行动中发挥作用：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:867
#, no-wrap
msgid ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"
msgstr ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:878
#, no-wrap
msgid ""
"Dependent types allow us to calculate types from values.\n"
"This makes it possible to encode properties of values\n"
"at the type-level and verify these properties at compile\n"
"time.\n"
msgstr "依赖类型允许我们根据值计算类型。这使得在类型级别对值的属性进行编码并在编译时验证这些属性成为可能。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:882
#, no-wrap
msgid ""
"Length-indexed lists (vectors) let us rule out certain implementation\n"
"errors, by forcing us to be precise about the lengths of input\n"
"and output vectors.\n"
msgstr "长度索引列表（向量）通过强制我们准确了解输入和输出向量的长度，让我们排除了某些实现错误。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:886
#, no-wrap
msgid ""
"We can use patterns in type signatures, for instance to\n"
"express that the length of a vector is non-zero and therefore,\n"
"the vector is non-empty.\n"
msgstr "我们可以在类型签名中使用模式，例如表示向量的长度非零，因此向量非空。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:891
#, no-wrap
msgid ""
"When creating values of a type family, the values of the indices\n"
"need to be known at compile time, or they need to be passed as\n"
"arguments to the function creating the values, where we can\n"
"pattern match on them to figure out, which constructors to use.\n"
msgstr "创建类型族的值时，索引的值需要在编译时知道，或者它们需要作为参数传递给创建值的函数，我们可以对它们进行模式匹配以确定哪些构造函数利用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:894
#, no-wrap
msgid ""
"We can use `Fin n`, the type of natural numbers strictly smaller\n"
"than `n`, to safely index into a vector of length `n`.\n"
msgstr "我们可以使用严格小于 `n` 的自然数类型 `Fin n` 来安全地索引长度为 `n` 的向量。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:899
#, no-wrap
msgid ""
"Sometimes, it is convenient to pass inferable arguments as\n"
"non-erased implicits, in which case we can still inspect them\n"
"by pattern matching or pass them to other functions, while Idris\n"
"will try and fill in the values for us.\n"
msgstr "有时，将可推断参数作为非擦除隐式传递很方便，在这种情况下，我们仍然可以通过模式匹配检查它们或将它们传递给其他函数，而 Idris 会尝试为我们填充值。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:903
#, no-wrap
msgid ""
"Note, that data type `Vect` together with many of the functions we\n"
"implemented here is available from module `Data.Vect` from the *base*\n"
"library. Likewise, `Fin` is available from `Data.Fin` from *base*.\n"
msgstr "请注意，数据类型 `Vect` 以及我们在此处实现的许多功能可从 *base* 库中的模块 `Data.Vect` 获得。同样，`Fin` 可从 `Data.Fin` 从 *base* 获得。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:908
#, no-wrap
msgid ""
"In the [next section](IO.md), it is time to learn how to write effectful programs\n"
"and how to do this while still staying *pure*.\n"
msgstr "在 [next section](IO.md) 中，是时候学习如何编写有效的程序以及如何在保持 * 纯 * 的同时做到这一点。\n"
