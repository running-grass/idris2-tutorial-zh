# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, fuzzy, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"

#. type: Title #
#: ../src/Appendices/Neovim.md:1
#, no-wrap
msgid "Interactive Editing in Neovim"
msgstr "Neovim 中的交互式编辑"

#. type: Plain text
#: ../src/Appendices/Neovim.md:10
#, no-wrap
msgid ""
"Idris provides extensive capabilities to interactively\n"
"analyze the types of values and expressions in our programs\n"
"and fill out skeleton implementations and sometimes even whole\n"
"programs for us based on the types provided. These interactive\n"
"editing features are available via plugins in different editors.\n"
"Since I am a Neovim user, I explain the Idris related parts of\n"
"my own setup in detail here.\n"
msgstr ""
"Idris 提供了广泛的交互功能\n"
"来分析我们程序中的值和表达式的类型\n"
"并填写骨架实现，有时甚至根据提供的类型为我们提供完整的的程序。这些交互\n"
"编辑功能可通过不同编辑器中的插件获得。\n"
"由于我是 Neovim 用户，我会详细解释一下我自己的设置中 Idris 的相关部分。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:20
#, no-wrap
msgid ""
"The main component required to get all these features to run\n"
"in Neovim is an executable provided by the\n"
"[idris2-lsp](https://github.com/idris-community/idris2-lsp) project.\n"
"This executable makes use of the Idris compiler API (application\n"
"programming interface) internally and can check the syntax and\n"
"types of the source code we are working on. It communicates with\n"
"Neovim via the language server protocol (LSP). This communication\n"
"is setup through the [idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
"plugin.\n"
msgstr ""
"Neovim 中运行所有这些功能所需的主要组件是由 [idris2-lsp](https://github.com/idris-community/idris2-lsp) 项目提供的可执行文件。\n"
"此可执行文件内部使用 Idris 编译器 API（应用程序编程接口），可以检查语法和\n"
"我们正在处理的源代码的类型。它与\n"
"Neovim 通过语言服务器协议 (LSP)。这种沟通由 [idris2-nvim](https://github.com/ShinKage/idris2-nvim) \n"
"插件来完成 。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:31
#, no-wrap
msgid ""
"As we will see in this tutorial, the `idris2-lsp` executable not only\n"
"supports syntax and type checking, but comes also with additional\n"
"interactive editing features. Finally, the Idris compiler API supports\n"
"semantic highlighting of Idris source code: Identifiers and keywords\n"
"are highlighted not only based on the language's syntax (that would\n"
"be *syntax highlighting*, a feature expected from all modern\n"
"programming environments and editors), but also based on their\n"
"*semantics*. For instance, a local variable in a function implementation\n"
"gets highlighted differently than the name of a top level function,\n"
"although syntactically these are both just identifiers.\n"
msgstr ""
"正如我们将在本教程中看到的，`idris2-lsp` 可执行文件不仅\n"
"支持语法和类型检查，但还附带额外的\n"
"交互式编辑功能。最后，Idris 编译器 API 支持\n"
"Idris 源代码的语义高亮：标识符和关键字\n"
"突出显示不仅基于语言的语法（这将\n"
"成为 *语法高亮*，所有现代编程环境和编辑器都预期会有的功能），也基于它们的\n"
"*语义*。例如，函数实现中的局部变量\n"
"以不同于顶级函数名称的方式突出显示，\n"
"尽管从语法上讲，它们都只是标识符。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:32
#, no-wrap
msgid ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:40
#, no-wrap
msgid "Setup"
msgstr "设置"

#. type: Plain text
#: ../src/Appendices/Neovim.md:44
#, no-wrap
msgid ""
"In order to make full use of interactive Idris editing in\n"
"Neovim, at least the following tools need to be installed:\n"
msgstr ""
"为了充分利用交互式 Idris 编辑\n"
"Neovim，至少需要安装以下工具：\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "A recent version of Neovim (version 0.5 or later).\n"
msgstr "Neovim 的最新版本（0.5 版或更高版本）。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "A recent version of the Idris compiler (at least version 0.5.1).\n"
msgstr "Idris 编译器的最新版本（至少版本 0.5.1）。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "The Idris compiler API.\n"
msgstr "Idris 编译器 API。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "The [idris2-lsp](https://github.com/idris-community/idris2-lsp) package.\n"
msgstr "[idris2-lsp](https://github.com/idris-community/idris2-lsp) 包。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "The following Neovim plugins:\n"
msgstr "以下 Neovim 插件：\n"

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "[idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
msgstr "[idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n"
msgstr "[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:57
#, no-wrap
msgid ""
"The `idris2-lsp` project gives detailed instructions about how\n"
"to install Idris 2 together with its standard libraries and compiler\n"
"API. Make sure to follow these instructions so that your compiler\n"
"and `idris2-lsp` executable are in sync.\n"
msgstr ""
"`idris2-lsp` 项目提供了有关如何使用的详细说明\n"
"安装 Idris 2 及其标准库和编译器\n"
"API。确保遵循这些说明，以便您的编译器和 `idris2-lsp` 可执行文件是同步的。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:67
#, no-wrap
msgid ""
"If you are new to Neovim, you might want to use the `init.vim`\n"
"file provided in the `resources` folder. In that case, the\n"
"necessary Neovim plugins are already included, but you need to install\n"
"[vim-plug](https://github.com/junegunn/vim-plug), a plugin manager.\n"
"Afterwards, copy all or parts of `resources/init.vim` to your own `init.vim`\n"
"file. (Use `:help init.vim` from within Neovim in order to find\n"
"out where to look for this file.). After setting up your `init.vim`\n"
"file, restart Neovim and run `:PlugUpdate` to install the\n"
"necessary plugins.\n"
msgstr ""
"如果你是 Neovim 的新手，你可能想要使用 `resource` 文件夹中提供的 `init.vim` 文件。在这种情况下，\n"
"已经包含了必要的 Neovim 插件，但您需要安装\n"
"[vim-plug](https://github.com/junegunn/vim-plug)，一个插件管理器。\n"
"之后，将 `resources/init.vim` 的全部或部分复制到你自己的 `init.vim`\n"
"文件。 （在 Neovim 中使用 `:help init.vim` 来查找\n"
"在哪里可以找到这个文件。）。设置好 `init.vim` 文件后，重启 Neovim 并运行 `:PlugUpdate` 安装\n"
"必要的插件。\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:68
#, no-wrap
msgid "A Typical Workflow"
msgstr "常见的工作流程"

#. type: Plain text
#: ../src/Appendices/Neovim.md:77
#, no-wrap
msgid ""
"In order to checkout the interactive editing features\n"
"available to us, we will reimplement some small utilities\n"
"from the *Prelude*. To follow along, you should have\n"
"already worked through the [Introduction](../Tutorial/Intro.md),\n"
"[Functions Part 1](../Tutorial/Functions1.md), and at least\n"
"parts of [Algebraic Data Types](../Tutorial/DataTypes.md), otherwise\n"
"it will be hard to understand what's going on here.\n"
msgstr ""
"为了检查可供我们使用的交互式编辑功能\n"
"，我们将重新实现一些来自 *Prelude* 的小型实用程序。跟随我到这一步，你应该已经完成了[介绍](../Tutorial/Intro.md)，\n"
"[函数第 1 部分](../Tutorial/Functions1.md)，并且至少\n"
"[代数数据类型](../Tutorial/DataTypes.md) 的一部分，否则很难理解这里发生了什么。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:83
#, no-wrap
msgid ""
"Before we begin, note that the commands and actions shown in this\n"
"tutorial might not work correctly after you edited a source file\n"
"but did not write your changes to disk. Therefore, the first thing\n"
"you should try if the things described here do not work, is to\n"
"quickly save the current file (`:w`).\n"
msgstr ""
"在开始之前，请注意这里显示的命令和操作在编辑源文件后教程可能无法正常工作\n"
"引用没有将您的更改写入磁盘。因此，第一件事是\n"
"如果这里描述的东西不起作用，你应该尝试，快速保存当前文件（`:w`）。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:85
#, no-wrap
msgid "Let's start with negation of a boolean value:\n"
msgstr "让我们从布尔值的否定开始：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:86
#, no-wrap
msgid "negate1 : Bool -> Bool\n"
msgstr "negate1 : Bool -> Bool\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:102
#, no-wrap
msgid ""
"Typically, when writing Idris code we follow the mantra\n"
"\"types first\". Although you might already have an idea about\n"
"how to implement a certain piece of functionality, you still\n"
"need to provide an accurate type before you can start writing\n"
"your implementation. This means, when programming in Idris, we have\n"
"to mentally keep track of the implementation of an algorithm\n"
"and the types involved at the same time, both of which can\n"
"become arbitrarily complex. Or do we? Remember that Idris knows\n"
"at least as much about the variables and their types available\n"
"in the current context of a function implementation as we do,\n"
"so we probably should ask it for guidance instead of trying\n"
"to do everything on our own.\n"
msgstr "通常，在编写 Idris 代码时，我们遵循“类型优先”准则。虽然您可能已经知道如何实现某一功能，但在开始编写实现之前，仍然需要提供准确的类型。这意味着，在 Idris 中编程时，我们需要在脑海中跟踪算法的实现以及同时涉及的类型，两者都有可能会变得异常复杂。我们还可以吗？请记住，请记住，Idris 至少和我们一样了解当前函数实现上下文中可用的变量及其类型，因此我们可能应该向Idris寻求指导，而不是尝试自己做所有事情。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:112
#, no-wrap
msgid ""
"So, in order to proceed, we ask Idris for a skeleton function\n"
"body: In normal editor mode, move your cursor on the line where\n"
"`negate1` is declared and enter `<LocalLeader>a` in quick\n"
"succession. `<LocalLeader>` is a special key that can be specified\n"
"in the `init.vim` file. If you\n"
"use the `init.vim` from the `resources` folder, it is set to\n"
"the comma character (`,`), in which case the above command\n"
"consists of a comma quickly followed by the lowercase letter \"a\".\n"
"See also `:help leader` and `:help localleader` in Neovim\n"
msgstr ""
"所以，为了继续，我们向 Idris 请求一个骨架函数体：在普通编辑器模式下，将光标移动到 `negate1` 声明并快速输入 `<LocalLeader>a`。 `<LocalLeader>` 是可以在 `init.vim` 文件中指定的特殊键。如果你使用 `resources` 文件夹中的 `init.vim`，它被设置为\n"
"逗号字符 (`,`)，在这种情况下，上面的命令由一个逗号后跟小写字母“a”组成。\n"
"另见 Neovim 中的 `:help leader` 和 `:help localleader`\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:115
#, no-wrap
msgid ""
"Idris will generate a skeleton implementation similar to the\n"
"following:\n"
msgstr "Idris 将生成一个类似于下面的代码：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:116
#, no-wrap
msgid ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"
msgstr ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:139
#, no-wrap
msgid ""
"Note, that on the left hand side a new variable with name\n"
"`x` was introduced, while on the right hand side Idris\n"
"added a *metavariable* (also called a *hole*). This is an\n"
"identifier prefixed with a question mark. It signals to Idris,\n"
"that we will implement this part of the function at a later time.\n"
"The great thing about holes is, that we can *hover* over them\n"
"and inspect their types and the types of values in the\n"
"surrounding context. You can do so by placing the cursor\n"
"on the identifier of a hole and entering `K` (the uppercase letter) in\n"
"normal mode. This will open a popup displaying the type of\n"
"the variable under the cursor plus the types and quantities of the variables\n"
"in the surrounding context. You can also have this information\n"
"displayed in a separate window: Enter `<LocalLeader>so` to\n"
"open this window and repeat the hovering. The information will\n"
"appear in the new window and as an additional benefit, it will\n"
"be semantically highlighted. Enter `<LocalLeader>sc` to close\n"
"this window again. Go ahead and checkout the type and\n"
"context of `?negate2_rhs`.\n"
msgstr ""
"请注意，在左边有一个名称为 `x` 的新变量被引入，而在右边 Idris 添加了一个*元变量*（也称为*孔*）。这是个\n"
"以问号为前缀的标识符。它向 Idris 发出信号，\n"
"我们将在稍后实现函数的这一部分。\n"
"孔的好处在于，我们可以*悬停*来检查它们的类型和上下文中所有值的类型。在正常模式下，您可以通过放置光标在孔的标识符上然后输入 `K`（大写字母）来做到。这将打开一个弹窗，显示光标下的变量类型和上下文中变量的类型和定量。你也可以让这些信息在单独的窗口中显示：输入 `<LocalLeader>so` 以打开此窗口并重复悬停。该信息将\n"
"出现在新窗口中，作为额外的好处，它将在语义上突出显示。输入`<LocalLeader>sc`关闭这个窗口。继续检查`?negate2_rhs` 的类型和上下文。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:148
#, no-wrap
msgid ""
"Most functions in Idris are implemented by pattern matching\n"
"on one or more of the arguments. Idris,\n"
"knowing the data constructors of all non-primitive data types,\n"
"can write such pattern matches for us (a process also called\n"
"*case splitting*). To give this a try, move the cursor onto the `x`\n"
"in the skeleton implementation of `negate2`, and enter\n"
"`<LocalLeader>c` in normal mode. The result will look as\n"
"follows:\n"
msgstr ""
"Idris 中的大部分函数都是通过模式匹配一个或多个参数实现的。\n"
"Idris 了解所有非原语数据类型的数据构造函数，\n"
"可以为我们编写这样的模式匹配（这个过程也称为*案例拆分*）。要尝试一下，请将光标移动到在`negate2`的骨架实现中的 `x` 上，在常规模式下输入 `<LocalLeader>c` 。结果将如下所示\n"
"如下：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:149
#, no-wrap
msgid ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"
msgstr ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:158
#, no-wrap
msgid ""
"As you can see, Idris inserted a hole for each of the cases on the\n"
"right hand side. We can again inspect their types or\n"
"replace them with a proper implementation directly.\n"
msgstr "如您所见，Idris 为每个情况的右侧插入了一个孔。我们可以再次检查它们的类型或直接用适当的实现替换它们。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:164
#, no-wrap
msgid ""
"This concludes the introduction of the (in my opinion) core\n"
"features of interactive editing: Hovering on metavariables,\n"
"adding skeleton function implementations, and case splitting\n"
"(which also works in case blocks and for nested pattern\n"
"matches). You should start using these all the time *now*!\n"
msgstr ""
"（在我看来）对于交互式编辑的核心特点的介绍到此结束：悬停在元变量上，\n"
"添加骨架函数实现和案例拆分\n"
"（这也适用于案例块和嵌套模式匹配）。你应该开始使用这些 *now*！\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:165
#, no-wrap
msgid "Expression Search"
msgstr "表达式搜索"

#. type: Plain text
#: ../src/Appendices/Neovim.md:173
#, no-wrap
msgid ""
"Sometimes, Idris knows enough about the types involved to\n"
"come up with a function implementation on its own. For instance,\n"
"let us implement function `either` from the *Prelude*.\n"
"After giving its type, creating a skeleton implementation,\n"
"and case splitting on the `Either` argument, we arrive at\n"
"something similar to the following:\n"
msgstr ""
"有时，Idris 对所涉及的类型有足够的了解但能自己想出一个函数的实现。例如，让我们实现 *Prelude* 中 `either` 函数。\n"
"在给出它的类型之后，创建一个骨架实现，\n"
"然后 `Either` 的参数上进行案例分割，我们得出类似于以下内容：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:174
#, no-wrap
msgid ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"
msgstr ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:186
#, no-wrap
msgid ""
"Idris can come up with expressions for the two metavariables\n"
"on its own, because the types are specific enough. Move\n"
"the cursor onto one of the metavariables and enter\n"
"`<LocalLeader>o` in normal mode. You will be given\n"
"a selection of possible expressions (only one in this case),\n"
"of which you can choose a fitting one (or abort with `q`).\n"
msgstr ""
"Idris 可以仅凭自己就可以提取出两个元变量的表达式，因为类型足够具体。\n"
"将光标移到其中一个元变量上并在常规模式下输入 `<LocalLeader>o`。你会得到一组可能的表达式（在这种情况下只有一个），\n"
"您可以从中选择一个合适的（或使用 `q` 中止）。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:190
#, no-wrap
msgid ""
"Here is another example: A reimplementation of function `maybe`.\n"
"If you run an expression search on `?maybe2_rhs1`, you will\n"
"get a larger list of choices.\n"
msgstr ""
"这是另一个例子：函数 `maybe` 的重新实现。\n"
"如果您在 `?maybe2_rhs1` 上运行表达式搜索，您将\n"
"获得更大的选择列表。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:191
#, no-wrap
msgid ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"
msgstr ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:208
#, no-wrap
msgid ""
"Idris is also sometimes capable of coming up with complete function\n"
"implementations based on a function's type. For this to work well\n"
"in practice, the number of possible implementations satisfying\n"
"the type checker must be pretty small. As an example, here is\n"
"function `zipWith` for vectors. You might not have heard\n"
"about vectors yet: They will be introduced in the chapter about\n"
"[dependent types](../Tutorial/Dependent.md). You can still give\n"
"this a go to check out its effect. Just move the cursor on the\n"
"line declaring `zipWithV`, enter `<LocalLeader>gd` and select the first option.\n"
"This will automatically generate the whole function body including\n"
"case splits and implementations.\n"
msgstr ""
"Idris 有时也能够基于函数类型提出完整的函数实现。为了让它在实践中运作良好，\n"
"满足类型检查器的可能实现的数量必须非常小。\n"
"例如，这里是用于向量的函数 `zipWith`。你可能没听说过向量：它们将在[依赖类型](../Tutorial/Dependent.md)的章节中介绍。\n"
"你仍然可以去检查一下它的效果。只需将光标移到声明 `zipWithV` 的行，输入 `<LocalLeader>gd` 并选择第一个选项。\n"
"这将自动生成整个函数体，包括案例拆分和实现。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:209
#, no-wrap
msgid "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
msgstr "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:218
#, no-wrap
msgid ""
"Expression search only works well if the types are specific\n"
"enough. If you feel like that might be the case, go ahead\n"
"and give it a go, either by running `<LocalLeader>o` on\n"
"a metavariable, or by trying `<LocalLeader>gd` on a\n"
"function declaration.\n"
msgstr ""
"表达式搜索仅在类型足够特定时才有效。如果您觉得可能是这种情况，请继续\n"
"试一试，方法是在元变量上运行 `<LocalLeader>o`，或在函数声明处尝试 `<LocalLeader>gd`。\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:219
#, no-wrap
msgid "More Code Actions"
msgstr "更多代码操作"

#. type: Plain text
#: ../src/Appendices/Neovim.md:223
#, no-wrap
msgid ""
"There are other shortcuts available for generating part of your code,\n"
"two of which I'll explain here.\n"
msgstr ""
"还有其他快捷方式可用于生成部分代码，\n"
"其中两个我将在这里解释。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:231
#, no-wrap
msgid ""
"First, it is possible to add a new case block by entering\n"
"`<LocalLeader>mc` in normal mode when on a metavariable.\n"
"For instance, here is part of an implementation of `filterList`,\n"
"which appears in an exercise in the chapter about\n"
"algebraic data types. I arrived at this by letting Idris\n"
"generate a skeleton implementation followed by a case split\n"
"and an expression search on the first metavariable:\n"
msgstr ""
"首先，处于正常模式是可以通过在元变量上按下 `<LocalLeader>mc` 添加一个新的案例块。\n"
"例如，这里是 `filterList` 实现的一部分，\n"
"它出现在代数数据类型一章中。让 Idris 先生成骨架实现，然后是进行一次案例拆分\n"
"以及对第一个元变量的表达式搜索：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:232
#, no-wrap
msgid ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"
msgstr ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:247
#, no-wrap
msgid ""
"We will next have to pattern match on the result of applying\n"
"`x` to `f`. Idris can introduce a new case block for us,\n"
"if we move the cursor onto metavariable `?filterList_rhs_1`\n"
"and enter `<LocalLeader>mc` in normal mode. We can then\n"
"continue with our implementation by first giving the\n"
"expression to use in the case block (`f x`) followed by a\n"
"case split on the new variable in the case block.\n"
"This will lead us to an implementation similar to the following\n"
"(I had to fix the indentation, though):\n"
msgstr ""
"接下来我们必须对应用 `x` 到 `f` 的结果进行模式匹配。\n"
"Idris 可以为我们介绍一个新的案例块，\n"
"如果我们将光标移动到元变量 `?filterList_rhs_1`\n"
"并在正常模式下输入 `<LocalLeader>mc`。那么我们可以\n"
"继续我们的实现，首先给出\n"
"在 case 块中使用的表达式 (`f x`) 后跟一个\n"
"对 case 块中的新变量进行 case 拆分。\n"
"这将导致我们实现类似于以下的实现\n"
"（不过，我必须修复缩进）：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:248
#, no-wrap
msgid ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"
msgstr ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:266
#, no-wrap
msgid ""
"Sometimes, we want to extract a utility function from\n"
"an implementation we are working on. For instance, this is often\n"
"useful or even necessary when we write proofs about our code\n"
"(see chapters [Propositional Equality](../Tutorial/Eq.md)\n"
"and [Predicates](../Tutorial/Predicates.md), for instance).\n"
"In order to do so, we can move the cursor on a metavariable,\n"
"and enter `<LocalLeader>ml`. Give this a try with\n"
"`?whatNow` in the following example (this will work better\n"
"in a regular Idris source file instead of the literate\n"
"file I use for this tutorial):\n"
msgstr ""
"有时，我们想从正在工作的实现中提取一个工具函数。例如，\n"
"当我们编写代码证明时通常是有用甚至是必要的\n"
"（参见章节 [命题等式](../Tutorial/Eq.md)\n"
"和 [谓词](../Tutorial/Predicates.md)）。\n"
"为此，我们可以将光标移动到元变量上，\n"
"并输入 `<LocalLeader>ml`。试试这个\n"
"`?whatNow` 在下面的例子中（这在常规的 Idris 源文件中会更好，\n"
"而不是我用于本教程的文学编程文件）：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:267
#, no-wrap
msgid ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"
msgstr ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:279
#, no-wrap
msgid ""
"Idris will create a new function declaration with the\n"
"type and name of `?whatNow`, which takes as arguments\n"
"all variables currently in scope. It also replaces the hole in\n"
"`traverseEither` with a call to this new function. Typically,\n"
"you will have to manually remove unneeded arguments\n"
"afterwards. This led me to the following version:\n"
msgstr ""
"Idris 将创建一个新的带有类型的函数声明，其名称为 `?whatNow`，\n"
"可以把当前作用域内的所有变量作为参数。它也取代了 `traverseEither` 中的孔来调用这个新函数。通常，\n"
"您将不得不手动删除不需要的参数。这导致我得到以下版本：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:280
#, no-wrap
msgid ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"
msgstr ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:288
#, no-wrap
msgid "Getting Information"
msgstr "获取资讯"

#. type: Plain text
#: ../src/Appendices/Neovim.md:294
#, no-wrap
msgid ""
"The `idris2-lsp` executable and through it, the `idris2-nvim` plugin,\n"
"not only supports the code actions described above. Here is a\n"
"non-comprehensive list of other capabilities. I suggest you try\n"
"out each of them from within this source file.\n"
msgstr ""
"`idris2-nvim` 通过`idris2-lsp` 可执行文件并通过它不仅支持上述代码操作。\n"
"这里有一个其他功能的非全面列表。\n"
"我建议你从这个源文件中取出它们中的每一个去试试。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `K` when on an identifier or operator in normal mode shows its type\n"
"and namespace (if any). In case of a metavariable, variables\n"
"in the current context are displayed as well together with their\n"
"types and quantities (quantities will be explained in\n"
"[Functions Part 2](../Tutorial/Functions2.md)).\n"
"If you don't like popups, enter `<LocalLeader>so` to open a new window where\n"
"this information is displayed and semantically highlighted instead.\n"
msgstr "在正常模式下的标识符或运算符上键入 `K` 会显示其类型和命名空间（如果有）。在元变量的情况下，当前上下文中的变量也会连同它们的类型和定量一起显示（定量将在 [Functions Part 2](../Tutorial/Functions2.md) 中解释）。如果您不喜欢弹出窗口，请输入 `<LocalLeader>so` 以打开一个新窗口，该窗口将显示此信息并在语义上突出显示。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `gd` on a function, operator, data constructor or type\n"
"constructor in normal mode jumps to the item's definition.\n"
"For external modules, this works only if the\n"
"module in question has been installed together with its source code\n"
"(by using the `idris2 --install-with-src` command).\n"
msgstr "在正常模式下在函数、运算符、数据构造函数或类型构造函数上输入 `gd` 会跳转到项目的定义。对于外部模块，仅当相关模块与其源代码一起安装时才有效（通过使用 `idris2 --install-with-src` 命令）。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>mm` opens a popup window listing all metavariables\n"
"in the current module. You can place the cursor on an entry and\n"
"jump to its location by pressing `<Enter>`.\n"
msgstr "输入 `<LocalLeader>mm` 打开一个弹出窗口，列出当前模块中的所有元变量。您可以将光标放在一个条目上，然后按 `<Enter>` 跳转到它的位置。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>mn` (or `<LocalLeader>mp`) jumps to the next\n"
"(or previous) metavariable in the current module.\n"
msgstr "输入 `<LocalLeader>mn`（或 `<LocalLeader>mp`）跳转到当前模块中的下一个（或上一个）元变量。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>br` opens a popup where you can enter a\n"
"namespace. Idris will then show all functions (plus their types)\n"
"exported from that namespace in a popup window, and you can\n"
"jump to a function's definition by pressing enter on one of the\n"
"entries. Note: The module in question must be imported in the\n"
"current source file.\n"
msgstr "键入 `<LocalLeader>br` 会打开一个弹出窗口，您可以在其中输入名称空间。然后 Idris 将在弹出窗口中显示从该命名空间导出的所有函数（以及它们的类型），您可以通过在其中一个条目上按 enter 来跳转到函数的定义。注意：有问题的模块必须在当前源文件中导入。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>x` opens a popup where you can enter\n"
"a REPL command or Idris expression, and the plugin will reply\n"
"with a response from the REPL. Whenever REPL examples are shown\n"
"in the main part of this guide, you can try them from within\n"
"Neovim with this shortcut if you like.\n"
msgstr "输入 `<LocalLeader>x` 会打开一个弹出窗口，您可以在其中输入 REPL 命令或 Idris 表达式，插件将回复来自 REPL 的响应。每当本指南的主要部分显示 REPL 示例时，如果您愿意，可以使用此快捷方式在 Neovim 中尝试它们。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader><LocalLeader>e` will display the error message\n"
"from the current line in a popup window. This can be highly useful,\n"
"if error messages are too long to fit on a single line. Likewise,\n"
"`<LocalLeader><LocalLeader>el` will list all error messages from the current\n"
"buffer in a new window. You can then select an error message and\n"
"jump to its origin by pressing `<Enter>`.\n"
msgstr "键入 `<LocalLeader><LocalLeader>e` 将在弹出窗口中显示当前行的错误消息。如果错误消息太长而无法放在一行中，这将非常有用。同样， `<LocalLeader><LocalLeader>el` 将在新窗口中列出当前缓冲区中的所有错误消息。然后，您可以通过按 `<Enter>` 选择错误消息并跳转到其原点。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:332
#, no-wrap
msgid ""
"Other use cases and examples are described on the GitHub page\n"
"of the `idris2-nvim` plugin and can be included as described there.\n"
msgstr "`idris2-nvim` 插件其他用例和示例在 GitHub 页面上进行了描述，这些描述也包含在内。\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:333
#, no-wrap
msgid "The `%name` Pragma"
msgstr "`%name` 编译指示"

#. type: Plain text
#: ../src/Appendices/Neovim.md:345
#, no-wrap
msgid ""
"When you ask Idris for a skeleton implementation with `<LocalLeader>a`\n"
"or a case split with `<LocalLeader>c`,\n"
"it has to decide on what names to use for the new variables it introduces.\n"
"If these variables already have predefined names (from the function's\n"
"signature, record fields, or named data constructor arguments),\n"
"those names will be used, but\n"
"otherwise Idris will as a default use names `x`, `y`, and `z`, followed\n"
"by other letters. You can change this default behavior by\n"
"specifying a list of names to use for such occasions for any\n"
"data type.\n"
msgstr ""
"当您向 Idris 询问使用 `<LocalLeader>a` 的框架实现\n"
"或用 `<LocalLeader>c` 案例拆分时，\n"
"它必须决定为它引入的新变量使用什么名称。\n"
"如果这些变量已经有预定义的名称（来自函数的\n"
"签名、记录字段或命名数据构造函数参数），\n"
"这些名称将被使用，否则 Idris 将默认使用名称 `x`、`y` 和 `z`，然后\n"
"或其他字母。您可以更改此默认行为，\n"
"只要指定用于此类数据类型场合的名称列表。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:347
#, no-wrap
msgid "For instance:\n"
msgstr "例如：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:348
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"
msgstr ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:358
#, no-wrap
msgid ""
"Idris will then use these names (followed by these names postfixed\n"
"with increasing integers), when it has to come up with variable names of this\n"
"type on its own. For instance, here is a test function and the\n"
"result of adding a skeleton definition to it:\n"
msgstr ""
"然后 Idris 将使用这些名称（这些名称后跟自增数字的后缀），\n"
"当它必须想出这个类型的自己变量名时。\n"
"例如，这是一个测试函数和向其添加骨架定义的结果：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:359
#, no-wrap
msgid ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"
msgstr ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:372
#, no-wrap
msgid ""
"Neovim, together with the `idris2-lsp` executable and the\n"
"`idris2-nvim` editor plugin, provides extensive utilities for\n"
"interactive editing when programming in Idris. Similar functionality\n"
"is available for some other editors, so feel free to ask what's\n"
"available for your editor of choice, for instance on the\n"
"[Idris 2 Discord channel](https://discord.gg/UX68fDs2jc).\n"
msgstr ""
"Neovim，连同 `idris2-lsp` 可执行文件和 `idris2-nvim` 编辑器插件，\n"
"为在 Idris 中编程时的交互式编辑。\n"
"其他一些编辑也可以使用类似的功能，\n"
"所以请随时询问可供您选择使用的编辑器有什么，\n"
"例如在 [Idris 2 Discord 频道](https://discord.gg/UX68fDs2jc) 上。\n"
