# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 04:14+0000\n"
"PO-Revision-Date: 2025-05-15 04:14+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, fuzzy, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  README.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2\n"
"-->\n"
"#-#-#-#-#  Neovim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  DataTypes.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions1.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functions2.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Functor.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Intro.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.zh_Hans.po (po 4a)  #-#-#-#-#\n"

#. type: Title #
#: ../src/Appendices/Projects.md:1
#, fuzzy, no-wrap
#| msgid "[Structuring Idris Projects](src/Appendices/Projects.md)\n"
msgid "Structuring Idris Projects"
msgstr "[构造 Idris 项目](src/Appendices/Projects.md)\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:7
#, no-wrap
msgid ""
"In this section I'm going to show how to organize, install, and depend on\n"
"larger Idris projects. We will have a look at Idris packages,\n"
"the module system, visibility of types and functions, writing\n"
"comments and doc strings, and using pack for managing our libraries.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:15
#, no-wrap
msgid ""
"This section should be useful for all readers who have already\n"
"written a bit of Idris code. We will not do any fancy type level\n"
"wizardry in here, but I'll demonstrate several concepts using\n"
"`failing` code blocks, which you might not have seen before.\n"
"This rather new addition to the language\n"
"allows us to write code that is expected to fail during elaboration\n"
"(type checking). For instance:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:16
#, fuzzy, no-wrap
#| msgid ""
#| "failing \"Can't find an implementation\\nfor NotNil [].\"\n"
#| "  errHead : Nat\n"
#| "  errHead = Predicates.head []\n"
msgid ""
"failing \"Can't find an implementation for FromString Bits8.\"\n"
"  ohno : Bits8\n"
"  ohno = \"Oh no!\"\n"
msgstr ""
"failing \"Can't find an implementation\\nfor NotNil [].\"\n"
"  errHead : Nat\n"
"  errHead = Predicates.head []\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:25
#, no-wrap
msgid ""
"As part of a failing block, we can give a substring of the compiler's\n"
"error message for documentation purposes and to make sure the block\n"
"fails with the expected error.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Projects.md:26
#, no-wrap
msgid "Modules"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:30
#, fuzzy, no-wrap
#| msgid ""
#| "Every Idris source file should typically start with a module\n"
#| "name plus some necessary imports, and this document is no\n"
#| "exception:\n"
msgid ""
"Every Idris source file defines a *module*, typically starting with a\n"
"module header like the one below:\n"
msgstr "每个 Idris 源文件通常应该以模块名称和一些必要的导入开头，本文档也不例外。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:31
#, no-wrap
msgid "module Appendices.Projects\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:39
#, no-wrap
msgid ""
"A module's name consists of several upper case identifiers separated\n"
"by dots, which must reflect the path of the `.idr` file where the\n"
"module is stored. For instance, this module is stored in file\n"
"`Appendices/Projects.md`, so the module's name is `Appendices.Projects`.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:46
#, no-wrap
msgid ""
"\"But wait!\", I hear you say, \"What about the parent folder(s) of `Appendices`?\n"
"Why aren't those part of the module's name?\" In order to understand this,\n"
"we must talk about the concept of the *source directory*. The source directory\n"
"is where Idris is looking for source files. It defaults to the\n"
"directory, from which the Idris executable is run. For instance, when\n"
"in folder `src` of this project, you can open this source file like so:\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:47
#, fuzzy, no-wrap
#| msgid "[Structuring Idris Projects](src/Appendices/Projects.md)\n"
msgid "idris2 Appendices/Projects.md\n"
msgstr "[构造 Idris 项目](src/Appendices/Projects.md)\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:53
#, no-wrap
msgid ""
"This will not work, however, if you try the same thing from this\n"
"project's root folder:\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:54
#, no-wrap
msgid ""
"$ idris2 src/Appendices/Projects.md\n"
"...\n"
"Error: Module name Appendices.Projects does not match file name \"src/Appendices/Projects.md\"\n"
"...\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:68
#, no-wrap
msgid ""
"So, which folder names to include in a module name depends on the\n"
"parent folder we consider to be our source directory. It is common\n"
"practice to name the source directory `src`, although this is not\n"
"mandatory (as I said above, the default is actually the directory,\n"
"from which we run Idris). It is possible to change the source directory\n"
"with the `--source-dir` command-line option. The following works from\n"
"within this project's root directory:\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:69
#, fuzzy, no-wrap
#| msgid "[Structuring Idris Projects](src/Appendices/Projects.md)\n"
msgid "idris2 --source-dir src src/Appendices/Projects.md\n"
msgstr "[构造 Idris 项目](src/Appendices/Projects.md)\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:75
#, no-wrap
msgid ""
"And the following would work from a parent directory\n"
"(assuming this tutorial is stored in folder `tutorial`):\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:76
#, fuzzy, no-wrap
#| msgid "[Structuring Idris Projects](src/Appendices/Projects.md)\n"
msgid "idris2 --source-dir tutorial/src tutorial/src/Appendices/Projects.md\n"
msgstr "[构造 Idris 项目](src/Appendices/Projects.md)\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:84
#, no-wrap
msgid ""
"Most of the time, however, you will specify an `.ipkg` file for\n"
"your project (see later in this section) and define the source\n"
"directory there. Afterwards, you can use pack (instead of the `idris2`\n"
"executable) to start REPL sessions and load your source files.\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:85
#, no-wrap
msgid "Module Imports"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:91
#, no-wrap
msgid ""
"You often need to import functions and data types from other\n"
"modules when writing Idris code. This can be done with an\n"
"`import` statement. Here are several examples showing\n"
"how these might look like:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:92
#, no-wrap
msgid ""
"import Data.String\n"
"import Data.List\n"
"import Text.CSV\n"
"import public Appendices.Neovim\n"
"import Data.Vect as V\n"
"import public Data.List1 as L\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:104
#, no-wrap
msgid ""
"The first two lines import modules from another *package* (we will learn\n"
"about packages below): `Data.List` from the *base* package, which\n"
"will be installed as part of your Idris installation.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:108
#, no-wrap
msgid ""
"The second line imports module `Text.CSV` from within our own source\n"
"directory `src`. It is always possible to import modules that are part\n"
"of the same source directory as the file we are working on.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:122
#, no-wrap
msgid ""
"The third line imports module `Appendices.Neovim`, again from our\n"
"own source directory. Note, however, that this `import` statement comes\n"
"with an additional `public` keyword. This allows us to *re-export*\n"
"a module, so that it is available from within other modules in addition\n"
"to the current module: If another module imports `Appendices.Projects`,\n"
"module `Appendices.Neovim` will be imported as well without the need\n"
"of an additional `import` statement. This is useful when\n"
"we split some complex functionality across different modules and\n"
"want to import the lot via a single catch-all module\n"
"See module `Control.Monad.State` in *base* for an example. You\n"
"can look at the Idris sources on GitHub or locally after cloning\n"
"the [Idris2 project](https://github.com/idris-lang/Idris2).\n"
"The base library can be found in the `libs/base` subfolder.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:127
#, no-wrap
msgid ""
"It often happens that in order to make use of functions from some module\n"
"`A` we also require utilities from another module `B`, so `A` should\n"
"re-export `B`. For instance, `Data.Vect` in *base* re-exports `Data.Fin`,\n"
"because the latter is often required when working with vectors.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:132
#, no-wrap
msgid ""
"The fourth line imports module `Data.Vect`, giving it a new name `V`, to\n"
"be used as a shorter prefix. If you often need to disambiguate identifiers\n"
"by prefixing them with a module's name, this can help making your code\n"
"more concise:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:133
#, no-wrap
msgid ""
"vectSum : Nat\n"
"vectSum = sum $ V.fromList [1..10]\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:143
#, no-wrap
msgid ""
"Finally, on the fifth line we publicly import a module and give it\n"
"a new name. This name will then be the one seen when we transitively\n"
"import `Data.List1` via `Appendices.Projects`. To see this, start\n"
"a REPL session (after type checking the tutorial)\n"
"without loading a source file from this project's root folder:\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:144
#, no-wrap
msgid ""
"pack typecheck tutorial\n"
"pack repl\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:151
#, no-wrap
msgid ""
"Now load module `Appendices.Projects` and checkout the type\n"
"of `singleton`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:152
#, no-wrap
msgid ""
"Main> :module Appendices.Projects\n"
"Imported module Appendices.Projects\n"
"Main> :t singleton\n"
"Data.String.singleton : Char -> String\n"
"Data.List.singleton : a -> List a\n"
"L.singleton : a -> List1 a\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:164
#, no-wrap
msgid ""
"As you can see, the `List1` version of `singleton` is now prefixed\n"
"with `L` instead of `Data.List1`. It is still possible to use the\n"
"\"official\" prefix, though:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:165
#, no-wrap
msgid ""
"Main> List1.singleton 12\n"
"12 ::: []\n"
"Main> L.singleton 12\n"
"12 ::: []\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:172
#, fuzzy, no-wrap
#| msgid "Modules and Namespaces"
msgid "Namespaces"
msgstr "模块和命名空间"

#. type: Plain text
#: ../src/Appendices/Projects.md:182
#, no-wrap
msgid ""
"At times, we want to define several functions or data types\n"
"with the same name in a single module. Idris does not allow this,\n"
"because every name must be unique in its *namespace*, and the\n"
"namespace of a module is just the fully qualified module name.\n"
"However, it is possible to define additional namespaces within\n"
"a module by using the `namespace` keyword followed by the name\n"
"of the namespace. All functions which should belong to this\n"
"namespace must then be indented by the same amount of whitespace.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:184
#, fuzzy, no-wrap
#| msgid "Here is another example:\n"
msgid "Here's an example:\n"
msgstr "这是另一个例子：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:185
#, no-wrap
msgid ""
"data HList : List Type -> Type where\n"
"  Nil  : HList []\n"
"  (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
"\n"
"head : HList (t :: ts) -> t\n"
"head (v :: _) = v\n"
"\n"
"tail : HList (t :: ts) -> HList ts\n"
"tail (_ :: vs) = vs\n"
"\n"
"namespace HVect\n"
"  public export\n"
"  data HVect : Vect n Type -> Type where\n"
"    Nil  : HVect []\n"
"    (::) : (v : t) -> (vs : HVect ts) -> HVect (t :: ts)\n"
"\n"
"  public export\n"
"  head : HVect (t :: ts) -> t\n"
"  head (v :: _) = v\n"
"\n"
"  public export\n"
"  tail : HVect (t :: ts) -> HVect ts\n"
"  tail (_ :: vs) = vs\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:222
#, no-wrap
msgid ""
"Function names `HVect.head` and `HVect.tail` as well as constructors\n"
"`HVect.Nil` and `HVect.(::)` would clash with functions and constructors\n"
"of the same names from the outer namespace (`Appendices.Projects`), so\n"
"we had to put them in their own namespace. In order to be able to use\n"
"them from outside their namespace, they need to be exported (see the\n"
"section on visibility below). In case we need to disambiguate between\n"
"these names, we can prefix them with part of their namespace. For instance,\n"
"the following fails with a disambiguation error, because there\n"
"are several functions called `head` in scope and it is not clear\n"
"from `head`'s argument (some data type supporting list syntax,\n"
"of which again several are in scope), which version we want:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:223
#, no-wrap
msgid ""
"failing \"Ambiguous elaboration.\"\n"
"  whatHead : Nat\n"
"  whatHead = head [12,\"foo\"]\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:232
#, no-wrap
msgid ""
"By prefixing `head` with part of its namespace, we can resolve both\n"
"ambiguities. It is now immediately clear, that `[12,\"foo\"]` must be\n"
"an `HVect`, because that's the type of `HVect.head`'s argument:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:233
#, fuzzy, no-wrap
#| msgid ""
#| "headEx3 : Nat\n"
#| "headEx3 = Predicates.head [1,2,3]\n"
msgid ""
"thisHead : Nat\n"
"thisHead = HVect.head [12,\"foo\"]\n"
msgstr ""
"headEx3 : Nat\n"
"headEx3 = Predicates.head [1,2,3]\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:240
#, no-wrap
msgid ""
"In the following subsection I'll make use of namespaces to demonstrate\n"
"the principles of visibility.\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:241
#, no-wrap
msgid "Visibility"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:248
#, no-wrap
msgid ""
"In order to use functions and data types outside of the module\n"
"or namespace they were defined in, we need to change\n"
"their *visibility*. The default visibility is `private`:\n"
"Such a function or data type is not visible from outside\n"
"its module or namespace:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:249
#, no-wrap
msgid ""
"namespace Foo\n"
"  foo : Nat\n"
"  foo = 12\n"
"\n"
"failing \"Name Appendices.Projects.Foo.foo is private.\"\n"
"  bar : Nat\n"
"  bar = 2 * foo\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:261
#, no-wrap
msgid ""
"To make a function visible, annotate it with the `export`\n"
"keyword:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:262
#, no-wrap
msgid ""
"namespace Square\n"
"  export\n"
"  square : Num a => a -> a\n"
"  square v = v * v\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:271
#, no-wrap
msgid ""
"This will allow us to invoke function `square` from within\n"
"other modules or namespaces (after importing `Appendices.Projects`):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:272
#, no-wrap
msgid ""
"OneHundred : Bits8\n"
"OneHundred = square 10\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:279
#, no-wrap
msgid ""
"However, the *implementation* of `square` will not be exported,\n"
"so `square` will not reduce during elaboration:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:280
#, no-wrap
msgid ""
"failing \"Can't solve constraint between: 100 and square 10.\"\n"
"  checkOneHundred : OneHundred === 100\n"
"  checkOneHundred = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:287
#, no-wrap
msgid "For this to work, we need to *publicly export* `square`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:288
#, no-wrap
msgid ""
"namespace SquarePub\n"
"  public export\n"
"  squarePub : Num a => a -> a\n"
"  squarePub v = v * v\n"
"\n"
"OneHundredAgain : Bits8\n"
"OneHundredAgain = squarePub 10\n"
"\n"
"checkOneHundredAgain : OneHundredAgain === 100\n"
"checkOneHundredAgain = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:306
#, no-wrap
msgid ""
"Therefore, if you need a function to reduce during elaboration,\n"
"annotate it with `public export` instead of `export`.\n"
"This is especially important if you use a function to compute\n"
"a type. Such function's *must* reduce during elaboration, otherwise they\n"
"are completely useless:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:307
#, no-wrap
msgid ""
"namespace Stupid\n"
"  export\n"
"  0 NatOrString : Type\n"
"  NatOrString = Either String Nat\n"
"\n"
"failing \"Can't solve constraint between: Either String ?b and NatOrString.\"\n"
"  natOrString : NatOrString\n"
"  natOrString = Left \"foo\"\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:319
#, no-wrap
msgid "If we publicly export our type alias, everything type checks fine:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:320
#, no-wrap
msgid ""
"namespace Better\n"
"  public export\n"
"  0 NatOrString : Type\n"
"  NatOrString = Either String Nat\n"
"\n"
"natOrString : Better.NatOrString\n"
"natOrString = Left \"bar\"\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:330
#, no-wrap
msgid "Visibility of Data Types"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:337
#, no-wrap
msgid ""
"Visibility of data types behaves slightly differently. If set to\n"
"`private` (the default), neither the *type constructor* nor\n"
"the *data constructors* are visible outside of the namespace\n"
"they where defined in. If annotated with `export`,\n"
"the type constructor is exported but not the data constructors:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:338
#, no-wrap
msgid ""
"namespace Export\n"
"  export\n"
"  data Foo : Type where\n"
"    Foo1 : String -> Foo\n"
"    Foo2 : Nat -> Foo\n"
"\n"
"  export\n"
"  mkFoo1 : String -> Export.Foo\n"
"  mkFoo1 = Foo1\n"
"\n"
"foo1 : Export.Foo\n"
"foo1 = mkFoo1 \"foo\"\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:357
#, no-wrap
msgid ""
"As you can see, we can use the type `Foo` as well as\n"
"function `mkFoo1` outside of namespace `Export`. However,\n"
"we cannot use the `Foo1` constructor to create a value\n"
"of type `Foo` directly:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:358
#, no-wrap
msgid ""
"failing \"Export.Foo1 is private.\"\n"
"  foo : Export.Foo\n"
"  foo = Foo1 \"foo\"\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:365
#, no-wrap
msgid "This changes when we publicly export the data type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:366
#, no-wrap
msgid ""
"namespace PublicExport\n"
"  public export\n"
"  data Foo : Type where\n"
"    Foo1 : String -> PublicExport.Foo\n"
"    Foo2 : Nat -> PublicExport.Foo\n"
"\n"
"foo2 : PublicExport.Foo\n"
"foo2 = Foo2 12\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:381
#, no-wrap
msgid ""
"The same goes for interfaces: If they are publicly exported, the\n"
"interface (a type constructor) plus all its functions are exported\n"
"and you can write implementations outside the namespace where\n"
"they where defined:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:382
#, no-wrap
msgid ""
"namespace PEI\n"
"  public export\n"
"  interface Sized a where\n"
"    size : a -> Nat\n"
"\n"
"Sized Nat where size = id\n"
"\n"
"sumSizes : Foldable t => Sized a => t a -> Nat\n"
"sumSizes = foldl (\\n,e => n + size e) 0\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:397
#, no-wrap
msgid ""
"If they are not publicly exported, you will not be able to write\n"
"implementations outside the namespace they were defined in\n"
"(but you can still use the type and its functions in your code):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:398
#, no-wrap
msgid ""
"namespace EI\n"
"  export\n"
"  interface Empty a where\n"
"    empty : a -> Bool\n"
"\n"
"  export\n"
"  Empty (List a) where\n"
"    empty [] = True\n"
"    empty _  = False\n"
"\n"
"failing\n"
"  Empty Nat where\n"
"    empty Z = True\n"
"    empty (S _) = False\n"
"\n"
"nonEmpty : Empty a => a -> Bool\n"
"nonEmpty = not . empty\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:418
#, fuzzy, no-wrap
#| msgid "Modules and Namespaces"
msgid "Child Namespaces"
msgstr "模块和命名空间"

#. type: Plain text
#: ../src/Appendices/Projects.md:424
#, no-wrap
msgid ""
"Sometimes, it is necessary to access a private function\n"
"in another module or namespace. This is possible from within child namespaces\n"
"(for want of a better name): Modules and namespaces sharing the\n"
"parent module's or namespace's prefix. For instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:425
#, no-wrap
msgid ""
"namespace Inner\n"
"  testEmpty : Bool\n"
"  testEmpty = nonEmpty (the (List Nat) [12])\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:441
#, no-wrap
msgid ""
"As you can see, we can access function `nonEmpty` from\n"
"within namespace `Appendices.Projects.Inner`, although it is a\n"
"private function of module `Appendices.Projects`. This is\n"
"even possible for modules: If we were to write a module\n"
"`Data.List.Magic`, we'd have access to private utility functions\n"
"defined in module `Data.List` in *base*. Actually, I did just that\n"
"and added module `Data.List.Magic` demonstrating this quirk\n"
"of the Idris module system (go have a look!).\n"
"In general, this is a rather hacky way to work around visibility\n"
"constraints, but it can be useful at times.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Projects.md:442
#, no-wrap
msgid "Parameter Blocks"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:450
#, no-wrap
msgid ""
"In this subsection, we are going to have a look at a language construct\n"
"called a `parameters` block,\n"
"which enables us to share a set of common read-only arguments (parameters)\n"
"across several functions, thus allowing us to write more concise function\n"
"signatures. I'm going to demonstrate their usability with a small\n"
"example program.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:457
#, no-wrap
msgid ""
"The most basic way to make some piece of external information available\n"
"to a function is by passing it as an additional argument. In object-orientied\n"
"programming, this principle is sometimes called\n"
"[dependency injection](https://en.wikipedia.org/wiki/Dependency_injection), and\n"
"a lot of fuss is being made about it, and whole libraries and frameworks\n"
"have been built around it.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:467
#, no-wrap
msgid ""
"In functional programming, we can be perfectly relaxed about all of this:\n"
"Need access to some configuration data for your application? Pass it as an additional\n"
"argument to your functions. Want to use some local\n"
"mutable state? Pass the corresponding `IORef` as an additional\n"
"argument to your functions. This is both highly efficient\n"
"and incredibly simple. The only drawback it has: It can blow\n"
"up our function signatures. There is even a monad for abstracting over this\n"
"concept, called the `Reader` monad. It can be found in module `Control.Monad.Reader`,\n"
"in the base library.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:471
#, no-wrap
msgid ""
"In Idris, however, there is an even simpler approach:\n"
"We can use proof search with auto implicit arguments for dependency\n"
"injection. Here's some example code:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:472
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NoNat  : String -> Error\n"
"  NoBool : String -> Error\n"
"\n"
"record Console where\n"
"  constructor MkConsole\n"
"  read : IO String\n"
"  put  : String -> IO ()\n"
"\n"
"record ErrorHandler where\n"
"  constructor MkHandler\n"
"  handle : Error -> IO ()\n"
"\n"
"getCount' : (h : ErrorHandler) => (c : Console) => IO Nat\n"
"getCount' = do\n"
"  str <- c.read\n"
"  case parsePositive str of\n"
"    Nothing => h.handle (NoNat str) $> 0\n"
"    Just n  => pure n\n"
"\n"
"getText' : (h : ErrorHandler) => (c : Console) => (n : Nat) -> IO (Vect n String)\n"
"getText' n = sequence $ replicate n c.read\n"
"\n"
"prog' : ErrorHandler => (c : Console) => IO ()\n"
"prog' = do\n"
"  c.put \"Please enter the number of lines to read.\"\n"
"  n  <- getCount'\n"
"  c.put \"Please enter \\{show n} lines of text.\"\n"
"  ls <- getText' n\n"
"  c.put \"Read \\{show n} lines and \\{show . sum $ map length ls} characters.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:520
#, no-wrap
msgid ""
"The example program reads input from and prints output to some\n"
"`Console` type, the implementation of which is left to the caller of the\n"
"function. This is a typical example of dependency injection: Our\n"
"`IO` actions know nothing about how to read and write lines of text\n"
"(they do, for instance, not invoke `putStrLn` or `getLine` directly),\n"
"but rely on an external *object* to handle these tasks for us. This allows\n"
"us to use a simple *mock object* during testing, while using - for instance -\n"
"two file handles or data base connections when running the application\n"
"for real. These are typical techniques often found in object-oriented\n"
"programming, and in fact, this example emulates typical object-oriented\n"
"patterns in a purely functional programming language: A type like\n"
"`Console` can be viewed as a *class* providing pieces of functionality\n"
"(*methods*  `read` and `put`), and a value of type `Console`\n"
"can be viewed as an *object* of this class, on which we can invoke\n"
"those methods.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:525
#, no-wrap
msgid ""
"The same goes for error handling: Our error handler could just silently\n"
"ignore any error that occurs, or it could print it to `stderr` and write\n"
"it to a log file at the same time. Whatever it does, our functions need\n"
"not care.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:536
#, no-wrap
msgid ""
"Note, however, that even in this very simple example we already\n"
"introduced two additional function arguments, and we can easily see\n"
"how in a real-world application we might need many more of those\n"
"and how this would quickly blow up our function signatures.\n"
"Luckily, there is a very clean and simple solution to this in\n"
"Idris: `parameter` blocks. These allow us to specify lists\n"
"of *parameters* (unchanging function arguments) shared by all\n"
"functions listed inside the block. These arguments need then no longer\n"
"be listed with each function, thus decluttering our function signatures.\n"
"Here's the example from above in a parameter block:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:537
#, no-wrap
msgid ""
"parameters {auto c : Console} {auto h : ErrorHandler}\n"
"  getCount : IO Nat\n"
"  getCount = do\n"
"    str <- c.read\n"
"    case parsePositive str of\n"
"      Nothing => h.handle (NoNat str) $> 0\n"
"      Just n  => pure n\n"
"\n"
"  getText : (n : Nat) -> IO (Vect n String)\n"
"  getText n = sequence $ replicate n c.read\n"
"\n"
"  prog : IO ()\n"
"  prog = do\n"
"    c.put \"Please enter the number of lines to read.\"\n"
"    n  <- getCount\n"
"    c.put \"Please enter \\{show n} lines of text.\"\n"
"    ls <- getText n\n"
"    c.put \"Read \\{show n} lines and \\{show . sum $ map length ls} characters.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:564
#, no-wrap
msgid ""
"We are free to list arbitrary arguments (implicit, explicit, auto-implicit,\n"
"named and unnamed) of any quantity as the parameters in a `parameters`\n"
"block, but it works best with implicit and auto implicit arguments. Explicit\n"
"arguments will have to be passed explicitly to functions in a parameter\n"
"block, even when invoking them from other parameter blocks with the\n"
"same explicit argument. This can be rather confusing.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:568
#, no-wrap
msgid ""
"To complete this example, here is a main function for running\n"
"the program. Note, how we explicitly assemble the `Console` and\n"
"`ErrorHandler` to be used when invoking `prog`.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:569
#, no-wrap
msgid ""
"main : IO ()\n"
"main =\n"
"  let cons := MkConsole (trim <$> getLine) putStrLn\n"
"      err  := MkHandler (const $ putStrLn \"It didn't work\")\n"
"   in prog\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:580
#, no-wrap
msgid ""
"Dependency injection via auto-implicit arguments is only one possible\n"
"application of parameter blocks. They are useful in general whenever\n"
"we have repeating argument lists for several functions.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Projects.md:581
#, fuzzy, no-wrap
#| msgid "Enumerations"
msgid "Documentation"
msgstr "枚举"

#. type: Plain text
#: ../src/Appendices/Projects.md:588
#, no-wrap
msgid ""
"Documentation is key. Be it for other programmers using a library\n"
"we wrote, or for people (including our future selves) trying to understand\n"
"our code, it is important to annotate our code with comments explaining\n"
"non-trivial implementation details and docstrings describing the intent and\n"
"functionality of exported data types and functions.\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:589
#, no-wrap
msgid "Comments"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:593
#, no-wrap
msgid ""
"Writing a comment in an Idris source file is as simple as\n"
"adding some text after two hyphens:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:594
#, no-wrap
msgid ""
"-- this is a truly boring comment\n"
"boring : Bits8 -> Bits8\n"
"boring a = a -- probably I should just use `id` from the Prelude\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:603
#, no-wrap
msgid ""
"Whenever a line contains two hyphens that are not part of\n"
"a string literal, the remainder of the line will be interpreted\n"
"as a comment by Idris.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:606
#, no-wrap
msgid ""
"It is also possible to write multiline comments using delimiters\n"
"`{-` and `-}`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:607
#, no-wrap
msgid ""
"{-\n"
"  This is a multiline comment. It can be used to comment\n"
"  out whole blocks of code, for instance if we get several\n"
"  type errors in a larger source file.\n"
"-}\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:615
#, no-wrap
msgid "Doc Strings"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:621
#, no-wrap
msgid ""
"While comments are targeted at programmers reading and trying to\n"
"understand our source code, doc strings provide documentation for\n"
"exported functions and data types, explaining their intent and\n"
"behavior to others.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:623
#, fuzzy, no-wrap
#| msgid "Here's the type of the function:\n"
msgid "Here's and example of a documented function:\n"
msgstr "这是函数的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:624
#, no-wrap
msgid ""
"||| Tries to extract the first two elements from the beginning\n"
"||| of a list.\n"
"|||\n"
"||| Returns a pair of values wrapped in a `Just` if the list has\n"
"||| two elements or more. Returns `Nothing` if the list has fewer\n"
"||| than two elements.\n"
"export\n"
"firstTwo : List a -> Maybe (a,a)\n"
"firstTwo (x :: y :: _) = Just (x,y)\n"
"firstTwo _             = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:638
#, fuzzy, no-wrap
#| msgid "Let's give this a spin at the REPL:\n"
msgid "We can view a doc string at the REPL:\n"
msgstr "让我们在 REPL 上试一试：\n"

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:639
#, no-wrap
msgid ""
"Appendices.Projects> :doc firstTwo\n"
"Appendices.Projects.firstTwo : List a -> Maybe (a,a)\n"
"  Tries to extract the first two elements from the beginning\n"
"  of a list.\n"
"\n"
"  Returns a pair of values wrapped in a `Just` if the list has\n"
"  two elements or more. Returns `Nothing` if the list has fewer\n"
"  than two elements.\n"
"  Visibility: export\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:653
#, no-wrap
msgid ""
"We can document data types and their constructors in a similar\n"
"manner:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:654
#, no-wrap
msgid ""
"||| A binary tree index by the number of values it holds.\n"
"|||\n"
"||| @param `n` : Number of values stored in the `Tree`\n"
"||| @param `a` : Type of values stored in the `Tree`\n"
"public export\n"
"data Tree : (n : Nat) -> (a : Type) -> Type where\n"
"  ||| A single value stored at the leaf of a binary tree.\n"
"  Leaf   : (v : a) -> Tree 1 a\n"
"\n"
"  ||| A branch unifying two subtrees.\n"
"  Branch : Tree m a -> Tree n a -> Tree (m + n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:670
#, fuzzy, no-wrap
#| msgid "As usual, we should have a look at the result at the REPL:\n"
msgid ""
"Go ahead and have a look at the doc strings this generates at\n"
"the REPL.\n"
msgstr "像往常一样，我们应该看看 REPL 的结果：\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:678
#, no-wrap
msgid ""
"Documenting our code is very important. You will realize this, once you\n"
"try to understand other people's code,\n"
"or when you come back to a non-trivial piece of source code you wrote yourself\n"
"a couple of months a ago and since then haven't looked at. If it is not well\n"
"documented, this can be an unpleasant experience. Idris provides\n"
"us with the tools necessary to document and annotate our code,\n"
"so should take our time and do so. It is time well spent.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Projects.md:679
#, no-wrap
msgid "Packages"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:686
#, no-wrap
msgid ""
"Idris packages allow us to assemble several modules into\n"
"a logical unit and make them available to other Idris projects\n"
"by *installing* the packages. In this section, we are going to learn\n"
"about the structure of an Idris package and how to depend on\n"
"other packages in our projects.\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:687
#, no-wrap
msgid "The `.ipkg` File"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:693
#, no-wrap
msgid ""
"At the heart of an Idris package lies its `.ipkg` file,\n"
"which is usually but not necessarily stored at a project's root directory.\n"
"For instance, for this Idris tutorial, there is file\n"
"`tutorial.ipkg` at the tutorial's root directory.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:699
#, no-wrap
msgid ""
"An `.ipkg` file consists\n"
"of several key-value pairs (most of them optional), the\n"
"most important of which I'll describe here. By far the easiest\n"
"way to setup a new Idris project is by letting pack or Idris itself\n"
"do it for you. Just run\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:700
#, no-wrap
msgid "pack new lib pkgname\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:705
#, no-wrap
msgid "to create the skeleton of a new library or\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:706
#, no-wrap
msgid "pack new bin appname\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:713
#, no-wrap
msgid ""
"to setup a new application. In addition to creating a new directory plus\n"
"a suitable `.ipkg` file, these commands will also add a `pack.toml` file,\n"
"which we will discuss further below.\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:714
#, fuzzy, no-wrap
#| msgid "Dependent Pairs"
msgid "Dependencies"
msgstr "依赖对"

#. type: Plain text
#: ../src/Appendices/Projects.md:721
#, no-wrap
msgid ""
"One of the most important aspects of an `.ipkg` file is\n"
"listing the packages the library depends on in\n"
"the `depends` field. Here is an example from the\n"
"[*hedgehog* package](https://github.com/stefan-hoeck/idris2-hedgehog),\n"
"a framework for writing property tests in Idris:\n"
msgstr ""

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:722
#, no-wrap
msgid ""
"depends    = base         >= 0.5.1\n"
"           , contrib      >= 0.5.1\n"
"           , elab-util    >= 0.5.0\n"
"           , pretty-show  >= 0.5.0\n"
"           , sop          >= 0.5.0\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:745
#, no-wrap
msgid ""
"As you can see, *hedgehog* depends on *base* and *contrib*,\n"
"both of which are part of every Idris installation, but\n"
"also on\n"
"[*elab-util*](https://github.com/stefan-hoeck/idris2-elab-util),\n"
"a library of utilities for writing elaborator scripts (a\n"
"powerful technique for creating Idris declarations by\n"
"writing Idris code; it comes with its own lengthy tutorial\n"
"if you are interested),\n"
"[*sop*](https://github.com/stefan-hoeck/idris2-sop), a library\n"
"for generically deriving interface implementations via a\n"
"*sum of products* representation (this is a useful thing\n"
"you might want to check out some day), and\n"
"[*pretty-show*](https://github.com/stefan-hoeck/idris2-pretty-show),\n"
"a library for pretty printing Idris values (*hedgehog* makes\n"
"use of this in case a test fails).\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:752
#, no-wrap
msgid ""
"So, before you actually can use *hedgehog* to write some\n"
"property tests for your own project, you will need to\n"
"install the packages it depends on before installing\n"
"*hedgehog* itself. Since this can be tedious to do manually,\n"
"it is best let a package manager like pack handle this task\n"
"for you.\n"
msgstr ""

#. type: Title ####
#: ../src/Appendices/Projects.md:753
#, fuzzy, no-wrap
#| msgid "Dependent Pairs"
msgid "Dependency Versions"
msgstr "依赖对"

#. type: Plain text
#: ../src/Appendices/Projects.md:760
#, no-wrap
msgid ""
"You might want to specify a certain version (or a range)\n"
"Idris should use for your dependencies. This might be useful\n"
"if you have several versions of the same package installed\n"
"and not all of them are compatible with your project.\n"
"Here are several examples:\n"
msgstr ""

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:761
#, no-wrap
msgid ""
"depends    = base         == 0.5.1\n"
"           , contrib      == 0.5.1\n"
"           , elab-util    >= 0.5.0\n"
"           , pretty-show\n"
"           , sop          >= 0.5.0 && < 0.6.0\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:776
#, no-wrap
msgid ""
"This will look for packages *base* and *contrib* of\n"
"exactly the given version, package *elab-util* of a version\n"
"greater than or equal to `0.5.0`, package *pretty-show* of\n"
"any version, and package *sop* of a version in the given\n"
"range. In all cases, if several installed versions of a\n"
"package match the specified range, the latest version will\n"
"be used.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:780
#, no-wrap
msgid ""
"In order to make use of this for your own packages, every\n"
"`.ipkg` file should give the package's name and current\n"
"version:\n"
msgstr ""

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:781
#, no-wrap
msgid ""
"package tutorial\n"
"\n"
"version    = 0.1.0\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:792
#, no-wrap
msgid ""
"As I'll show below, package versions play a much less crucial role\n"
"when using pack and its curated package collection. But even then\n"
"you might want to consider restricting the versions of packages you\n"
"accept in order to make sure you catch any braking changes introduced\n"
"upstream.\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:793
#, no-wrap
msgid "Library Modules"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:806
#, no-wrap
msgid ""
"Many if not most Idris packages available on GitHub are\n"
"programming *libraries*: They implement some piece of\n"
"functionality and make it available to all projects depending on\n"
"the given package. This is unlike Idris *applications*, which\n"
"are supposed to be compiled to an executable that can then\n"
"be run on your computer. The Idris project itself provides\n"
"both: The Idris compiler application, which we use to\n"
"type check and build other Idris libraries and applications,\n"
"and several libraries like *prelude*, *base*, and *contrib*,\n"
"which provide basic data types and functions useful in\n"
"most Idris projects.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:810
#, no-wrap
msgid ""
"In order to type check and install the modules you wrote in a\n"
"library, you must list them in the `.ipkg` file's `modules` field.\n"
"Here is an excerpt from the *sop* package:\n"
msgstr ""

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:811
#, no-wrap
msgid ""
"modules = Data.Lazy\n"
"        , Data.SOP\n"
"        , Data.SOP.Interfaces\n"
"        , Data.SOP.NP\n"
"        , Data.SOP.NS\n"
"        , Data.SOP.POP\n"
"        , Data.SOP.SOP\n"
"        , Data.SOP.Utils\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:824
#, no-wrap
msgid ""
"Modules missing from this list will *not* be installed and hence\n"
"will not be available for other packages depending on the sop library.\n"
msgstr ""

#. type: Title ###
#: ../src/Appendices/Projects.md:825
#, no-wrap
msgid "Pack and its curated Collection of Packages"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:833
#, no-wrap
msgid ""
"When the dependency graph of your project is getting large and complex, that is,\n"
"when your project depends on many libraries, which themselves depend on yet\n"
"other libraries, it can happen that two packages depend both on different -\n"
"and, possibly, incompatible - versions of a third package.\n"
"This situation can be nigh to impossible to resolve, and can lead to a lot\n"
"of frustration when working with conflicting libraries.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:841
#, no-wrap
msgid ""
"It is therefore the philosophy of the pack project to avoid such a situation\n"
"from the very beginning by making use of *curated package collections*. A pack\n"
"collection consists of a specific Git commit of the Idris compiler and a set\n"
"of packages, again each at a specific Git commit, all of which have been\n"
"tested to work well and without issues together. You can see a list of\n"
"packages available to pack\n"
"[here](https://github.com/stefan-hoeck/idris2-pack-db/blob/main/STATUS.md).\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:852
#, no-wrap
msgid ""
"Whenever a project you are working on depends on one of the libraries listed\n"
"in pack's package collection, pack will automatically install it and all of its\n"
"dependencies for you. However, you might also want to depend on a library that\n"
"is not yet part of pack's collection. In that case, you must specify the\n"
"library in question in one of your `pack.toml` files - the global\n"
"one found at `$HOME/.pack/user/pack.toml`, or one local to your\n"
"current project or one of its parent directories (if any).\n"
"There, you can either specify a dependency local\n"
"to your system or a Git project (local or remote). An example for each is\n"
"shown below:\n"
msgstr ""

#. type: Fenced code block (toml)
#: ../src/Appendices/Projects.md:853
#, no-wrap
msgid ""
"[custom.all.foo]\n"
"type = \"local\"\n"
"path = \"/path/to/foo\"\n"
"ipkg = \"foo.ipkg\"\n"
"\n"
"[custom.all.bar]\n"
"type   = \"github\"\n"
"url    = \"https://github.com/me/bar\"\n"
"commit = \"latest:main\"\n"
"ipkg   = \"bar.ipkg\"\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:872
#, no-wrap
msgid ""
"As you can see, in both cases you have to specify where the project can be\n"
"found as well as the name and location of its `.ipkg` file. In case of\n"
"a Git project, you also need to tell pack the commit it should use.\n"
"In the example above, we want to use the latest commit from the `main`\n"
"branch. We can use `pack fetch` to fetch and store the currently latest\n"
"commit hash.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:877
#, no-wrap
msgid ""
"Entries like the ones given above are all that is needed to add support to\n"
"custom libraries to pack. You can now list these libraries as dependencies\n"
"in your own project's `.ipkg` file and pack will automatically install them\n"
"for you.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Projects.md:888
#, no-wrap
msgid ""
"This concludes our section about structuring Idris projects. We have learned\n"
"about several types of code blocks - `failing` blocks for showing that a\n"
"piece of code fails to elaborate, `namespace`s for having overloaded names\n"
"in the same source file, and parameter blocks for sharing lists of\n"
"parameters between functions - and how to group several source files into\n"
"an Idris library or application. Finally, we learned how to include\n"
"external libraries in an Idris project and how to use pack to help us\n"
"keep track of these dependencies.\n"
msgstr ""
