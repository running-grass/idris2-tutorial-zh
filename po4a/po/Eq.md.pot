# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, no-wrap
msgid "Exercises part 4"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Eq.md:1
#, no-wrap
msgid "Propositional Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:9
#, no-wrap
msgid ""
"In the [last chapter](DPair.md) we learned, how dependent pairs\n"
"and records can be used to calculate *types* from values only known\n"
"at runtime by pattern matching on these values. We will now look\n"
"at how we can describe relations - or *contracts* - between\n"
"values as types, and how we can use values of these types as\n"
"proofs that the contracts hold.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:10
#, no-wrap
msgid ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:21
#, no-wrap
msgid "Equality as a Type"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:26
#, no-wrap
msgid ""
"Imagine, we'd like to concatenate the contents of two CSV files,\n"
"both of which we stored on disk as tables together with their schemata\n"
"as shown in our discussion about dependent pairs:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:27
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:55
#, no-wrap
msgid ""
"We will not be able to implement `concatTables1` by appending the\n"
"two row vectors, unless we can somehow verify that the two schemata\n"
"are identical. \"Well,\" I hear you say, \"that shouldn't be a big issue!\n"
"Just implement `Eq` for `ColType`\". Let's give this a try:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:56
#, no-wrap
msgid ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:73
#, no-wrap
msgid ""
"Somehow, this doesn't seem to work. If we inspect the context of hole\n"
"`what_now`, Idris still thinks that `s1` and `s2` are different, and\n"
"if we go ahead and invoke `Vect.(++)` anyway in the `True` case,\n"
"Idris will respond with a type error.\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:74
#, no-wrap
msgid ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:92
#, no-wrap
msgid ""
"The problem is, that there is no reason for Idris to unify the two\n"
"values, even though `(==)` returned `True` because the result of `(==)`\n"
"holds no other information than the type being a `Bool`. *We* think,\n"
"if this is `True` the two values should be identical, but Idris is not\n"
"convinced. In fact, the following implementation of `Eq ColType`\n"
"would be perfectly fine as far as the type checker is concerned:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:93
#, no-wrap
msgid ""
"Eq ColType where\n"
"  _       == _       = True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:106
#, no-wrap
msgid ""
"So Idris is right in not trusting us. You might expect it to inspect the\n"
"implementation of `(==)` and figure out on its own, what the `True` result\n"
"means, but this is not how these things work in general, because most of the\n"
"time the number of computational paths to check would be far too large.\n"
"As a consequence, Idris is able to evaluate functions during\n"
"unification, but it will not trace back information about function\n"
"arguments from a function's result for us. We can do so manually, however,\n"
"as we will see later.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:107
#, no-wrap
msgid "A Type for equal Schemata"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:114
#, no-wrap
msgid ""
"The problem described above is similar to what we saw when\n"
"we talked about the benefit of [singleton types](DPair.md#erased-existentials):\n"
"The types are not precise enough. What we are going to do now,\n"
"is something we'll repeat time again for different use cases:\n"
"We encode a contract between values in an indexed data type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:115
#, no-wrap
msgid ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:124
#, no-wrap
msgid ""
"First, note how `SameSchema` is a family of types indexed over two\n"
"values of type `Schema`. But note also that the sole constructor\n"
"restricts the values we allow for `s1` and `s2`: The two indices\n"
"*must* be identical.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:128
#, no-wrap
msgid ""
"Why is this useful? Well, imagine we had a function for checking\n"
"the equality of two schemata, which would try and return a value\n"
"of type `SameSchema s1 s2`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:129
#, no-wrap
msgid "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:134
#, no-wrap
msgid "We could then use this function to implement `concatTables`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:135
#, no-wrap
msgid ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:143
#, no-wrap
msgid "It worked! What's going on here? Well, let's inspect the types involved:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:144
#, no-wrap
msgid ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:152
#, no-wrap
msgid "At the REPL, we get the following context for `almost_there`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:153
#, no-wrap
msgid ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:168
#, no-wrap
msgid ""
"See, how the types of `rs1` and `rs2` unify? Value `Same`, coming as the\n"
"result of `sameSchema s1 s2`, is a *witness* that `s1` and `s2` are actually\n"
"identical, because this is what we specified in the definition of `Same`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:172
#, no-wrap
msgid ""
"All that remains to do is to implement `sameSchema`. For this, we will write\n"
"another data type for specifying when two values of type `ColType` are\n"
"identical:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:173
#, no-wrap
msgid ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:180
#, no-wrap
msgid ""
"We can now define several utility functions. First, one for figuring out\n"
"if two column types are identical:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:181
#, no-wrap
msgid ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:195
#, no-wrap
msgid ""
"This will convince Idris, because in each pattern match, the return\n"
"type will be adjusted according to the values we matched on. For instance,\n"
"on the first line, the output type is `Maybe (SameColType I64 I64)` as\n"
"you can easily verify yourself by inserting a hole and checking its\n"
"type at the REPL.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:203
#, no-wrap
msgid ""
"We will need two additional utilities: Functions for creating values\n"
"of type `SameSchema` for the nil and cons cases. Please note, how\n"
"the implementations are trivial. Still, we often have to quickly\n"
"write such small proofs (I'll explain in the next section, why I\n"
"call them *proofs*), which will then be used to convince the\n"
"type checker about some fact we already take for granted but Idris\n"
"does not.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:204
#, no-wrap
msgid ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:221
#, no-wrap
msgid ""
"As usual, it can help understanding what's going on by replacing\n"
"the right hand side of `sameCons` with a hole an check out its\n"
"type and context at the REPL. The presence of values `SameCT`\n"
"and `Same` on the left hand side forces Idris to unify `c1` and `c2`\n"
"as well as `s1` and `s2`, from which the unification of\n"
"`c1 :: s1` and `c2 :: s2` immediately follows.\n"
"With these, we can finally implement `sameSchema`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:222
#, no-wrap
msgid ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:238
#, no-wrap
msgid ""
"What we described here is a far stronger form of equality\n"
"than what is provided by interface `Eq` and the `(==)`\n"
"operator: Equality of values that is accepted by the\n"
"type checker when trying to unify type level indices.\n"
"This is also called *propositional equality*: We will see\n"
"below, that we can view types as mathematical *propositions*,\n"
"and values of these types a *proofs* that these propositions\n"
"hold.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:239
#, no-wrap
msgid "Type `Equal`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:251
#, no-wrap
msgid ""
"Propositional equality is such a fundamental concept, that the *Prelude*\n"
"exports a general data type for this already: `Equal`, with its only\n"
"data constructor `Refl`. In addition, there is a built-in operator\n"
"for expressing propositional equality, which gets desugared to `Equal`:\n"
"`(=)`. This can sometimes lead to some confusion, because the equals\n"
"symbol is also used for *definitional equality*: Describing in function\n"
"implementations that the left-hand side and right-hand side are\n"
"defined to be equal. If you want to disambiguate propositional from\n"
"definitional equality, you can also use operator `(===)` for the\n"
"former.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:253
#, no-wrap
msgid "Here is another implementation of `concatTables`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:254
#, no-wrap
msgid ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) |]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:285
#, no-wrap
msgid ""
"In the following exercises, you are going to implement\n"
"some very basic properties of equality proofs. You'll\n"
"have to come up with the types of the functions yourself,\n"
"as the implementations will be incredibly simple.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:289
#, no-wrap
msgid ""
"Note: If you can't remember what the terms \"reflexive\",\n"
"\"symmetric\", and \"transitive\" mean, quickly read about\n"
"equivalence relations [here](https://en.wikipedia.org/wiki/Equivalence_relation).\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:291
#, no-wrap
msgid "Show that `SameColType` is a reflexive relation.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:293
#, no-wrap
msgid "Show that `SameColType` is a symmetric relation.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:295
#, no-wrap
msgid "Show that `SameColType` is a transitive relation.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:299
#, no-wrap
msgid ""
"Let `f` be a function of type `ColType -> a` for an\n"
"arbitrary type `a`. Show that from a value of type\n"
"`SameColType c1 c2` follows that `f c1` and `f c2` are equal.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:303
#, no-wrap
msgid ""
"For `(=)` the above properties are available from the *Prelude*\n"
"as functions `sym`, `trans`, and `cong`. Reflexivity comes\n"
"from the data constructor `Refl` itself.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:307
#, no-wrap
msgid ""
"Implement a function for verifying that two natural\n"
"numbers are identical. Try using `cong` in your\n"
"implementation.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:310
#, no-wrap
msgid ""
"Use the function from exercise 5 for zipping two\n"
"`Table`s if they have the same number of rows.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:315
#, no-wrap
msgid ""
"   Hint: Use `Vect.zipWith`. You will need to implement\n"
"   custom function `appRows` for this, since Idris will\n"
"   not automatically figure out that the types unify when\n"
"   using `HList.(++)`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:316
#, no-wrap
msgid "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:323
#, no-wrap
msgid ""
"We will later learn how to use *rewrite rules* to circumvent\n"
"the need of writing custom functions like `appRows` and use\n"
"`(++)` in `zipWith` directly.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:324
#, no-wrap
msgid "Programs as Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:333
#, no-wrap
msgid ""
"A famous observation by mathematician *Haskell Curry* and\n"
"logician *William Alvin Howard* leads to the conclusion,\n"
"that we can view a *type* in a programming language with\n"
"a sufficiently rich type system as a mathematical proposition\n"
"and a total program calculating a *value* of this type as a\n"
"proof that the proposition holds. This is also known as the\n"
"[Curry-Howard isomorphism](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:336
#, no-wrap
msgid ""
"For instance, here is a simple proof that one plus one\n"
"equals two:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:337
#, no-wrap
msgid ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:346
#, no-wrap
msgid ""
"The above proof is trivial, as Idris solves this by unification.\n"
"But we already stated some more interesting things in the\n"
"exercises. For instance, the symmetry and transitivity of\n"
"`SameColType`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:347
#, no-wrap
msgid ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 c3\n"
"sctTransitive SameCT SameCT = SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:357
#, no-wrap
msgid ""
"Note, that a type alone is not a proof. For instance, we are free\n"
"to state that one plus one equals three:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:358
#, no-wrap
msgid "onePlusOneWrong : the Nat 1 + 1 = 3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:365
#, no-wrap
msgid ""
"We will, however, have a hard time implementing this in a provably\n"
"total way. We say: \"The type `the Nat 1 + 1 = 3` is *uninhabited*\",\n"
"meaning, that there is no value of this type.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:366
#, no-wrap
msgid "When Proofs replace Tests"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:373
#, no-wrap
msgid ""
"We will see several different use cases for compile time proofs, a\n"
"very straight forward one being to show that our functions behave\n"
"as they should by proofing some properties about them. For instance,\n"
"here is a proposition that `map` on list does not change the number of\n"
"elements in the list:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:374
#, no-wrap
msgid "mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:381
#, no-wrap
msgid ""
"Read this as a universally quantified statement: For all functions `f`\n"
"from `a` to `b` and for all lists `as` holding values of type `a`,\n"
"the length of `map f as` is the same the as the length of the original list.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:387
#, no-wrap
msgid ""
"We can implement `mapListLength` by pattern matching on `as`. The `Nil` case\n"
"will be trivial: Idris solves this by unification. It knows the value of the\n"
"input list (`Nil`), and since `map` is implemented by pattern matching on\n"
"the input as well, it follows immediately that the result will be `Nil` as\n"
"well:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:388
#, no-wrap
msgid "mapListLength f []        = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:395
#, no-wrap
msgid ""
"The `cons` case is more involved, and we will do this stepwise.\n"
"First, note that we can proof that the length of a map over the\n"
"tail will stay the same by means of recursion:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:397
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:403
#, no-wrap
msgid "Let's inspect the types and context we have here:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:404
#, no-wrap
msgid ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:422
#, no-wrap
msgid ""
"So, we have a proof of type `length xs = length (map f xs)`,\n"
"and from the implementation of `map` Idris concludes that what\n"
"we are actually looking for is a result of type\n"
"`S (length xs) = S (length (map f xs))`. This is exactly what\n"
"function `cong` from the *Prelude* is for (\"cong\" is an abbreviation\n"
"for *congruence*). We can thus implement the *cons* case\n"
"concisely like so:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:423
#, no-wrap
msgid "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:431
#, no-wrap
msgid ""
"Please take a moment to appreciate what we achieved here:\n"
"A *proof* in the mathematical sense that our function will not\n"
"affect the length of our list. We no longer need a unit test\n"
"or similar program to verify this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:435
#, no-wrap
msgid ""
"Before we continue, please note an important thing: In our\n"
"case expression, we used a *variable* for the result from the\n"
"recursive call:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:436
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:448
#, no-wrap
msgid ""
"Here, we did not want the two lengths to unify, because we\n"
"needed the distinction in our call to `cong`. Therefore: If\n"
"you need a proof of type `x = y` in order for two variables\n"
"to unify, use the `Refl` data constructor in the pattern match.\n"
"If, on the other hand, you need to run further computations on\n"
"such a proof, use a variable and the left and right-hand sides\n"
"will remain distinct.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:453
#, no-wrap
msgid ""
"Here is another example from the last chapter: We want to show\n"
"that parsing and printing column types behaves correctly.\n"
"Writing proofs about parsers can be very hard in general, but\n"
"here it can be done with a mere pattern match:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:454
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:477
#, no-wrap
msgid ""
"Such simple proofs give us quick but strong guarantees\n"
"that we did not make any stupid mistakes.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:485
#, no-wrap
msgid ""
"The examples we saw so far were very easy to implement. In general,\n"
"this is not the case, and we will have to learn about several\n"
"additional techniques in order to proof interesting things about\n"
"our programs. However, when we use Idris as a general purpose\n"
"programming language and not as a proof assistant, we are free\n"
"to choose whether some aspect of our code needs such strong\n"
"guarantees or not.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:486
#, no-wrap
msgid "A Note of Caution: Lowercase Identifiers in Function Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:494
#, no-wrap
msgid ""
"When writing down the types of proofs as we did above, one\n"
"has to be very careful not to fall into the following trap:\n"
"In general, Idris will treat lowercase identifiers in\n"
"function types as type parameters (erased implicit arguments).\n"
"For instance, here is a try at proofing the identity functor\n"
"law for `Maybe`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:495
#, no-wrap
msgid ""
"mapMaybeId1 : (ma : Maybe a) -> map id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:504
#, no-wrap
msgid ""
"You will not be able to implement the `Just` case, because\n"
"Idris treats `id` as an implicit argument as can easily be\n"
"seen when inspecting the context of `mapMaybeId1_rhs`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:505
#, no-wrap
msgid ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:517
#, no-wrap
msgid ""
"As you can see, `id` is an erased argument of type `a -> a`. And in\n"
"fact, when type-checking this module, Idris will issue a warning that\n"
"parameter `id` is shadowing an existing function:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:518
#, no-wrap
msgid ""
"Warning: We are about to implicitly bind the following lowercase names.\n"
"You may be unintentionally shadowing the associated global definitions:\n"
"  id is shadowing Prelude.Basics.id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:527
#, no-wrap
msgid ""
"The same is not true for `map`: Since we explicitly pass arguments\n"
"to `map`, Idris treats this as a function name and not as an\n"
"implicit argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:530
#, no-wrap
msgid ""
"You have several options here. For instance, you could use an uppercase\n"
"identifier, as these will never be treated as implicit arguments:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:531
#, no-wrap
msgid ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:543
#, no-wrap
msgid ""
"As an alternative - and this is the preferred way to handle this case -\n"
"you can prefix `id` with part of its namespace, which will immediately\n"
"resolve the issue:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:544
#, no-wrap
msgid ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:554
#, no-wrap
msgid ""
"Note: If you have semantic highlighting turned on in your editor\n"
"(for instance, by using the [idris2-lsp plugin](https://github.com/idris-community/idris2-lsp)),\n"
"you will note that `map` and `id` in `mapMaybeId1` get\n"
"highlighted differently: `map` as a function name, `id` as a bound variable.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:562
#, no-wrap
msgid ""
"In these exercises, you are going to proof several simple properties\n"
"of small functions. When writing proofs, it is even more important\n"
"to use holes to figure out what Idris expects from you next. Use\n"
"the tools given to you, instead of trying to find your way in the\n"
"dark!\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:564
#, no-wrap
msgid "Proof that `map id` on an `Either e` returns the value unmodified.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:566
#, no-wrap
msgid "Proof that `map id` on a list returns the list unmodified.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:570
#, no-wrap
msgid ""
"Proof that complementing a strand of a nucleobase\n"
"(see the [previous chapter](DPair.md#use-case-nucleic-acids))\n"
"twice leads to the original strand.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:574
#, no-wrap
msgid ""
"   Hint: Proof this for single bases first, and use `cong2`\n"
"   from the *Prelude* in your implementation for sequences\n"
"   of nucleic acids.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:576
#, no-wrap
msgid "Implement function `replaceVect`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:577
#, no-wrap
msgid "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:584
#, no-wrap
msgid ""
"   Now proof, that after replacing an element in a vector\n"
"   using `replaceAt` accessing the same element using\n"
"   `index` will return the value we just added.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:586
#, no-wrap
msgid "Implement function `insertVect`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:587
#, no-wrap
msgid "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:593
#, no-wrap
msgid ""
"   Use a similar proof as in exercise 4 to show that this\n"
"   behaves correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:596
#, no-wrap
msgid ""
"Note: Functions `replaceVect` and `insertVect` are available\n"
"from `Data.Vect` as `replaceAt` and `insertAt`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:597
#, no-wrap
msgid "Into the Void"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:612
#, no-wrap
msgid ""
"Remember function `onePlusOneWrong` from above? This was definitely\n"
"a wrong statement: One plus one does not equal three. Sometimes,\n"
"we want to express exactly this: That a certain statement is false\n"
"and does not hold. Consider for a moment what it means to proof\n"
"a statement in Idris: Such a statement (or proposition) is a\n"
"type, and a proof of the statement is a value or expression of\n"
"this type: The type is said to be *inhabited*.\n"
"If a statement is not true, there can be no value\n"
"of the given type. We say, the given type is *uninhabited*.\n"
"If we still manage to get our hands on a value of an uninhabited\n"
"type, that is a logical contradiction and from this, anything\n"
"follows (remember\n"
"[ex falso quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion)).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:617
#, no-wrap
msgid ""
"So this is how to express that a proposition does not hold: We\n"
"state that if it *would* hold, this would lead to a contradiction.\n"
"The most natural way to express a contradiction in Idris is\n"
"to return a value of type `Void`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:618
#, no-wrap
msgid ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:628
#, no-wrap
msgid ""
"See how this is a provably total implementation of the\n"
"given type: A function from `1 + 1 = 3` to `Void`. We\n"
"implement this by pattern matching, and there is only\n"
"one constructor to match on, which leads to an impossible\n"
"case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:633
#, no-wrap
msgid ""
"We can also use contradictory statements to proof other such\n"
"statements. For instance, here is a proof that if the lengths\n"
"of two lists are not the same, then the two list can't be\n"
"the same either:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:634
#, no-wrap
msgid ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:642
#, no-wrap
msgid ""
"This is cumbersome to write and pretty hard to read, so there\n"
"is function `Not` in the prelude to express the same thing\n"
"more naturally:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:643
#, no-wrap
msgid ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:651
#, no-wrap
msgid ""
"Actually, this is just a specialized version of the contraposition of\n"
"`cong`: If from `a = b` follows `f a = f b`, then from\n"
"`not (f a = f b)` follows `not (a = b)`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:652
#, no-wrap
msgid ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun x = fun $ cong f x\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:657
#, no-wrap
msgid "Interface `Uninhabited`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:664
#, no-wrap
msgid ""
"There is an interface in the *Prelude* for uninhabited types: `Uninhabited`\n"
"with its sole function `uninhabited`. Have a look at its documentation at\n"
"the REPL. You will see, that there is already an impressive number\n"
"of implementations available, many of which involve data type\n"
"`Equal`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:667
#, no-wrap
msgid ""
"We can use `Uninhabited`, to for instance express that\n"
"the empty schema is not equal to a non-empty schema:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:668
#, no-wrap
msgid ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:678
#, no-wrap
msgid ""
"There is a related function you need to know about: `absurd`, which\n"
"combines `uninhabited` with `void`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:679
#, no-wrap
msgid ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:685
#, no-wrap
msgid "Decidable Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:703
#, no-wrap
msgid ""
"When we implemented `sameColType`, we got a proof that two\n"
"column types are indeed the same, from which we could figure out,\n"
"whether two schemata are identical. The types guarantee\n"
"we do not generate any false positives: If we generate a value\n"
"of type `SameSchema s1 s2`, we have a proof that `s1` and `s2`\n"
"are indeed identical.\n"
"However, `sameColType` and thus `sameSchema` could theoretically\n"
"still produce false negatives by returning `Nothing`\n"
"although the two values are identical. For instance,\n"
"we could implement `sameColType` in such a way that it\n"
"always returns `Nothing`. This would be in agreement with\n"
"the types, but definitely not what we want. So, here is\n"
"what we'd like to do in order to get yet stronger guarantees:\n"
"We'd either want to return a proof that the two schemata\n"
"are the same, or return a proof that the two schemata\n"
"are not the same. (Remember that `Not a` is an alias for `a -> Void`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:708
#, no-wrap
msgid ""
"We call a property, which either holds or leads to a\n"
"contradiction a *decidable property*, and the *Prelude*\n"
"exports data type `Dec prop`, which encapsulates this\n"
"distinction.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:710
#, no-wrap
msgid "Here is a way to encode this for `ColType`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:711
#, no-wrap
msgid ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:741
#, no-wrap
msgid ""
"First, note how we could use a pattern match in a single\n"
"argument lambda directly. This is sometimes called the\n"
"*lambda case* style, named after an extension of the Haskell\n"
"programming language. If we use the `SameCT` constructor\n"
"in the pattern match, Idris is forced to try and unify for instance\n"
"`Float` with `I64`. This is not possible, so the case as\n"
"a whole is impossible.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:749
#, no-wrap
msgid ""
"Yet, this was pretty cumbersome to implement. In order to\n"
"convince Idris we did not miss a case,\n"
"there is no way around treating every possible pairing\n"
"of constructors explicitly.\n"
"However, we get *much* stronger guarantees out of this: We\n"
"can no longer create false positives *or* false negatives, and\n"
"therefore, `decSameColType` is provably correct.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:752
#, no-wrap
msgid ""
"Doing the same thing for schemata requires some utility functions,\n"
"the types of which we can figure out by placing some holes:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:753
#, no-wrap
msgid ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:770
#, no-wrap
msgid ""
"The first two cases are not too hard. The type of `decss1` is\n"
"`SameSchema [] (y :: ys) -> Void`, which you can easily verify\n"
"at the REPL. But that's just `uninhabited`, specialized to\n"
"`SameSchema [] (y :: ys)`, and this we already implemented\n"
"further above. The same goes for `decss2`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:777
#, no-wrap
msgid ""
"The other two cases are harder, so I already filled in as much stuff\n"
"as possible. We know that we want to return a `No`, if either the\n"
"heads or tails are provably distinct. The `No` holds a\n"
"function, so I already added a lambda, leaving a hole only for\n"
"the return value. Here are the type and - more important -\n"
"context of `decss3`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:778
#, no-wrap
msgid ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:797
#, no-wrap
msgid ""
"The types of `contra` and `prf` are what we need here:\n"
"If `xs` and `ys` are distinct, then `y :: xs` and `y :: ys`\n"
"must be distinct as well. This is the contraposition of the\n"
"following statement: If `x :: xs` is the same as `y :: ys`,\n"
"then `xs` and `ys` are the same as well. We must therefore\n"
"implement a lemma, which proves that the *cons* constructor\n"
"is [*injective*](https://en.wikipedia.org/wiki/Injective_function):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:798
#, no-wrap
msgid ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:809
#, no-wrap
msgid ""
"We can now pass `prf` to `consInjective` to extract a value of\n"
"type `SameSchema xs ys`, which we then pass to `contra` in\n"
"order to get the desired value of type `Void`.\n"
"With these observations and utilities, we can now implement\n"
"`decSameSchema`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:810
#, no-wrap
msgid ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:825
#, no-wrap
msgid ""
"There is an interface called `DecEq` exported by module `Decidable.Equality`\n"
"for types for which we can implement a decision procedure for propositional\n"
"equality. We can implement this to figure out if two values are equal or not.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:830
#, no-wrap
msgid ""
"Show that there can be no non-empty vector of `Void`\n"
"by writing a corresponding implementation of uninhabited\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:832
#, no-wrap
msgid "Generalize exercise 1 for all uninhabited element types.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:835
#, no-wrap
msgid ""
"Show that if `a = b` cannot hold, then `b = a` cannot hold\n"
"either.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:838
#, no-wrap
msgid ""
"Show that if `a = b` holds, and `b = c` cannot hold, then\n"
"`a = c` cannot hold either.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:841
#, no-wrap
msgid ""
"Implement `Uninhabited` for `Crud i a`. Try to be\n"
"as general as possible.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:851
#, no-wrap
msgid "Implement `DecEq` for `ColType`.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:856
#, no-wrap
msgid ""
"Implementations such as the one from exercise 6 are cumbersome\n"
"to write as they require a quadratic number of pattern matches\n"
"with relation to the number of data constructors. Here is a\n"
"trick how to make this more bearable.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Eq.md:859
#, no-wrap
msgid ""
"Implement a function `ctNat`, which assigns every value\n"
"of type `ColType` a unique natural number.\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Eq.md:864
#, no-wrap
msgid ""
"Proof that `ctNat` is injective.\n"
"Hint: You will need to pattern match on the `ColType`\n"
"values, but four matches should be enough to satisfy the\n"
"coverage checker.\n"
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Eq.md:869
#, no-wrap
msgid ""
"In your implementation of `DecEq` for `ColType`,\n"
"use `decEq` on the result of applying both column\n"
"types to `ctNat`, thus reducing it to only two lines of\n"
"code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:877
#, no-wrap
msgid ""
"   We will later talk about `with` rules: Special forms of\n"
"   dependent pattern matches, that allow us to learn something\n"
"   about the shape of function arguments by performing\n"
"   computations on them. These will allow us to use\n"
"   a similar technique as shown here to implement `DecEq`\n"
"   requiring only `n` pattern matches\n"
"   for arbitrary sum types with `n` data constructors.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:878
#, no-wrap
msgid "Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:888
#, no-wrap
msgid ""
"One of the most important use cases of propositional equality\n"
"is to replace or *rewrite* existing types, which Idris can't\n"
"unify automatically otherwise. For instance,\n"
"the following is no problem:\n"
"Idris know that `0 + n` equals `n`, because `plus` on\n"
"natural numbers is implemented by pattern matching on the\n"
"first argument. The two vector lengths therefore unify\n"
"just fine.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:889
#, no-wrap
msgid ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:899
#, no-wrap
msgid ""
"However, the example below can't be implemented as easily\n"
"(try it!), because Idris can't figure out on its own\n"
"that the two lengths unify.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:900
#, no-wrap
msgid ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:909
#, no-wrap
msgid ""
"Probably for the first time we realize, just how little\n"
"Idris knows about the laws of arithmetics. Idris is able\n"
"to unify values when\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, no-wrap
msgid "all values in a computation are known at compile time\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, no-wrap
msgid ""
"one expression follows directly from the other due\n"
"to the pattern matches used in a function's implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:917
#, no-wrap
msgid ""
"In expression `n + 0`,  not all values are known (`n` is a variable),\n"
"and `(+)` is implemented by pattern matching on the first\n"
"argument, about which we know nothing here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:923
#, no-wrap
msgid ""
"However, we can teach Idris. If we can proof that the two\n"
"expressions are equivalent, we can replace one expression\n"
"for the other, so that the two unify again. Here is a lemma\n"
"and its proof, that `n + 0` equals `n`, for all natural\n"
"numbers `n`.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:924
#, no-wrap
msgid ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:935
#, no-wrap
msgid ""
"Note, how the base case is trivial: Since there are no\n"
"variables left, Idris can immediately figure out that\n"
"`0 + 0 = 0`. In the recursive case, it can be instructive\n"
"to replace `cong S` with a hole and look at its type\n"
"and context to figure out how to proceed.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:940
#, no-wrap
msgid ""
"The *Prelude* exports function `replace` for substituting one\n"
"variable in a term by another, based on a proof of equality.\n"
"Make sure to inspect its type first before looking at the\n"
"example below:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:941
#, no-wrap
msgid ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:952
#, no-wrap
msgid ""
"As you can see, we *replace* a value of type `p x` with a value\n"
"of type `p y` based on a proof that `x = y`,\n"
"where `p` is a function from some type `t` to\n"
"`Type`, and `x` and `y` are values of type `t`. In our\n"
"`replaceVect` example, `t` equals `Nat`, `x` equals `n + 0`,\n"
"`y` equals `n`, and `p` equals `\\k => Vect k a`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:960
#, no-wrap
msgid ""
"Using `replace` directly is not very convenient, because Idris\n"
"can often not infer the value of `p` on its own. Indeed, we\n"
"had to give its type explicitly in `replaceVect`.\n"
"Idris therefore provides special syntax for such *rewrite rules*,\n"
"which will get desugared to calls to `replace` with all the\n"
"details filled in for us. Here is an implementation\n"
"of `replaceVect` with a rewrite rule:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:961
#, no-wrap
msgid ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:970
#, no-wrap
msgid ""
"One source of confusion is that *rewrite* uses proofs\n"
"of equality the other way round: Given an `y = x`\n"
"it replaces `p x` with `p y`. Hence the need to call `sym`\n"
"in our implementation above.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:971
#, no-wrap
msgid "Use Case: Reversing Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:982
#, no-wrap
msgid ""
"Rewrite rules are often required when we perform interesting\n"
"type-level computations. For instance,\n"
"we have already seen many interesting examples of functions\n"
"operating on `Vect`, which allowed us to keep track of the\n"
"exact lengths of the vectors involved, but one key\n"
"functionality has been missing from our discussions so far,\n"
"and for good reasons: Function `reverse`. Here is a possible\n"
"implementation, which is how `reverse` is implemented for\n"
"lists:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:984
#, no-wrap
msgid ""
"revOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto' xs []        = xs\n"
"revOnto' xs (x :: ys) = revOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = revOnto' []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:997
#, no-wrap
msgid ""
"As you might have guessed, this will not compile as the\n"
"length indices in the two clauses of `revOnto'` do\n"
"not unify.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1001
#, no-wrap
msgid ""
"The *nil* case is a case we've already seen above:\n"
"Here `n` is zero, because the second vector is empty,\n"
"so we have to convince Idris once again that `m + 0 = m`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1002
#, no-wrap
msgid ""
"revOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto xs [] = rewrite addZeroRight m in xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1013
#, no-wrap
msgid ""
"The second case is more complex. Here, Idris fails to unify\n"
"`S (m + len)` with `m + S len`, where `len` is the length of\n"
"`ys`, the tail of the second vector. Module `Data.Nat`\n"
"provides many proofs about arithmetic operations on natural\n"
"numbers, one of which is `plusSuccRightSucc`. Here's its\n"
"type:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:1014
#, no-wrap
msgid ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1032
#, no-wrap
msgid ""
"In our case, we want to replace `S (m + len)` with `m + S len`,\n"
"so we will need the version with arguments flipped. However, there\n"
"is one more obstacle: We need to invoke `plusSuccRightSucc`\n"
"with the length of `ys`, which is not given as an implicit\n"
"function argument of `revOnto`. We therefore need to pattern\n"
"match on `n` (the length of the second vector), in order to\n"
"bind the length of the tail to a variable. Remember, that we\n"
"are allowed to pattern match on an erased argument only if\n"
"the constructor used follows from a match on another, unerased,\n"
"argument (`ys` in this case). Here's the implementation of the\n"
"second case:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1033
#, no-wrap
msgid ""
"revOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in revOnto (x :: xs) ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1043
#, no-wrap
msgid ""
"I know from my own experience that this can be highly confusing\n"
"at first. If you use Idris as a general purpose programming language\n"
"and not as a proof assistant, you probably will not have to use\n"
"rewrite rules too often. Still, it is important to know that they\n"
"exist, as they allow us to teach complex equivalences to Idris.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:1044
#, no-wrap
msgid "A Note on Erasure"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1055
#, no-wrap
msgid ""
"Single value data types like `Unit`, `Equal`, or `SameSchema` have\n"
"not runtime relevance, as values of these types are always identical.\n"
"We can therefore always use them as erased function arguments while\n"
"still being able to pattern match on these values.\n"
"For instance, when you look at the type of `replace`, you will see\n"
"that the equality proof is an erased argument.\n"
"This allows us to run arbitrarily complex computations to produce\n"
"such values without fear of these computations slowing down\n"
"the compiled Idris program.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:1059
#, no-wrap
msgid "Implement `plusSuccRightSucc` yourself.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:1061
#, no-wrap
msgid "Proof that `minus n n` equals zero for all natural numbers `n`.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:1063
#, no-wrap
msgid "Proof that `minus n 0` equals n for all natural numbers `n`\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:1066
#, no-wrap
msgid ""
"Proof that `n * 1 = n` and `1 * n = n`\n"
"for all natural numbers `n`.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:1069
#, no-wrap
msgid ""
"Proof that addition of natural numbers is\n"
"commutative.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:1071
#, no-wrap
msgid "Implement a tail-recursive version of `map` for vectors.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:1073
#, no-wrap
msgid "Proof the following proposition:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1074
#, no-wrap
msgid ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Eq.md:1084
#, no-wrap
msgid ""
"Use the proof from exercise 7 to implement again a function\n"
"for  zipping two `Table`s, this time using a rewrite rule\n"
"plus `Data.HList.(++)` instead of custom function `appRows`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1096
#, no-wrap
msgid ""
"The concept of *types as propositions, values as proofs* is\n"
"a very powerful tool for writing provably correct programs. We\n"
"will therefore spend some more time defining data types\n"
"for describing contracts between values, and values of these\n"
"types as proofs that the contracts hold. This will allow\n"
"us to describe necessary pre- and postconditions for our functions,\n"
"thus reducing the need to return a `Maybe` or other failure type,\n"
"because due to the restricted input, our functions can no longer\n"
"fail.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1098
#, no-wrap
msgid "[Next chapter](./Predicates.md)\n"
msgstr ""
