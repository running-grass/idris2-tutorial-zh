# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Stefan HÃ¶ck
# This file is distributed under the same license as the Functional Programming in Idris 2 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Idris 2 1.0\n"
"POT-Creation-Date: 2025-05-15 20:00+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, no-wrap
msgid "Exercises part 4"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Eq.md:1
#, no-wrap
msgid "Propositional Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:9
msgid ""
"In the [last chapter](DPair.md) we learned, how dependent pairs and records "
"can be used to calculate *types* from values only known at runtime by "
"pattern matching on these values. We will now look at how we can describe "
"relations - or *contracts* - between values as types, and how we can use "
"values of these types as proofs that the contracts hold."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:10
#, no-wrap
msgid ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:21
#, no-wrap
msgid "Equality as a Type"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:26
msgid ""
"Imagine, we'd like to concatenate the contents of two CSV files, both of "
"which we stored on disk as tables together with their schemata as shown in "
"our discussion about dependent pairs:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:27
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:55
msgid ""
"We will not be able to implement `concatTables1` by appending the two row "
"vectors, unless we can somehow verify that the two schemata are identical. "
"\"Well,\" I hear you say, \"that shouldn't be a big issue! Just implement "
"`Eq` for `ColType`\". Let's give this a try:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:56
#, no-wrap
msgid ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:73
msgid ""
"Somehow, this doesn't seem to work. If we inspect the context of hole "
"`what_now`, Idris still thinks that `s1` and `s2` are different, and if we "
"go ahead and invoke `Vect.(++)` anyway in the `True` case, Idris will "
"respond with a type error."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:74
#, no-wrap
msgid ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:92
msgid ""
"The problem is, that there is no reason for Idris to unify the two values, "
"even though `(==)` returned `True` because the result of `(==)` holds no "
"other information than the type being a `Bool`. *We* think, if this is "
"`True` the two values should be identical, but Idris is not convinced. In "
"fact, the following implementation of `Eq ColType` would be perfectly fine "
"as far as the type checker is concerned:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:93
#, no-wrap
msgid ""
"Eq ColType where\n"
"  _       == _       = True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:106
msgid ""
"So Idris is right in not trusting us. You might expect it to inspect the "
"implementation of `(==)` and figure out on its own, what the `True` result "
"means, but this is not how these things work in general, because most of the "
"time the number of computational paths to check would be far too large.  As "
"a consequence, Idris is able to evaluate functions during unification, but "
"it will not trace back information about function arguments from a "
"function's result for us. We can do so manually, however, as we will see "
"later."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:107
#, no-wrap
msgid "A Type for equal Schemata"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:114
msgid ""
"The problem described above is similar to what we saw when we talked about "
"the benefit of [singleton types](DPair.md#erased-existentials): The types "
"are not precise enough. What we are going to do now, is something we'll "
"repeat time again for different use cases: We encode a contract between "
"values in an indexed data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:115
#, no-wrap
msgid ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:124
msgid ""
"First, note how `SameSchema` is a family of types indexed over two values of "
"type `Schema`. But note also that the sole constructor restricts the values "
"we allow for `s1` and `s2`: The two indices *must* be identical."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:128
msgid ""
"Why is this useful? Well, imagine we had a function for checking the "
"equality of two schemata, which would try and return a value of type "
"`SameSchema s1 s2`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:129
#, no-wrap
msgid "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:134
msgid "We could then use this function to implement `concatTables`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:135
#, no-wrap
msgid ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:143
msgid ""
"It worked! What's going on here? Well, let's inspect the types involved:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:144
#, no-wrap
msgid ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:152
msgid "At the REPL, we get the following context for `almost_there`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:153
#, no-wrap
msgid ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:168
msgid ""
"See, how the types of `rs1` and `rs2` unify? Value `Same`, coming as the "
"result of `sameSchema s1 s2`, is a *witness* that `s1` and `s2` are actually "
"identical, because this is what we specified in the definition of `Same`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:172
msgid ""
"All that remains to do is to implement `sameSchema`. For this, we will write "
"another data type for specifying when two values of type `ColType` are "
"identical:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:173
#, no-wrap
msgid ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:180
msgid ""
"We can now define several utility functions. First, one for figuring out if "
"two column types are identical:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:181
#, no-wrap
msgid ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:195
msgid ""
"This will convince Idris, because in each pattern match, the return type "
"will be adjusted according to the values we matched on. For instance, on the "
"first line, the output type is `Maybe (SameColType I64 I64)` as you can "
"easily verify yourself by inserting a hole and checking its type at the REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:203
msgid ""
"We will need two additional utilities: Functions for creating values of type "
"`SameSchema` for the nil and cons cases. Please note, how the "
"implementations are trivial. Still, we often have to quickly write such "
"small proofs (I'll explain in the next section, why I call them *proofs*), "
"which will then be used to convince the type checker about some fact we "
"already take for granted but Idris does not."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:204
#, no-wrap
msgid ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:221
msgid ""
"As usual, it can help understanding what's going on by replacing the right "
"hand side of `sameCons` with a hole an check out its type and context at the "
"REPL. The presence of values `SameCT` and `Same` on the left hand side "
"forces Idris to unify `c1` and `c2` as well as `s1` and `s2`, from which the "
"unification of `c1 :: s1` and `c2 :: s2` immediately follows.  With these, "
"we can finally implement `sameSchema`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:222
#, no-wrap
msgid ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:238
msgid ""
"What we described here is a far stronger form of equality than what is "
"provided by interface `Eq` and the `(==)` operator: Equality of values that "
"is accepted by the type checker when trying to unify type level indices.  "
"This is also called *propositional equality*: We will see below, that we can "
"view types as mathematical *propositions*, and values of these types a "
"*proofs* that these propositions hold."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:239
#, no-wrap
msgid "Type `Equal`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:251
msgid ""
"Propositional equality is such a fundamental concept, that the *Prelude* "
"exports a general data type for this already: `Equal`, with its only data "
"constructor `Refl`. In addition, there is a built-in operator for expressing "
"propositional equality, which gets desugared to `Equal`: `(=)`. This can "
"sometimes lead to some confusion, because the equals symbol is also used for "
"*definitional equality*: Describing in function implementations that the "
"left-hand side and right-hand side are defined to be equal. If you want to "
"disambiguate propositional from definitional equality, you can also use "
"operator `(===)` for the former."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:253
msgid "Here is another implementation of `concatTables`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:254
#, no-wrap
msgid ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) |]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:285
msgid ""
"In the following exercises, you are going to implement some very basic "
"properties of equality proofs. You'll have to come up with the types of the "
"functions yourself, as the implementations will be incredibly simple."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:289
msgid ""
"Note: If you can't remember what the terms \"reflexive\", \"symmetric\", and "
"\"transitive\" mean, quickly read about equivalence relations [here](https://"
"en.wikipedia.org/wiki/Equivalence_relation)."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:291
msgid "Show that `SameColType` is a reflexive relation."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:293
msgid "Show that `SameColType` is a symmetric relation."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:295
msgid "Show that `SameColType` is a transitive relation."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:299
msgid ""
"Let `f` be a function of type `ColType -> a` for an arbitrary type `a`. Show "
"that from a value of type `SameColType c1 c2` follows that `f c1` and `f c2` "
"are equal."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:303
msgid ""
"For `(=)` the above properties are available from the *Prelude* as functions "
"`sym`, `trans`, and `cong`. Reflexivity comes from the data constructor "
"`Refl` itself."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:307
msgid ""
"Implement a function for verifying that two natural numbers are identical. "
"Try using `cong` in your implementation."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:310
msgid ""
"Use the function from exercise 5 for zipping two `Table`s if they have the "
"same number of rows."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:315
#, no-wrap
msgid ""
"   Hint: Use `Vect.zipWith`. You will need to implement\n"
"   custom function `appRows` for this, since Idris will\n"
"   not automatically figure out that the types unify when\n"
"   using `HList.(++)`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:316
#, no-wrap
msgid "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:323
msgid ""
"We will later learn how to use *rewrite rules* to circumvent the need of "
"writing custom functions like `appRows` and use `(++)` in `zipWith` directly."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:324
#, no-wrap
msgid "Programs as Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:333
msgid ""
"A famous observation by mathematician *Haskell Curry* and logician *William "
"Alvin Howard* leads to the conclusion, that we can view a *type* in a "
"programming language with a sufficiently rich type system as a mathematical "
"proposition and a total program calculating a *value* of this type as a "
"proof that the proposition holds. This is also known as the [Curry-Howard "
"isomorphism](https://en.wikipedia.org/wiki/"
"Curry%E2%80%93Howard_correspondence)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:336
msgid "For instance, here is a simple proof that one plus one equals two:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:337
#, no-wrap
msgid ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:346
msgid ""
"The above proof is trivial, as Idris solves this by unification.  But we "
"already stated some more interesting things in the exercises. For instance, "
"the symmetry and transitivity of `SameColType`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:347
#, no-wrap
msgid ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 c3\n"
"sctTransitive SameCT SameCT = SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:357
msgid ""
"Note, that a type alone is not a proof. For instance, we are free to state "
"that one plus one equals three:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:358
#, no-wrap
msgid "onePlusOneWrong : the Nat 1 + 1 = 3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:365
msgid ""
"We will, however, have a hard time implementing this in a provably total "
"way. We say: \"The type `the Nat 1 + 1 = 3` is *uninhabited*\", meaning, "
"that there is no value of this type."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:366
#, no-wrap
msgid "When Proofs replace Tests"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:373
msgid ""
"We will see several different use cases for compile time proofs, a very "
"straight forward one being to show that our functions behave as they should "
"by proofing some properties about them. For instance, here is a proposition "
"that `map` on list does not change the number of elements in the list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:374
#, no-wrap
msgid "mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:381
msgid ""
"Read this as a universally quantified statement: For all functions `f` from "
"`a` to `b` and for all lists `as` holding values of type `a`, the length of "
"`map f as` is the same the as the length of the original list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:387
msgid ""
"We can implement `mapListLength` by pattern matching on `as`. The `Nil` case "
"will be trivial: Idris solves this by unification. It knows the value of the "
"input list (`Nil`), and since `map` is implemented by pattern matching on "
"the input as well, it follows immediately that the result will be `Nil` as "
"well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:388
#, no-wrap
msgid "mapListLength f []        = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:395
msgid ""
"The `cons` case is more involved, and we will do this stepwise.  First, note "
"that we can proof that the length of a map over the tail will stay the same "
"by means of recursion:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:397
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:403
msgid "Let's inspect the types and context we have here:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:404 ../src/Appendices/QTT.md:76
#, no-wrap
msgid ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:422
msgid ""
"So, we have a proof of type `length xs = length (map f xs)`, and from the "
"implementation of `map` Idris concludes that what we are actually looking "
"for is a result of type `S (length xs) = S (length (map f xs))`. This is "
"exactly what function `cong` from the *Prelude* is for (\"cong\" is an "
"abbreviation for *congruence*). We can thus implement the *cons* case "
"concisely like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:423
#, no-wrap
msgid "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:431
msgid ""
"Please take a moment to appreciate what we achieved here: A *proof* in the "
"mathematical sense that our function will not affect the length of our list. "
"We no longer need a unit test or similar program to verify this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:435
msgid ""
"Before we continue, please note an important thing: In our case expression, "
"we used a *variable* for the result from the recursive call:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:436
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:448
msgid ""
"Here, we did not want the two lengths to unify, because we needed the "
"distinction in our call to `cong`. Therefore: If you need a proof of type `x "
"= y` in order for two variables to unify, use the `Refl` data constructor in "
"the pattern match.  If, on the other hand, you need to run further "
"computations on such a proof, use a variable and the left and right-hand "
"sides will remain distinct."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:453
msgid ""
"Here is another example from the last chapter: We want to show that parsing "
"and printing column types behaves correctly.  Writing proofs about parsers "
"can be very hard in general, but here it can be done with a mere pattern "
"match:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:454
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:477
msgid ""
"Such simple proofs give us quick but strong guarantees that we did not make "
"any stupid mistakes."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:485
msgid ""
"The examples we saw so far were very easy to implement. In general, this is "
"not the case, and we will have to learn about several additional techniques "
"in order to proof interesting things about our programs. However, when we "
"use Idris as a general purpose programming language and not as a proof "
"assistant, we are free to choose whether some aspect of our code needs such "
"strong guarantees or not."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:486
#, no-wrap
msgid "A Note of Caution: Lowercase Identifiers in Function Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:494
msgid ""
"When writing down the types of proofs as we did above, one has to be very "
"careful not to fall into the following trap: In general, Idris will treat "
"lowercase identifiers in function types as type parameters (erased implicit "
"arguments).  For instance, here is a try at proofing the identity functor "
"law for `Maybe`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:495
#, no-wrap
msgid ""
"mapMaybeId1 : (ma : Maybe a) -> map id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:504
msgid ""
"You will not be able to implement the `Just` case, because Idris treats `id` "
"as an implicit argument as can easily be seen when inspecting the context of "
"`mapMaybeId1_rhs`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:505
#, no-wrap
msgid ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:517
#, no-wrap
msgid ""
"As you can see, `id` is an erased argument of type `a -> a`. And in\n"
"fact, when type-checking this module, Idris will issue a warning that\n"
"parameter `id` is shadowing an existing function:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:518
#, no-wrap
msgid ""
"Warning: We are about to implicitly bind the following lowercase names.\n"
"You may be unintentionally shadowing the associated global definitions:\n"
"  id is shadowing Prelude.Basics.id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:527
msgid ""
"The same is not true for `map`: Since we explicitly pass arguments to `map`, "
"Idris treats this as a function name and not as an implicit argument."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:530
msgid ""
"You have several options here. For instance, you could use an uppercase "
"identifier, as these will never be treated as implicit arguments:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:531
#, no-wrap
msgid ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:543
msgid ""
"As an alternative - and this is the preferred way to handle this case - you "
"can prefix `id` with part of its namespace, which will immediately resolve "
"the issue:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:544
#, no-wrap
msgid ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:554
msgid ""
"Note: If you have semantic highlighting turned on in your editor (for "
"instance, by using the [idris2-lsp plugin](https://github.com/idris-"
"community/idris2-lsp)), you will note that `map` and `id` in `mapMaybeId1` "
"get highlighted differently: `map` as a function name, `id` as a bound "
"variable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:562
msgid ""
"In these exercises, you are going to proof several simple properties of "
"small functions. When writing proofs, it is even more important to use holes "
"to figure out what Idris expects from you next. Use the tools given to you, "
"instead of trying to find your way in the dark!"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:564
msgid "Proof that `map id` on an `Either e` returns the value unmodified."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:566
msgid "Proof that `map id` on a list returns the list unmodified."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:570
msgid ""
"Proof that complementing a strand of a nucleobase (see the [previous chapter]"
"(DPair.md#use-case-nucleic-acids))  twice leads to the original strand."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:574
#, no-wrap
msgid ""
"   Hint: Proof this for single bases first, and use `cong2`\n"
"   from the *Prelude* in your implementation for sequences\n"
"   of nucleic acids.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:576
msgid "Implement function `replaceVect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:577
#, no-wrap
msgid "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:584
#, no-wrap
msgid ""
"   Now proof, that after replacing an element in a vector\n"
"   using `replaceAt` accessing the same element using\n"
"   `index` will return the value we just added.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:586
msgid "Implement function `insertVect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:587
#, no-wrap
msgid "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:593
#, no-wrap
msgid ""
"   Use a similar proof as in exercise 4 to show that this\n"
"   behaves correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:596
msgid ""
"Note: Functions `replaceVect` and `insertVect` are available from `Data."
"Vect` as `replaceAt` and `insertAt`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:597
#, no-wrap
msgid "Into the Void"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:612
msgid ""
"Remember function `onePlusOneWrong` from above? This was definitely a wrong "
"statement: One plus one does not equal three. Sometimes, we want to express "
"exactly this: That a certain statement is false and does not hold. Consider "
"for a moment what it means to proof a statement in Idris: Such a statement "
"(or proposition) is a type, and a proof of the statement is a value or "
"expression of this type: The type is said to be *inhabited*.  If a statement "
"is not true, there can be no value of the given type. We say, the given type "
"is *uninhabited*.  If we still manage to get our hands on a value of an "
"uninhabited type, that is a logical contradiction and from this, anything "
"follows (remember [ex falso quodlibet](https://en.wikipedia.org/wiki/"
"Principle_of_explosion))."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:617
msgid ""
"So this is how to express that a proposition does not hold: We state that if "
"it *would* hold, this would lead to a contradiction.  The most natural way "
"to express a contradiction in Idris is to return a value of type `Void`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:618
#, no-wrap
msgid ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:628
msgid ""
"See how this is a provably total implementation of the given type: A "
"function from `1 + 1 = 3` to `Void`. We implement this by pattern matching, "
"and there is only one constructor to match on, which leads to an impossible "
"case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:633
msgid ""
"We can also use contradictory statements to proof other such statements. For "
"instance, here is a proof that if the lengths of two lists are not the same, "
"then the two list can't be the same either:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:634
#, no-wrap
msgid ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:642
msgid ""
"This is cumbersome to write and pretty hard to read, so there is function "
"`Not` in the prelude to express the same thing more naturally:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:643
#, no-wrap
msgid ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:651
msgid ""
"Actually, this is just a specialized version of the contraposition of "
"`cong`: If from `a = b` follows `f a = f b`, then from `not (f a = f b)` "
"follows `not (a = b)`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:652
#, no-wrap
msgid ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun x = fun $ cong f x\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:657
#, no-wrap
msgid "Interface `Uninhabited`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:664
msgid ""
"There is an interface in the *Prelude* for uninhabited types: `Uninhabited` "
"with its sole function `uninhabited`. Have a look at its documentation at "
"the REPL. You will see, that there is already an impressive number of "
"implementations available, many of which involve data type `Equal`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:667
msgid ""
"We can use `Uninhabited`, to for instance express that the empty schema is "
"not equal to a non-empty schema:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:668
#, no-wrap
msgid ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:678
msgid ""
"There is a related function you need to know about: `absurd`, which combines "
"`uninhabited` with `void`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:679
#, no-wrap
msgid ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:685
#, no-wrap
msgid "Decidable Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:703
#, no-wrap
msgid ""
"When we implemented `sameColType`, we got a proof that two\n"
"column types are indeed the same, from which we could figure out,\n"
"whether two schemata are identical. The types guarantee\n"
"we do not generate any false positives: If we generate a value\n"
"of type `SameSchema s1 s2`, we have a proof that `s1` and `s2`\n"
"are indeed identical.\n"
"However, `sameColType` and thus `sameSchema` could theoretically\n"
"still produce false negatives by returning `Nothing`\n"
"although the two values are identical. For instance,\n"
"we could implement `sameColType` in such a way that it\n"
"always returns `Nothing`. This would be in agreement with\n"
"the types, but definitely not what we want. So, here is\n"
"what we'd like to do in order to get yet stronger guarantees:\n"
"We'd either want to return a proof that the two schemata\n"
"are the same, or return a proof that the two schemata\n"
"are not the same. (Remember that `Not a` is an alias for `a -> Void`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:708
msgid ""
"We call a property, which either holds or leads to a contradiction a "
"*decidable property*, and the *Prelude* exports data type `Dec prop`, which "
"encapsulates this distinction."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:710
msgid "Here is a way to encode this for `ColType`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:711
#, no-wrap
msgid ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:741
msgid ""
"First, note how we could use a pattern match in a single argument lambda "
"directly. This is sometimes called the *lambda case* style, named after an "
"extension of the Haskell programming language. If we use the `SameCT` "
"constructor in the pattern match, Idris is forced to try and unify for "
"instance `Float` with `I64`. This is not possible, so the case as a whole is "
"impossible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:749
msgid ""
"Yet, this was pretty cumbersome to implement. In order to convince Idris we "
"did not miss a case, there is no way around treating every possible pairing "
"of constructors explicitly.  However, we get *much* stronger guarantees out "
"of this: We can no longer create false positives *or* false negatives, and "
"therefore, `decSameColType` is provably correct."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:752
msgid ""
"Doing the same thing for schemata requires some utility functions, the types "
"of which we can figure out by placing some holes:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:753
#, no-wrap
msgid ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:770
#, no-wrap
msgid ""
"The first two cases are not too hard. The type of `decss1` is\n"
"`SameSchema [] (y :: ys) -> Void`, which you can easily verify\n"
"at the REPL. But that's just `uninhabited`, specialized to\n"
"`SameSchema [] (y :: ys)`, and this we already implemented\n"
"further above. The same goes for `decss2`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:777
msgid ""
"The other two cases are harder, so I already filled in as much stuff as "
"possible. We know that we want to return a `No`, if either the heads or "
"tails are provably distinct. The `No` holds a function, so I already added a "
"lambda, leaving a hole only for the return value. Here are the type and - "
"more important - context of `decss3`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:778
#, no-wrap
msgid ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:797
msgid ""
"The types of `contra` and `prf` are what we need here: If `xs` and `ys` are "
"distinct, then `y :: xs` and `y :: ys` must be distinct as well. This is the "
"contraposition of the following statement: If `x :: xs` is the same as `y :: "
"ys`, then `xs` and `ys` are the same as well. We must therefore implement a "
"lemma, which proves that the *cons* constructor is [*injective*](https://en."
"wikipedia.org/wiki/Injective_function):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:798
#, no-wrap
msgid ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:809
msgid ""
"We can now pass `prf` to `consInjective` to extract a value of type "
"`SameSchema xs ys`, which we then pass to `contra` in order to get the "
"desired value of type `Void`.  With these observations and utilities, we can "
"now implement `decSameSchema`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:810
#, no-wrap
msgid ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:825
msgid ""
"There is an interface called `DecEq` exported by module `Decidable.Equality` "
"for types for which we can implement a decision procedure for propositional "
"equality. We can implement this to figure out if two values are equal or not."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:830
msgid ""
"Show that there can be no non-empty vector of `Void` by writing a "
"corresponding implementation of uninhabited"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:832
msgid "Generalize exercise 1 for all uninhabited element types."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:835
msgid "Show that if `a = b` cannot hold, then `b = a` cannot hold either."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:838
msgid ""
"Show that if `a = b` holds, and `b = c` cannot hold, then `a = c` cannot "
"hold either."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:841
msgid ""
"Implement `Uninhabited` for `Crud i a`. Try to be as general as possible."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:851
msgid "Implement `DecEq` for `ColType`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:856
msgid ""
"Implementations such as the one from exercise 6 are cumbersome to write as "
"they require a quadratic number of pattern matches with relation to the "
"number of data constructors. Here is a trick how to make this more bearable."
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Eq.md:859
msgid ""
"Implement a function `ctNat`, which assigns every value of type `ColType` a "
"unique natural number."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Eq.md:864
msgid ""
"Proof that `ctNat` is injective.  Hint: You will need to pattern match on "
"the `ColType` values, but four matches should be enough to satisfy the "
"coverage checker."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Eq.md:869
msgid ""
"In your implementation of `DecEq` for `ColType`, use `decEq` on the result "
"of applying both column types to `ctNat`, thus reducing it to only two lines "
"of code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:877
#, no-wrap
msgid ""
"   We will later talk about `with` rules: Special forms of\n"
"   dependent pattern matches, that allow us to learn something\n"
"   about the shape of function arguments by performing\n"
"   computations on them. These will allow us to use\n"
"   a similar technique as shown here to implement `DecEq`\n"
"   requiring only `n` pattern matches\n"
"   for arbitrary sum types with `n` data constructors.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:878
#, no-wrap
msgid "Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:888
msgid ""
"One of the most important use cases of propositional equality is to replace "
"or *rewrite* existing types, which Idris can't unify automatically "
"otherwise. For instance, the following is no problem: Idris know that `0 + "
"n` equals `n`, because `plus` on natural numbers is implemented by pattern "
"matching on the first argument. The two vector lengths therefore unify just "
"fine."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:889
#, no-wrap
msgid ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:899
msgid ""
"However, the example below can't be implemented as easily (try it!), because "
"Idris can't figure out on its own that the two lengths unify."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:900
#, no-wrap
msgid ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:909
msgid ""
"Probably for the first time we realize, just how little Idris knows about "
"the laws of arithmetics. Idris is able to unify values when"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
msgid "all values in a computation are known at compile time"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
msgid ""
"one expression follows directly from the other due to the pattern matches "
"used in a function's implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:917
msgid ""
"In expression `n + 0`, not all values are known (`n` is a variable), and "
"`(+)` is implemented by pattern matching on the first argument, about which "
"we know nothing here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:923
msgid ""
"However, we can teach Idris. If we can proof that the two expressions are "
"equivalent, we can replace one expression for the other, so that the two "
"unify again. Here is a lemma and its proof, that `n + 0` equals `n`, for all "
"natural numbers `n`."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:924
#, no-wrap
msgid ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:935
msgid ""
"Note, how the base case is trivial: Since there are no variables left, Idris "
"can immediately figure out that `0 + 0 = 0`. In the recursive case, it can "
"be instructive to replace `cong S` with a hole and look at its type and "
"context to figure out how to proceed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:940
msgid ""
"The *Prelude* exports function `replace` for substituting one variable in a "
"term by another, based on a proof of equality.  Make sure to inspect its "
"type first before looking at the example below:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:941
#, no-wrap
msgid ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:952
#, no-wrap
msgid ""
"As you can see, we *replace* a value of type `p x` with a value\n"
"of type `p y` based on a proof that `x = y`,\n"
"where `p` is a function from some type `t` to\n"
"`Type`, and `x` and `y` are values of type `t`. In our\n"
"`replaceVect` example, `t` equals `Nat`, `x` equals `n + 0`,\n"
"`y` equals `n`, and `p` equals `\\k => Vect k a`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:960
msgid ""
"Using `replace` directly is not very convenient, because Idris can often not "
"infer the value of `p` on its own. Indeed, we had to give its type "
"explicitly in `replaceVect`.  Idris therefore provides special syntax for "
"such *rewrite rules*, which will get desugared to calls to `replace` with "
"all the details filled in for us. Here is an implementation of `replaceVect` "
"with a rewrite rule:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:961
#, no-wrap
msgid ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:970
msgid ""
"One source of confusion is that *rewrite* uses proofs of equality the other "
"way round: Given an `y = x` it replaces `p x` with `p y`. Hence the need to "
"call `sym` in our implementation above."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:971
#, no-wrap
msgid "Use Case: Reversing Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:982
msgid ""
"Rewrite rules are often required when we perform interesting type-level "
"computations. For instance, we have already seen many interesting examples "
"of functions operating on `Vect`, which allowed us to keep track of the "
"exact lengths of the vectors involved, but one key functionality has been "
"missing from our discussions so far, and for good reasons: Function "
"`reverse`. Here is a possible implementation, which is how `reverse` is "
"implemented for lists:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:984
#, no-wrap
msgid ""
"revOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto' xs []        = xs\n"
"revOnto' xs (x :: ys) = revOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = revOnto' []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:997
msgid ""
"As you might have guessed, this will not compile as the length indices in "
"the two clauses of `revOnto'` do not unify."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1001
msgid ""
"The *nil* case is a case we've already seen above: Here `n` is zero, because "
"the second vector is empty, so we have to convince Idris once again that `m "
"+ 0 = m`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1002
#, no-wrap
msgid ""
"revOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto xs [] = rewrite addZeroRight m in xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1013
msgid ""
"The second case is more complex. Here, Idris fails to unify `S (m + len)` "
"with `m + S len`, where `len` is the length of `ys`, the tail of the second "
"vector. Module `Data.Nat` provides many proofs about arithmetic operations "
"on natural numbers, one of which is `plusSuccRightSucc`. Here's its type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:1014
#, no-wrap
msgid ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1032
msgid ""
"In our case, we want to replace `S (m + len)` with `m + S len`, so we will "
"need the version with arguments flipped. However, there is one more "
"obstacle: We need to invoke `plusSuccRightSucc` with the length of `ys`, "
"which is not given as an implicit function argument of `revOnto`. We "
"therefore need to pattern match on `n` (the length of the second vector), in "
"order to bind the length of the tail to a variable. Remember, that we are "
"allowed to pattern match on an erased argument only if the constructor used "
"follows from a match on another, unerased, argument (`ys` in this case). "
"Here's the implementation of the second case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1033
#, no-wrap
msgid ""
"revOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in revOnto (x :: xs) ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1043
msgid ""
"I know from my own experience that this can be highly confusing at first. If "
"you use Idris as a general purpose programming language and not as a proof "
"assistant, you probably will not have to use rewrite rules too often. Still, "
"it is important to know that they exist, as they allow us to teach complex "
"equivalences to Idris."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:1044
#, no-wrap
msgid "A Note on Erasure"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1055
msgid ""
"Single value data types like `Unit`, `Equal`, or `SameSchema` have not "
"runtime relevance, as values of these types are always identical.  We can "
"therefore always use them as erased function arguments while still being "
"able to pattern match on these values.  For instance, when you look at the "
"type of `replace`, you will see that the equality proof is an erased "
"argument.  This allows us to run arbitrarily complex computations to produce "
"such values without fear of these computations slowing down the compiled "
"Idris program."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:1059
msgid "Implement `plusSuccRightSucc` yourself."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:1061
msgid "Proof that `minus n n` equals zero for all natural numbers `n`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:1063
msgid "Proof that `minus n 0` equals n for all natural numbers `n`"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:1066
msgid "Proof that `n * 1 = n` and `1 * n = n` for all natural numbers `n`."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:1069
msgid "Proof that addition of natural numbers is commutative."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:1071
msgid "Implement a tail-recursive version of `map` for vectors."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:1073
msgid "Proof the following proposition:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1074
#, no-wrap
msgid ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Eq.md:1084
msgid ""
"Use the proof from exercise 7 to implement again a function for zipping two "
"`Table`s, this time using a rewrite rule plus `Data.HList.(++)` instead of "
"custom function `appRows`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1096
msgid ""
"The concept of *types as propositions, values as proofs* is a very powerful "
"tool for writing provably correct programs. We will therefore spend some "
"more time defining data types for describing contracts between values, and "
"values of these types as proofs that the contracts hold. This will allow us "
"to describe necessary pre- and postconditions for our functions, thus "
"reducing the need to return a `Maybe` or other failure type, because due to "
"the restricted input, our functions can no longer fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1098
msgid "[Next chapter](./Predicates.md)"
msgstr ""
