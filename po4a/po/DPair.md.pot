# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/DPair.md:1
#, no-wrap
msgid "Sigma Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
#, no-wrap
msgid ""
"So far in our examples of dependently typed programming,\n"
"type indices such as the length of vectors were known at\n"
"compile time or could be calculated from values known at\n"
"compile time. In real applications, however, such information is\n"
"often not available until runtime, where values depend on\n"
"the decisions made by users or the state of the surrounding world.\n"
"For instance, if we store a file's content as a vector of lines\n"
"of text, the length of this vector is in general unknown until\n"
"the file has been loaded into memory.\n"
"As a consequence, the types of values we work with depend on\n"
"other values only known at runtime, and we can often only figure out\n"
"these types by pattern matching on the values they depend on.\n"
"To express these dependencies, we need so called\n"
"[*sigma types*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A3_type):\n"
"Dependent pairs and their generalization, dependent records.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:19
#, no-wrap
msgid ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:38
#, no-wrap
msgid "Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
#, no-wrap
msgid ""
"We've already seen several examples of how useful the length\n"
"index of a vector is to describe more precisely in the types what\n"
"a function can and can't do. For instance, `map` or `traverse`\n"
"operating on a vector will return a vector of exactly\n"
"the same length. The types guarantee that this is true, therefore\n"
"the following function is perfectly safe and provably total:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:47
#, no-wrap
msgid ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
#, no-wrap
msgid ""
"Since the argument of `traverse parsePositive`\n"
"is of type `Vect (3 + n) String`, its result will be of\n"
"type `Maybe (Vect (3 + n) Nat)`. It is therefore\n"
"safe to use this in a call to `drop 3`. Note, how all of this\n"
"is known at compile time: We encoded the prerequisite\n"
"that the first argument is a vector of at least three elements\n"
"in the length index and could derive the length\n"
"of the result from this.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:61
#, no-wrap
msgid "Vectors of Unknown Length"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
#, no-wrap
msgid ""
"However, this is not always possible. Consider the following function,\n"
"defined on `List` and exported by `Data.List`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:66
#, no-wrap
msgid ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
#, no-wrap
msgid ""
"This will take the longest prefix of the list argument, for which\n"
"the given predicate returns `True`. In this case, it depends on\n"
"the list elements and the predicate, how long this prefix will be.\n"
"Can we write such a function for vectors? Let's give it a try:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:76
#, no-wrap
msgid "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
#, no-wrap
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not\n"
"be able to do so in a provably total way. The question is: What is the\n"
"problem here?\n"
"In order to understand this, we have to realize what the type of `takeWhile'`\n"
"promises: \"For all predicates operating on values on type `a`, and for\n"
"all vectors holding values of this type, and for all lengths `m`, I\n"
"give you a vector of length `m` holding values of type `a`\".\n"
"All three arguments are said to be\n"
"[*universally quantified*](https://en.wikipedia.org/wiki/Universal_quantification):\n"
"The caller of our function is free to choose the predicate,\n"
"the input vector, the type of values the vector holds,\n"
"and *the length of the output vector*. Don't believe me? See here:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:93
#, no-wrap
msgid ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
#, no-wrap
msgid ""
"See how I could freely decide on the value of `m` when invoking `takeWhile'`?\n"
"Although I passed `takeWhile'` an empty vector (the only existing vector\n"
"holding values of type `Void`), the function's type promises me\n"
"to return a possibly non-empty vector holding values of the same\n"
"type, from which I freely extracted the first one.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
#, no-wrap
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to\n"
"implement `takeWhile'` without cheating (for instance, by\n"
"turning totality checking off and looping forever).\n"
"So, the question remains, how to express the result of `takeWhile'`\n"
"in a type. The answer to this is: \"Use a *dependent pair*\", a vector\n"
"paired with a value corresponding to its length.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:116
#, no-wrap
msgid ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
#, no-wrap
msgid ""
"This corresponds to [*existential quantification*](https://en.wikipedia.org/wiki/Existential_quantification)\n"
"in predicate logic: There is a natural number, which corresponds to\n"
"the length of the vector I have here. Note, how from the outside\n"
"of `AnyVect a`, the length of the wrapped vector is no longer\n"
"visible at the type level but we can still inspect it and learn\n"
"something about it at runtime, since it is wrapped up together\n"
"with the actual vector. We can implement `takeWhile` in such\n"
"a way that it returns a value of type `AnyVect a`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:132
#, no-wrap
msgid ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
#, no-wrap
msgid ""
"This works in a provably total way, because callers of this function\n"
"can no longer choose the length of the resulting vector themselves. Our\n"
"function, `takeWhile`, decides on this length and returns it together\n"
"with the vector, and the type checker verifies that we\n"
"make no mistakes when pairing the two values. In fact,\n"
"the length can be inferred automatically by Idris, so we can replace\n"
"it with underscores, if we so desire:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:148
#, no-wrap
msgid ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
#, no-wrap
msgid ""
"To summarize: Parameters in generic function types are\n"
"universally quantified, and their values can be decided on at the\n"
"call site of such functions. Dependent record types allow us\n"
"to describe existentially quantified values. Callers cannot choose\n"
"such values freely: They are returned as part of a function's result.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
#, no-wrap
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.\n"
"The type of `takeWhile'` can also be written like so:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:165
#, no-wrap
msgid "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
#, no-wrap
msgid ""
"Universally quantified arguments are desugared to implicit\n"
"erased arguments by Idris. The above is a less verbose version\n"
"of the following function type, the likes of which we have seen\n"
"before:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:174
#, no-wrap
msgid ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
#, no-wrap
msgid ""
"In Idris, we are free to choose whether we want to be explicit\n"
"about universal quantification. Sometimes it can help understanding\n"
"what's going on at the type level. Other languages - for instance\n"
"[PureScript](https://www.purescript.org/) - are more strict about\n"
"this: There, explicit annotations on universally quantified parameters\n"
"are [mandatory](https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#explicit-forall).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:190
#, no-wrap
msgid "The Essence of Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
#, no-wrap
msgid ""
"It can take some time and experience to understand what's going on here. At\n"
"least in my case, it took many sessions programming in Idris, before I figured\n"
"out what dependent pairs are about: They pair a *value* of some type with\n"
"a second value of a type calculated from the first value.\n"
"For instance, a natural number `n` (the value)\n"
"paired with a vector of length `n` (the second value, the type\n"
"of which *depends* on the first value).\n"
"This is such a fundamental concept of programming with dependent types, that\n"
"a general dependent pair type is provided by the *Prelude*. Here is its\n"
"implementation (primed for disambiguation):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:203
#, no-wrap
msgid ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
#, no-wrap
msgid ""
"It is essential to understand what's going on here. There are two\n"
"parameters: A type `a`, and a function `p`, calculating a *type*\n"
"from a *value* of type `a`. Such a value (`fst`) is then used\n"
"to calculate the *type* of the second value (`snd`).\n"
"For instance, here is `AnyVect a` represented as a `DPair`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:216
#, no-wrap
msgid ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
#, no-wrap
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.\n"
"Idris provides special syntax for describing dependent pairs, as\n"
"they are important building blocks for programming in languages\n"
"with first class types:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:226
#, no-wrap
msgid ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
#, no-wrap
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''`\n"
"get's desugared to the right hand side of `AnyVect'`:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:234
#, no-wrap
msgid ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
#, no-wrap
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop\n"
"this information. (We still need to put the whole expression in\n"
"parentheses.)\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:243
#, no-wrap
msgid ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
#, no-wrap
msgid ""
"This allows us to pair a natural number `n` with a vector of\n"
"length `n`, which is exactly what we did with `AnyVect`. We can\n"
"therefore rewrite `takeWhile` to return a `DPair` instead of\n"
"our custom type `AnyVect`. Note, that like with regular pairs,\n"
"we can use the same syntax `(x ** y)` for creating and\n"
"pattern matching on dependent pairs:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:255
#, no-wrap
msgid ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
#, no-wrap
msgid ""
"Just like with regular pairs, we can use the dependent pair\n"
"syntax to define dependent triples and larger tuples:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:266
#, no-wrap
msgid ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:271
#, no-wrap
msgid "Erased Existentials"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
#, no-wrap
msgid ""
"Sometimes, it is possible to determine the value of an\n"
"index by pattern matching on a value of the indexed type.\n"
"For instance, by pattern matching on a vector, we can learn\n"
"about its length index. In these cases, it is not strictly\n"
"necessary to carry around the index at runtime,\n"
"and we can write a special version of a dependent pair\n"
"where the first argument has quantity zero. Module `Data.DPair`\n"
"from *base* exports data type `Exists` for this use case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
#, no-wrap
msgid ""
"As an example, here is a version of `takeWhile` returning\n"
"a value of type `Exists`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:285
#, no-wrap
msgid ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
#, no-wrap
msgid ""
"In order to restore an erased value, data type `Singleton`\n"
"from *base* module `Data.Singleton` can be useful: It is\n"
"parameterized by the *value* it stores:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:298
#, no-wrap
msgid ""
"true : Singleton True\n"
"true = Val True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
#, no-wrap
msgid ""
"This is called a *singleton* type: A type corresponding to\n"
"exactly one value. It is a type error to return any other\n"
"value for constant `true`, and Idris knows this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:307
#, no-wrap
msgid ""
"true' : Singleton True\n"
"true' = Val _\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
#, no-wrap
msgid ""
"We can use this to conjure the (erased!) length of a vector\n"
"out of thin air:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:315
#, no-wrap
msgid ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
#, no-wrap
msgid ""
"This function comes with much stronger guarantees\n"
"than `Data.Vect.length`: The latter claims to just return\n"
"*any* natural number, while `vectLength` *must* return\n"
"exactly `n` in order to type check. As a demonstration,\n"
"here is a well-typed bogus implementation of `length`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:327
#, no-wrap
msgid ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
#, no-wrap
msgid ""
"This would not be accepted as a valid implementation of\n"
"`vectLength`, as you may quickly verify yourself.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
#, no-wrap
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)\n"
"we can convert an erased existential to a proper dependent\n"
"pair:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:339
#, no-wrap
msgid ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
#, no-wrap
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms\n"
"of `length`, and note how Idris will fail to unify the\n"
"result of `length` with the actual length of the vector.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
#, no-wrap
msgid ""
"Declare and implement a function for filtering a\n"
"vector similar to `Data.List.filter`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
#, no-wrap
msgid ""
"Declare and implement a function for mapping a partial\n"
"function over the values of a vector similar\n"
"to `Data.List.mapMaybe`.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
#, no-wrap
msgid ""
"Declare and implement a function similar to\n"
"`Data.List.dropWhile` for vectors. Use `Data.DPair.Exists`\n"
"as your return type.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
#, no-wrap
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use\n"
"the function from exercise 3 in your implementation.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:364
#, no-wrap
msgid "Use Case: Nucleic Acids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
#, no-wrap
msgid ""
"We'd like to come up with a small, simplified library for running computations\n"
"on nucleic acids: RNA and DNA. These are built from five types of\n"
"nucleobases, three of which are used in both types of nucleic\n"
"acids and two bases specific for each type of acid. We'd like\n"
"to make sure that only valid bases are in strands of nucleic acids.\n"
"Here's a possible encoding:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:373
#, no-wrap
msgid ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
#, no-wrap
msgid "It is a type error to use `Uracile` in a strand of DNA:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:405
#, no-wrap
msgid ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
#, no-wrap
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and\n"
"`Guanine`: These are again universally quantified,\n"
"and client code is free to choose a value here. This allows us\n"
"to use these bases in strands of DNA *and* RNA:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:416
#, no-wrap
msgid ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
#, no-wrap
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only\n"
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.\n"
"Let's write parsers for strands of DNA and RNA:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:428
#, no-wrap
msgid ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
#, no-wrap
msgid ""
"Again, in case of the bases appearing in both kinds of strands,\n"
"users of the universally quantified `readAnyBase`\n"
"are free to choose what base type they want, but they will\n"
"never get a `Thymine` or `Uracile` value.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
#, no-wrap
msgid ""
"We can now implement some simple calculations on sequences of\n"
"nucleobases. For instance, we can come up with the complementary\n"
"strand:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:459
#, no-wrap
msgid ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
#, no-wrap
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were\n"
"dozens of bases with only few specialized ones. Surely, we can\n"
"do better? Unfortunately, the following won't work:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:481
#, no-wrap
msgid ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
#, no-wrap
msgid ""
"All goes well with the exception of the `Adenine` case. Remember:\n"
"Parameter `b` is universally quantified, and the *callers* of\n"
"our function can decide what `b` is supposed to\n"
"be. We therefore can't just return `Thymine`: Idris will respond\n"
"with a type error since callers might want a `Nucleobase RNABase` instead.\n"
"One way to go about this is to take an additional unerased argument\n"
"(explicit or implicit) representing the base type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:498
#, no-wrap
msgid ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
#, no-wrap
msgid ""
"This is again an example of a dependent *function* type (also called a\n"
"[*pi type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)):\n"
"The input and output types both *depend* on the *value* of the first argument.\n"
"We can now use this to calculate the complement of any nucleic acid:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:513
#, no-wrap
msgid ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
#, no-wrap
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence\n"
"of nucleobases from user input, accepting two strings: The first\n"
"telling us, whether the user plans to enter a DNA or RNA sequence,\n"
"the second being the sequence itself. What should be the type of\n"
"such a function? Well, we're describing computations with side effects,\n"
"so something involving `IO` seems about right. User input almost\n"
"always needs to be validated or translated, so something might go wrong\n"
"and we need an error type for this case. Finally, our users can\n"
"decide whether they want to enter a strand of RNA or DNA, so this\n"
"distinction should be encoded as well.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
#, no-wrap
msgid ""
"Of course, it is always possible to write a custom sum type for\n"
"such a use case:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:532
#, no-wrap
msgid ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
#, no-wrap
msgid ""
"This has all possible outcomes encoded in a single data type.\n"
"However, it is lacking in terms of flexibility. If we want to handle\n"
"errors early on and just extract a strand of RNA or DNA, we need\n"
"yet another data type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:545
#, no-wrap
msgid "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
#, no-wrap
msgid ""
"This might be the way to go, but for results with many options, this\n"
"can get cumbersome quickly. Also: Why come up with a custom data type when\n"
"we already have the tools to deal with this at our hands?\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
#, no-wrap
msgid "Here is how we can encode this with a dependent pair:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:555
#, no-wrap
msgid ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
#, no-wrap
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid\n"
"sequence. Assume now we implement a function for transcribing\n"
"a strand of DNA to RNA, and we'd like to convert a sequence of\n"
"nucleobases from user input to the corresponding RNA sequence.\n"
"Here's how to do this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:584
#, no-wrap
msgid ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
#, no-wrap
msgid ""
"By pattern matching on the first value of the dependent pair we could\n"
"determine, whether the second value is an RNA or DNA sequence.\n"
"In the first case, we had to transcribe the\n"
"sequence first, in the second case, we could invoke `printRNA` directly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
#, no-wrap
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence\n"
"to the corresponding protein sequence. Still, this example shows\n"
"how to deal with a simplified real world scenario: Data may be\n"
"encoded differently and coming from different sources. By using precise\n"
"types, we are forced to first convert values to the correct\n"
"format. Failing to do so leads to a compile time exception instead of\n"
"an error at runtime or - even worse - the program silently running\n"
"a bogus computation.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:621
#, no-wrap
msgid "Dependent Records vs Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
#, no-wrap
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization\n"
"of dependent pairs: We can have an arbitrary number of fields\n"
"and use the values stored therein to calculate the types of\n"
"other values. For very simple cases like the example with nucleobases,\n"
"it doesn't matter too much, whether we use a `DPair`, a custom\n"
"dependent record, or even a sum type. In fact, the three encodings\n"
"are equally expressive:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:631
#, no-wrap
msgid ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
#, no-wrap
msgid ""
"It is trivial to write lossless conversions between these\n"
"encodings, and with each encoding we can decide with a simple\n"
"pattern match, whether we currently have a sequence of\n"
"RNA or DNA. However, dependent types can depend on more than\n"
"one value, as we will see in the exercises. In such cases,\n"
"sum types and dependent pairs quickly become unwieldy, and\n"
"you should go for an encoding as a dependent record.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
#, no-wrap
msgid ""
"Sharpen your skills in using dependent pairs and dependent\n"
"records! In exercises 2 to 7 you have to decide yourself,\n"
"when a function should return a dependent pair or record,\n"
"when a function requires additional arguments, on which you\n"
"can pattern match, and what other utility functions might be\n"
"necessary.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
#, no-wrap
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic*\n"
"(meaning: of the same structure) by writing lossless conversion\n"
"functions from `Acid1` to `Acid2` and back. Likewise\n"
"for `Acid1` and `Acid3`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
#, no-wrap
msgid ""
"Sequences of nucleobases can be encoded in one of two directions:\n"
"[*Sense* and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).\n"
"Declare a new data type to describe\n"
"the sense of a sequence of nucleobases, and add this as an\n"
"additional parameter to type `Nucleobase` and types `DNA` and\n"
"`RNA`.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
#, no-wrap
msgid ""
"Refine the types of `complement` and `transcribe`, so that they\n"
"reflect the changing of *sense*. In case of `transcribe`, a\n"
"strand of antisense DNA is converted to a strand of sense RNA.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
#, no-wrap
msgid ""
"Define a dependent record storing the base type and sense\n"
"together with a sequence of nucleobases.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
#, no-wrap
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that\n"
"the *sense* of a sequence is read from the input string.\n"
"Sense strands are encoded like so: \"5´-CGGTAG-3´\". Antisense\n"
"strands are encoded like so: \"3´-CGGTAG-5´\".\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
#, no-wrap
msgid ""
"Adjust `encode` in such a way that it includes the sense\n"
"in its output.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
#, no-wrap
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that\n"
"the sense and base type are stored together with the sequence,\n"
"and that `transcribeProg` always prints the *sense* RNA strand\n"
"(after transcription, if necessary).\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
#, no-wrap
msgid "Enjoy the fruits of your labour and test your program at the REPL.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
#, no-wrap
msgid ""
"Note: Instead of using a dependent record, we could again\n"
"have used a sum type of four constructors to encode the different\n"
"types of sequences. However, the number of constructors\n"
"required corresponds to the *product* of the number of values\n"
"of each type level index. Therefore, this number can grow quickly\n"
"and sum type encodings can lead to lengthy blocks of pattern matches\n"
"in these cases.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:704
#, no-wrap
msgid "Use Case: CSV Files with a Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
#, no-wrap
msgid ""
"In this section, we are going to look at an extended example\n"
"based on our previous work on CSV parsers. We'd like to\n"
"write a small command-line program, where users can specify a\n"
"schema for the CSV tables they'd like to parse and load into\n"
"memory. Before we begin, here is a REPL session running\n"
"the final program, which you will complete in the exercises:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:713
#, no-wrap
msgid ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
#, no-wrap
msgid ""
"This example was inspired by a similar program used as an example\n"
"in the [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)\n"
"book.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
#, no-wrap
msgid "We'd like to focus on several things here:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
#, no-wrap
msgid ""
"Purity: With the exception of the main program loop, all functions\n"
"used in the implementation should be pure, which in this context\n"
"means \"not running in any monad with side effects such as `IO`\".\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
#, no-wrap
msgid ""
"Fail early: With the exception of the command parser, all functions\n"
"updating the table and handling queries should be typed and\n"
"implemented in such a way that they cannot fail.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
#, no-wrap
msgid ""
"We are often well advised to adhere to these two guidelines, as they can\n"
"make the majority of our functions easier to implement and test.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
#, no-wrap
msgid ""
"Since we allow users of our library to specify a schema (order and\n"
"types of columns) for the table they work with, this information is\n"
"not known until runtime. The same goes for the current size of the\n"
"table. We will therefore store both values as fields in a\n"
"dependent record.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:773
#, no-wrap
msgid "Encoding the Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
#, no-wrap
msgid ""
"We need to inspect the table schema at runtime. Although theoretically\n"
"possible, it is not advisable to operate on Idris types directly here.\n"
"We'd rather use a closed custom data type describing the types of\n"
"columns we understand. In a first try, we only support some Idris\n"
"primitives:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:781
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
#, no-wrap
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris\n"
"types, which we will then use as the index of a heterogeneous\n"
"list representing the rows in our table:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:792
#, no-wrap
msgid ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
#, no-wrap
msgid ""
"We can now describe a table as a dependent record storing\n"
"the table's content as a vector of rows. In order to safely\n"
"index rows of the table and parse new rows to be added, the\n"
"current schema and size of the table must be known at runtime:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:808
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
#, no-wrap
msgid ""
"Finally, we define an indexed data type describing commands\n"
"operating on the current table. Using the current table as\n"
"the command's index allows us to make sure that indices for\n"
"accessing and deleting rows are within bounds and that\n"
"new rows agree with the current schema. This is necessary\n"
"to uphold our second design principle: All functions\n"
"operating on tables must do so without the possibility of failure.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:824
#, no-wrap
msgid ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
#, no-wrap
msgid ""
"We can now implement the main application logic: How user\n"
"entered commands affect the application's current state. As promised,\n"
"this comes without the risk of failure, so we don't have to\n"
"wrap the return type in an `Either`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:840
#, no-wrap
msgid ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
#, no-wrap
msgid ""
"Please understand, that the constructors of `Command t` are typed\n"
"in such a way that indices are always within bounds (constructors\n"
"`Get` and `Delete`), and new rows adhere to the table's\n"
"current schema (constructor `Prepend`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
#, no-wrap
msgid ""
"One thing you might not have seen so far is the call to `absurd`\n"
"on the last line. This is a derived function of the\n"
"`Uninhabited` interface, which is used to describe types such\n"
"as `Void` or - in the case above - `Fin 0`, of which there can\n"
"be no value. Function `absurd` is then just another manifestation\n"
"of the principle of explosion. If this doesn't make too much sense\n"
"yet, don't worry. We will look at `Void` and its uses in the\n"
"next chapter.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:867
#, no-wrap
msgid "Parsing Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
#, no-wrap
msgid ""
"User input validation is an important topic when writing\n"
"applications. If it happens early, you can keep larger parts\n"
"of your application pure (which - in this context - means:\n"
"\"without the possibility of failure\") and provably total.\n"
"If done properly, this step encodes and handles most if not all\n"
"ways in which things can go wrong in your program, allowing\n"
"you to come up with clear error messages telling users exactly what caused\n"
"an issue. As you surely have experienced yourself, there are few\n"
"things more frustrating than a non-trivial computer program terminating\n"
"with an unhelpful \"There was an error\" message.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
#, no-wrap
msgid ""
"So, in order to treat this important topic with all due respect,\n"
"we are first going to implement a custom error type. This is\n"
"not *strictly* necessary for small programs, but once your software\n"
"gets more complex, it can be tremendously helpful for keeping track\n"
"of what can go wrong where. In order to figure out what can possibly\n"
"go wrong, we first need to decide on how the commands should be entered.\n"
"Here, we use a single keyword for each command, together with an\n"
"optional number of arguments separated from the keyword by a single\n"
"space character. For instance: `\"new i64,boolean,str,str\"`,\n"
"for initializing an empty table with a new schema. With this settled,\n"
"here is a list of things that can go wrong, and the messages we'd\n"
"like to print:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"A bogus command is entered. We repeat the input with a message that\n"
"we don't know the command plus a list of commands we know about.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"An invalid schema was entered. In this case, we list the position\n"
"of the first unknown type, the string we found there, and a list of\n"
"types we know about.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous position,\n"
"the string encountered there, plus the expected type. In case\n"
"of a too small or too large number of fields, we also print\n"
"a corresponding error message.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"An index was out of bounds. This can happen, when users try to access\n"
"or delete specific rows. We print the current number of rows plus\n"
"the value entered.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"A value not representing a natural number was entered as an index.\n"
"We print an according error message.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
#, no-wrap
msgid ""
"That's a lot of stuff to keep track of, so let's encode this in\n"
"a sum type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:911
#, no-wrap
msgid ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
#, no-wrap
msgid ""
"In order to conveniently construct our error messages, it is best\n"
"to use Idris' string interpolation facilities: We can enclose\n"
"arbitrary string expressions in a string literal by enclosing\n"
"them in curly braces, the first of which must be escaped with\n"
"a backslash. Like so: `\"foo \\{myExpr a b c}\"`.\n"
"We can pair this with multiline string literals to get\n"
"nicely formatted error messages.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:930
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
#, no-wrap
msgid ""
"We can now write parsers for the different commands. We need facilities\n"
"to parse vector indices, schemata, and CSV rows.\n"
"Since we are using a CSV format for encoding\n"
"and decoding rows, it makes sense to also encode the schema\n"
"as a comma-separated list of values:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:991
#, no-wrap
msgid ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
#, no-wrap
msgid ""
"We also need to decode CSV content based on the current schema.\n"
"Note, how we can do so in a type safe manner by pattern matching\n"
"on the schema, which will not be known until runtime. Unfortunately,\n"
"we need to reimplement CSV-parsing, because we want to add the\n"
"expected type to the error messages (a thing that would be\n"
"much harder to do with interface `CSVLine`\n"
"and error type `CSVError`).\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1019
#, no-wrap
msgid ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
#, no-wrap
msgid ""
"There is no hard and fast rule about whether to pass an index as an\n"
"implicit argument or not. Some considerations:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, no-wrap
msgid "Pattern matching on explicit arguments comes with less syntactic overhead.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, no-wrap
msgid ""
"If an argument can be inferred from the context most of the time, consider\n"
"passing it as an implicit to make your function nicer to use in client\n"
"code.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, no-wrap
msgid ""
"Use explicit (possibly erased) arguments for values that can't\n"
"be inferred by Idris most of the time.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
#, no-wrap
msgid ""
"All that is missing now is a way to parse indices for accessing\n"
"the current table's rows. We use the conversion for indices to\n"
"start at one instead of zero, which feels more natural for most\n"
"non-programmers.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1053
#, no-wrap
msgid ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
#, no-wrap
msgid ""
"We are finally able to implement a parser for user commands.\n"
"Function `Data.String.words` is used for splitting a string\n"
"at space characters. In most cases, we expect the name of\n"
"the command plus a single argument without additional spaces.\n"
"CSV rows can have additional space characters, however, so we\n"
"use `Data.String.unwords` on the split string.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1068
#, no-wrap
msgid ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:1081
#, no-wrap
msgid "Running the Application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
#, no-wrap
msgid ""
"All that's left to do is to write functions for\n"
"printing the results of commands to users and run\n"
"the application in a loop until command `\"quit\"`\n"
"is entered.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1088
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
#, no-wrap
msgid ""
"The challenges presented here all deal with enhancing our\n"
"table editor in several interesting ways. Some of them are\n"
"more a matter of style and less a matter of learning to write\n"
"dependently typed programs, so feel free to solve these as you\n"
"please. Exercises 1 to 3 should be considered to be\n"
"mandatory.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
#, no-wrap
msgid ""
"Add support for storing Idris types `Integer` and `Nat`\n"
"in CSV columns\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
#, no-wrap
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need\n"
"runtime access to `n` in order for this to work.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
#, no-wrap
msgid ""
"Add support for optional types to CSV columns. Since\n"
"missing values should be encoded by empty strings,\n"
"it makes no sense to allow for nested optional types,\n"
"meaning that types like `Maybe Nat` should be allowed\n"
"while `Maybe (Maybe Nat)` should not.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
#, no-wrap
msgid ""
"Add a command for printing the whole table. Bonus points\n"
"if all columns are properly aligned.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
#, no-wrap
msgid ""
"Add support for simple queries: Given a column number\n"
"and a value, list all rows where entries match the given\n"
"value.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
#, no-wrap
msgid ""
"Add support for loading and saving tables from and to disk.\n"
"A table should be stored in two files: One for the schema\n"
"and one for the CSV content.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
#, no-wrap
msgid ""
"You can find an implementation of these additions in the\n"
"solutions. A small example table can be found in folder\n"
"`resources`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
#, no-wrap
msgid ""
"Note: There are of course tons of projects to pursue from\n"
"here, such as writing a proper query language, calculating\n"
"new rows from existing ones, accumulating values in a\n"
"column, concatenating and zipping tables, and so on.\n"
"We will stop for now, probably coming back to this in\n"
"later examples.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
#, no-wrap
msgid ""
"Dependent pairs and records are necessary to at runtime\n"
"inspect the values defining the types we work with. By pattern\n"
"matching on these values, we learn about the types and\n"
"possible shapes of other values, allowing us to reduce\n"
"the number of potential bugs in our programs.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
#, no-wrap
msgid ""
"In the [next chapter](Eq.md) we start learning about how\n"
"to write data types, which we use as proofs that certain\n"
"contracts between values hold. These will eventually allow\n"
"us to define pre- and post conditions for our function\n"
"arguments and output types.\n"
msgstr ""
