# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-05-15 03:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:965
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:711
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1235
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:935
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429
#: ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functor.md:1
#, no-wrap
msgid "Functor and Friends"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:6
#, no-wrap
msgid ""
"Programming, like mathematics, is about abstraction. We\n"
"try to model parts of the real world, reusing recurring\n"
"patterns by abstracting over them.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:17
#, no-wrap
msgid ""
"In this chapter, we will learn about several related interfaces,\n"
"which are all about abstraction and therefore can be hard to\n"
"understand at the beginning. Especially figuring out\n"
"*why* they are useful and *when* to use them will take\n"
"time and experience. This chapter therefore comes\n"
"with tons of exercises, most of which can be solved\n"
"with only a few short lines of code. Don't skip them.\n"
"Come back to them several times until these things start\n"
"feeling natural to you. You will then realize that their\n"
"initial complexity has vanished.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:18
#, no-wrap
msgid ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:28
#, no-wrap
msgid "Functor"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:42
#, no-wrap
msgid ""
"What do type constructors like `List`, `List1`, `Maybe`, or\n"
"`IO` have in common? First, all of them are of type\n"
"`Type -> Type`. Second, they all put values of a given type\n"
"in a certain *context*. With `List`,\n"
"the *context* is *non-determinism*: We know there to\n"
"be zero or more values, but we don't know the exact number\n"
"until we start taking the list apart by pattern matching\n"
"on it. Likewise for `List1`, though we know for sure that\n"
"there is at least one value. For `Maybe`, we are still not\n"
"sure about how many values there are, but the possibilities\n"
"are much smaller: Zero or one. With `IO`, the context is a different one:\n"
"Arbitrary side effects.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:49
#, no-wrap
msgid ""
"Although the type constructors discussed above are quite\n"
"different in how they behave and when they are useful,\n"
"there are certain operations that keep coming up\n"
"when working with them. The first such operation\n"
"is *mapping a pure function over the data type, without\n"
"affecting its underlying structure*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:53
#, no-wrap
msgid ""
"For instance, given a list of numbers, we'd like to multiply\n"
"each number by two, without changing their order or removing\n"
"any values:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:54
#, no-wrap
msgid ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:62
#, no-wrap
msgid ""
"But we might just as well convert every string in a\n"
"list of strings to upper case characters:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:63
#, no-wrap
msgid ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:72
#, no-wrap
msgid ""
"Sometimes, the type of the stored value changes. In the\n"
"next example, we calculate the lengths of the strings stored\n"
"in a list:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:73
#, no-wrap
msgid ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:83
#, no-wrap
msgid ""
"I'd like you to appreciate, just how boring these functions are. They\n"
"are almost identical, with the only interesting part being\n"
"the function we apply to each element. Surely, there must be a\n"
"pattern to abstract over:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:84
#, no-wrap
msgid ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:94
#, no-wrap
msgid ""
"This is often the first step of abstraction in functional\n"
"programming: Write a (possibly generic) higher-order function.\n"
"We can now concisely implement all examples shown above in\n"
"terms of `mapList`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:95
#, no-wrap
msgid ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:110
#, no-wrap
msgid ""
"But surely we'd like to do the same kind of thing with\n"
"`List1` and `Maybe`! After all, they are just container\n"
"types like `List`, the only difference being some detail\n"
"about the number of values they can or can't hold:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:111
#, no-wrap
msgid ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:125
#, no-wrap
msgid ""
"Even with `IO`, we'd like to be able to map pure functions\n"
"over effectful computations. The implementation is\n"
"a bit more involved, due to the nested layers of\n"
"data constructors, but if in doubt, the types will surely\n"
"guide us. Note, however, that `IO` is not publicly exported,\n"
"so its data constructor is unavailable to us. We can use\n"
"functions `toPrim` and `fromPrim`, however, for converting\n"
"`IO` from and to `PrimIO`, which we can freely dissect:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:126
#, no-wrap
msgid ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:138
#, no-wrap
msgid ""
"From the concept of *mapping a pure function over\n"
"values in a context* follow some derived functions, which are\n"
"often useful. Here are some of them for `IO`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:139
#, no-wrap
msgid ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:151
#, no-wrap
msgid ""
"Of course, we'd want to implement `mapConst` and `forget` as well\n"
"for `List`, `List1`, and `Maybe` (and dozens of other type\n"
"constructors with some kind of mapping function), and they'd\n"
"all look the same and be equally boring.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:161
#, no-wrap
msgid ""
"When we come upon a recurring class of functions with\n"
"several useful derived functions, we should consider defining\n"
"an interface. But how should we go about this here?\n"
"When you look at the types of `mapList`, `mapMaybe`, and `mapIO`,\n"
"you'll see that it's the `List`, `List1`, and `IO` types we\n"
"need to get rid of. These are not of type `Type` but of type\n"
"`Type -> Type`. Luckily, there is nothing preventing us\n"
"from parametrizing an interface over something else than\n"
"a `Type`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:166
#, no-wrap
msgid ""
"The interface we are looking for is called `Functor`.\n"
"Here is its definition and an example implementation (I appended\n"
"a tick at the end of the names for them not to overlap with\n"
"the interface and functions exported by the *Prelude*):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:167
#, no-wrap
msgid ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:179
#, no-wrap
msgid ""
"Note, that we had to give the type of parameter `f` explicitly,\n"
"and in that case it needs to be annotated with quantity zero if\n"
"you want it to be erased at runtime (which you almost always want).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:186
#, no-wrap
msgid ""
"Now, reading type signatures consisting only of type parameters\n"
"like the one of `map'` can take some time to get used to, especially\n"
"when some type parameters are applied to other parameters as in\n"
"`f a`. It can be very helpful to inspect these signatures together\n"
"with all implicit arguments at the REPL (I formatted the output to\n"
"make it more readable):\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:187
#, no-wrap
msgid ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:200
#, no-wrap
msgid ""
"It can also be helpful to replace type parameter `f` with a concrete\n"
"value of the same type:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:201
#, no-wrap
msgid ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:209
#, no-wrap
msgid ""
"Remember, being able to interpret type signatures is paramount to\n"
"understanding what's going on in an Idris declaration. You *must*\n"
"practice this and make use of the tools and utilities given to you.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:210
#, no-wrap
msgid "Derived Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:215
#, no-wrap
msgid ""
"There are several functions and operators directly derivable from interface\n"
"`Functor`. Eventually, you should know and remember all of them as\n"
"they are highly useful. Here they are together with their types:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:216
#, no-wrap
msgid ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:235
#, no-wrap
msgid ""
"`(<$>)` is an operator alias for `map` and allows you to sometimes\n"
"drop some parentheses. For instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:236
#, no-wrap
msgid ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:249
#, no-wrap
msgid ""
"`(<&>)` is an alias for `(<$>)` with the arguments flipped.\n"
"The other three (`ignore`, `($>)`, and `(<$)`) are all used\n"
"to replace the values in a context with a constant. They are often useful\n"
"when you don't care about the values themselves but\n"
"want to keep the underlying structure.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:250
#, no-wrap
msgid "Functors with more than one Type Parameter"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:259
#, no-wrap
msgid ""
"The type constructors we looked at so far were all\n"
"of type `Type -> Type`. However, we can also implement `Functor`\n"
"for other type constructors. The only prerequisite is that\n"
"the type parameter we'd like to change with function `map` must\n"
"be the last in the argument list. For instance, here is the\n"
"`Functor` implementation for `Either e` (note, that `Either e`\n"
"has of course type `Type -> Type` as required):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:260
#, no-wrap
msgid ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:269
#, no-wrap
msgid ""
"Here is another example, this time for a type constructor of\n"
"type `Bool -> Type -> Type` (you might remember this from\n"
"the exercises in the [last chapter](IO.md)):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:270
#, no-wrap
msgid ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:280
#, no-wrap
msgid "Functor Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:284
#, no-wrap
msgid ""
"The nice thing about functors is how they can be paired and\n"
"nested with other functors and the results are functors again:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:285
#, no-wrap
msgid ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:297
#, no-wrap
msgid ""
"The above allows us to conveniently map over a pair of functors. Note,\n"
"however, that Idris needs some help with inferring the types involved:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:298
#, no-wrap
msgid ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:313
#, no-wrap
msgid ""
"More often, we'd like to map over several layers of nested functors\n"
"at once. Here's how to do this with an example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:314
#, no-wrap
msgid ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Functor.md:326
#, no-wrap
msgid "Named Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:334
#, no-wrap
msgid ""
"Sometimes, there are more ways to implement an interface for\n"
"a given type. For instance, for numeric types we can have\n"
"a `Monoid` representing addition and one representing multiplication.\n"
"Likewise, for nested functors, `map` can be interpreted as a mapping\n"
"over only the first layer of values, or a mapping over several layers\n"
"of values.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:339
#, no-wrap
msgid ""
"One way to go about this is to define single-field wrappers as\n"
"shown with data type `Comp` above. However, Idris also allows us\n"
"to define additional interface implementations, which must then\n"
"be given a name. For instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:340
#, no-wrap
msgid ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:350
#, no-wrap
msgid ""
"Note, that this defines a new implementation of `Functor`, which will\n"
"*not* be considered during implicit resolution in order\n"
"to avoid ambiguities. However,\n"
"it is possible to explicitly choose to use this implementation\n"
"by passing it as an explicit argument to `map`, prefixed with an `@`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:351
#, no-wrap
msgid ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:358
#, no-wrap
msgid ""
"In the example above, we used `Compose` instead of `Compose'`, since\n"
"the former is already exported by the *Prelude*.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:359
#, no-wrap
msgid "Functor Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:365
#, no-wrap
msgid ""
"Implementations of `Functor` are supposed to adhere to certain laws,\n"
"just like implementations of `Eq` or `Ord`. Again, these laws are\n"
"not verified by Idris, although it would be possible (and\n"
"often cumbersome) to do so.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:370
#, no-wrap
msgid ""
"1. `map id = id`: Mapping the identity function over a functor\n"
"    must not have any visible effect such as changing a container's\n"
"    structure or affecting the side effects perfomed when\n"
"    running an `IO` action.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:373
#, no-wrap
msgid ""
"`map (f . g) = map f . map g`: Sequencing two mappings must be identical\n"
"to a single mapping using the composition of the two functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:380
#, no-wrap
msgid ""
"Both of these laws request, that `map` is preserving the *structure*\n"
"of values. This is easier to understand with container types like\n"
"`List`, `Maybe`, or `Either e`, where `map` is not allowed to\n"
"add or remove any wrapped value, nor - in case of `List` -\n"
"change their order. With `IO`, this can best be described as `map`\n"
"not performing additional side effects.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:385
#, no-wrap
msgid ""
"Write your own implementations of `Functor'` for `Maybe`, `List`,\n"
"`List1`, `Vect n`, `Either e`, and `Pair a`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:388
#, no-wrap
msgid ""
"Write a named implementation of `Functor` for pairs of functors\n"
"(similar to the one implemented for `Product`).\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:391
#, no-wrap
msgid ""
"Implement `Functor` for data type `Identity` (which is available\n"
"from `Control.Monad.Identity` in *base*):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:392
#, no-wrap
msgid ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:404
#, no-wrap
msgid ""
"Here is a curious one: Implement `Functor` for `Const e` (which is also\n"
"available from `Control.Applicative.Const` in *base*). You might be\n"
"confused about the fact that the second type parameter has absolutely\n"
"no relevance at runtime, as there is no value of that type. Such\n"
"types are sometimes called *phantom types*. They can be quite useful\n"
"for tagging values with additional typing information.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:407
#, no-wrap
msgid ""
"   Don't let the above confuse you: There is only one possible implementation.\n"
"   As usual, use holes and let the compiler guide you if you get lost.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:408
#, no-wrap
msgid ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:416
#, no-wrap
msgid ""
"Here is a sum type for describing CRUD operations\n"
"(Create, Read, Update, and Delete) in a data store:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:426
#, no-wrap
msgid "   Implement `Functor` for `Crud i`.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:428
#, no-wrap
msgid "Here is a sum type for describing responses from a data server:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:439
#, no-wrap
msgid "   Implement `Functor` for `Repsonse e i`.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:441
#, no-wrap
msgid "Implement `Functor` for `Validated e`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:442
#, no-wrap
msgid ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:448
#, no-wrap
msgid "Applicative"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:453
#, no-wrap
msgid ""
"While `Functor` allows us to map a pure, unary function\n"
"over a value in a context, it doesn't allow us to combine\n"
"n such values under an n-ary function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:455
#, no-wrap
msgid "For instance, consider the following functions:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:456
#, no-wrap
msgid ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:478
#, no-wrap
msgid ""
"This behavior is not covered by `Functor`, yet it is a very\n"
"common thing to do. For instance, we might want to read two numbers\n"
"from standard input (both operations might fail), calculating the\n"
"product of the two. Here's the code:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:479
#, no-wrap
msgid ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:490
#, no-wrap
msgid ""
"And it won't stop here. We might just as well want to have\n"
"`liftMaybe3` for ternary functions and three `Maybe` arguments\n"
"and so on, for arbitrary numbers of arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:493
#, no-wrap
msgid ""
"But there is more: We'd also like to lift pure values into\n"
"the context in question. With this, we could do the following:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:494
#, no-wrap
msgid ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:511
#, no-wrap
msgid ""
"As you'll of course already know, I am now going to present a new\n"
"interface to encapsulate this behavior. It's called `Applicative`.\n"
"Here is its definition and an example implementation:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:512
#, no-wrap
msgid ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:527
#, no-wrap
msgid ""
"Interface `Applicative` is of course already exported by the *Prelude*.\n"
"There, function `app` is an operator sometimes called *app* or *apply*:\n"
"`(<*>)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:530
#, no-wrap
msgid ""
"You may wonder, how functions like `liftMaybe2` or `liftIO3` are related\n"
"to operator *apply*. Let me demonstrate this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:531
#, no-wrap
msgid ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:544
#, no-wrap
msgid ""
"It is really important for you to understand what's going on here, so let's\n"
"break these down. If we specialize `liftA2` to use `Maybe` for `f`,\n"
"`pure fun` is of type `Maybe (a -> b -> c)`. Likewise, `pure fun <*> fa`\n"
"is of type `Maybe (b -> c)`, as `(<*>)` will apply the value stored\n"
"in `fa` to the function stored in `pure fun` (currying!).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:550
#, no-wrap
msgid ""
"You'll often see such chains of applications of *apply*, the number\n"
"of *applies* corresponding to the arity of the function we lift.\n"
"You'll sometimes also see the following, which allows us to drop\n"
"the initial call to `pure`, and use the operator version of `map`\n"
"instead:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:551
#, no-wrap
msgid ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:564
#, no-wrap
msgid ""
"So, interface `Applicative` allows us to lift values (and functions!)\n"
"into computational contexts and apply them to values in the same\n"
"contexts. Before we will see an extended example why this is\n"
"useful, I'll quickly introduce some syntactic sugar for working\n"
"with applicative functors.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:565
#, no-wrap
msgid "Idiom Brackets"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:571
#, no-wrap
msgid ""
"The programming style used for implementing `liftA2'` and `liftA3'`\n"
"is also referred to as *applicative style* and is used a lot\n"
"in Haskell for combining several effectful computations\n"
"with a single pure function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:575
#, no-wrap
msgid ""
"In Idris, there is an alternative to using such chains of\n"
"operator applications: Idiom brackets. Here's another\n"
"reimplementation of `liftA2` and `liftA3`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:576
#, no-wrap
msgid ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:590
#, no-wrap
msgid ""
"The above implementations will be desugared to the one given\n"
"for `liftA2` and `liftA3`, again *before disambiguating,\n"
"type checking, and filling in of implicit values*. Like with the\n"
"*bind* operator, we can therefore write custom implementations\n"
"for `pure` and `(<*>)`, and Idris will use these if it\n"
"can disambiguate between the overloaded function names.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:591
#, no-wrap
msgid "Use Case: CSV Reader"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:604
#, no-wrap
msgid ""
"In order to understand the power and versatility that comes\n"
"with applicative functors, we will look at a slightly\n"
"extended example. We are going to write some utilities\n"
"for parsing and decoding content from CSV files. These\n"
"are files where each line holds a list of values separated\n"
"by commas (or some other delimiter). Typically, they are\n"
"used to store tabular data, for instance from spread sheet\n"
"applications. What we would like to do is convert\n"
"lines in a CSV file and store the result in custom\n"
"records, where each record field corresponds to a column\n"
"in the table.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:609
#, no-wrap
msgid ""
"For instance, here is a simple example\n"
"file, containing tabular user information from a web\n"
"store: First name, last name, age (optional), email address,\n"
"gender, and password.\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:610
#, no-wrap
msgid ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:621
#, no-wrap
msgid ""
"And here are the Idris data types necessary to hold\n"
"this information at runtime. We use again custom\n"
"string wrappers for increased type safety and\n"
"because it will allow us to define for each data type\n"
"what we consider to be valid input:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:622
#, no-wrap
msgid ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:650
#, no-wrap
msgid ""
"We start by defining an interface for reading fields\n"
"in a CSV file and writing implementations for\n"
"the data types we'd like to read:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:651
#, no-wrap
msgid ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:659
#, no-wrap
msgid ""
"Below are implementations for `Gender` and `Bool`. I decided\n"
"to in these cases encode each value with a single lower\n"
"case character:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:660
#, no-wrap
msgid ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:675
#, no-wrap
msgid ""
"For numeric types, we can use the parsing functions\n"
"from `Data.String`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:676
#, no-wrap
msgid ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:692
#, no-wrap
msgid ""
"For optional values, the stored type must itself\n"
"come with an instance of `CSVField`. We can then treat\n"
"the empty string `\"\"` as `Nothing`, while a non-empty\n"
"string will be passed to the encapsulated type's field reader.\n"
"(Remember that `(<$>)` is an alias for `map`.)\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:693
#, no-wrap
msgid ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:703
#, no-wrap
msgid ""
"Finally, for our string wrappers, we need to decide what\n"
"we consider to be valid values. For simplicity, I decided\n"
"to limit the length of allowed strings and the set of\n"
"valid characters.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:704
#, no-wrap
msgid ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"-- please note that isSpace holds as well for other characaters than ' '\n"
"-- e.g. for non-breaking space: isSpace '\\160' = True\n"
"-- but only ' ' shall be llowed in passwords\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:748
#, no-wrap
msgid ""
"In a later chapter, we will learn about refinement types and\n"
"how to store an erased proof of validity together with\n"
"a validated value.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:752
#, no-wrap
msgid ""
"We can now start to decode whole lines in a CSV file.\n"
"In order to do so, we first introduce a custom error\n"
"type encapsulating how things can go wrong:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:753
#, no-wrap
msgid ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:763
#, no-wrap
msgid ""
"We can now use `CSVField` to read a single field at a given\n"
"line and position in a CSV file, and return a `FieldError` in case\n"
"of a failure.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:764
#, no-wrap
msgid ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:775
#, no-wrap
msgid ""
"If we know in advance the number of fields we need to read,\n"
"we can try and convert a list of strings to a `Vect` of\n"
"the given length. This facilitates reading record values of\n"
"a known number of fields, as we get the correct number\n"
"of string variables when pattern matching on the vector:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:776
#, no-wrap
msgid ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:786
#, no-wrap
msgid ""
"Finally, we can implement function `readUser` to try and convert\n"
"a single line in a CSV-file to a value of type `User`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:787
#, no-wrap
msgid ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:803 ../src/Tutorial/Traverse.md:122
#, no-wrap
msgid "Let's give this a go at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:804
#, no-wrap
msgid ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:819
#, no-wrap
msgid ""
"Note, how in the implementation of `readUser'` we used\n"
"an idiom bracket to map a function of six arguments (`MkUser`)\n"
"over six values of type `Either CSVError`. This will automatically\n"
"succeed, if and only if all of the parsings have\n"
"succeeded. It would have been notoriously cumbersome resulting\n"
"in much less readable code to implement\n"
"`readUser'` with a succession of six nested pattern matches.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:822
#, no-wrap
msgid ""
"However, the idiom bracket above looks still quite repetitive.\n"
"Surely, we can do better?\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Functor.md:823
#, no-wrap
msgid "A Case for Heterogeneous Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:830
#, no-wrap
msgid ""
"It is time to learn about a family of types, which can\n"
"be used as a generic representation for record types, and\n"
"which will allow us to represent and read rows in\n"
"heterogeneous tables with a minimal amount of code: Heterogeneous\n"
"lists.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:831
#, no-wrap
msgid ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:844
#, no-wrap
msgid ""
"A heterogeneous list is a list type indexed over a *list of types*.\n"
"This allows us to at each position store a value of the\n"
"type at the same position in the list index. For instance,\n"
"here is a variant, which stores three values of types\n"
"`Bool`, `Nat`, and `Maybe String` (in that order):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:845
#, no-wrap
msgid ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:857
#, no-wrap
msgid ""
"You could argue that heterogeneous lists are just tuples\n"
"storing values of the given types. That's right, of course,\n"
"however, as you'll learn the hard way in the exercises,\n"
"we can use the list index to perform compile-time computations\n"
"on `HList`, for instance when concatenating two such lists\n"
"to keep track of the types stored in the result at the\n"
"same time.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:862
#, no-wrap
msgid ""
"But first, we'll make use of `HList` as a means to\n"
"concisely parse CSV-lines. In order to do that, we\n"
"need to introduce a new interface for types corresponding\n"
"to whole lines in a CSV-file:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:863
#, no-wrap
msgid ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:874
#, no-wrap
msgid ""
"We'll now write two implementations of `CSVLine` for `HList`:\n"
"One for the `Nil` case, which will succeed if and only if\n"
"the current list of strings is empty. The other for the *cons*\n"
"case, which will try and read a single field from the head\n"
"of the list and the remainder from its tail. We use\n"
"again an idiom bracket to concatenate the results:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:875
#, no-wrap
msgid ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:890
#, no-wrap
msgid ""
"And that's it! All we need to add is two utility function\n"
"for decoding whole lines before they have been split into\n"
"tokens, one of which is specialized to `HList` and takes an\n"
"erased list of types as argument to make it more convenient to\n"
"use at the REPL:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:891
#, no-wrap
msgid ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:905
#, no-wrap
msgid ""
"It's time to reap the fruits of our labour and give this a go at\n"
"the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:906
#, no-wrap
msgid ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:913
#, no-wrap
msgid "Applicative Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:917
#, no-wrap
msgid ""
"Again, `Applicative` implementations must follow certain\n"
"laws. Here they are:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:920
#, no-wrap
msgid ""
"`pure id <*> fa = fa`: Lifting and applying the identity\n"
"function has no visible effect.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:925
#, no-wrap
msgid ""
"`[| f . g |] <*> v = f <*> (g <*> v)`:\n"
"I must not matter, whether we compose our functions\n"
"first and then apply them, or whether we apply\n"
"our functions first and then compose them.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:928
#, no-wrap
msgid ""
"  The above might be hard to understand, so here\n"
"  they are again with explicit types and implementations:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:929
#, no-wrap
msgid ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:939
#, no-wrap
msgid ""
"  The second applicative law states, that the two implementations\n"
"  `compL` and `compR` should behave identically.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:942
#, no-wrap
msgid ""
"`pure f <*> pure x = pure (f x)`. This is also called the\n"
"*homomorphism* law. It should be pretty self-explaining.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:945
#, no-wrap
msgid ""
"`f <*> pure v = pure ($ v) <*> f`. This is called the law\n"
"of *interchange*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:947
#, no-wrap
msgid "  This should again be explained with a concrete example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:948
#, no-wrap
msgid ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:960
#, no-wrap
msgid ""
"  Note, that `($ v)` has type `(a -> b) -> b`, so this\n"
"  is a function type being applied to `f`, which has\n"
"  a function of type `a -> b` wrapped in a `Maybe`\n"
"  context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:964
#, no-wrap
msgid ""
"  The law of interchange states that it must not matter\n"
"  whether we apply a pure value from the left or\n"
"  right of the *apply* operator.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:968
#, no-wrap
msgid "Implement `Applicative'` for `Either e` and `Identity`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:973
#, no-wrap
msgid ""
"Implement `Applicative'` for `Vect n`. Note: In order to\n"
"implement `pure`, the length must be known at runtime.\n"
"This can be done by passing it as an unerased implicit\n"
"to the interface implementation:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:974
#, no-wrap
msgid "   implementation {n : _} -> Applicative' (Vect n) where\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:980
#, no-wrap
msgid ""
"Implement `Applicative'` for `Pair e`, with `e` having\n"
"a `Monoid` constraint.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:983
#, no-wrap
msgid ""
"Implement `Applicative` for `Const e`, with `e` having\n"
"a `Monoid` constraint.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:988
#, no-wrap
msgid ""
"Implement `Applicative` for `Validated e`, with `e` having\n"
"a `Semigroup` constraint. This will allow us to use `(<+>)`\n"
"to accumulate errors in case of two `Invalid` values in\n"
"the implementation of *apply*.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:993
#, no-wrap
msgid ""
"Add an additional data constructor of\n"
"type `CSVError -> CSVError -> CSVError`\n"
"to `CSVError` and use this to implement `Semigroup` for\n"
"`CSVError`.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:997
#, no-wrap
msgid ""
"Refactor our CSV-parsers and all related functions so that\n"
"they return `Validated` instead of `Either`. This will only\n"
"work, if you solved exercise 6.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1003
#, no-wrap
msgid ""
"   Two things to note: You will have to adjust very little of\n"
"   the existing code, as we can still use applicative syntax\n"
"   with `Validated`. Also, with this change, we enhanced our CSV-parsers\n"
"   with the ability of error accumulation. Here are some examples\n"
"   from a REPL session:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1004
#, no-wrap
msgid ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1018
#, no-wrap
msgid ""
"   Behold the power of applicative functors and heterogeneous lists: With\n"
"   only a few lines of code we wrote a pure, type-safe, and total\n"
"   parser with error accumulation for lines in CSV-files, which is\n"
"   very convenient to use at the same time!\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Functor.md:1021
#, no-wrap
msgid ""
"Since we introduced heterogeneous lists in this chapter, it\n"
"would be a pity not to experiment with them a little.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1030
#, no-wrap
msgid ""
"   This exercise is meant to sharpen your skills in type wizardry.\n"
"   It therefore comes with very few hints. Try to decide yourself\n"
"   what behavior you'd expect from a given function, how to express\n"
"   this in the types, and how to implement it afterwards.\n"
"   If your types are correct and precise enough, the implementations\n"
"   will almost come for free. Don't give up too early if you get stuck.\n"
"   Only if you truly run out of ideas should you have a glance\n"
"   at the solutions (and then, only at the types at first!)\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1032
#, no-wrap
msgid "Implement `head` for `HList`.\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1034
#, no-wrap
msgid "Implement `tail` for `HList`.\n"
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1036
#, no-wrap
msgid "Implement `(++)` for `HList`.\n"
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1040
#, no-wrap
msgid ""
"Implement `index` for `HList`. This might be harder than the other three.\n"
"Go back and look how we implemented `indexList` in an\n"
"[earlier exercise](Dependent.md) and start from there.\n"
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1046
#, no-wrap
msgid ""
"Package *contrib*, which is part of the Idris project, provides\n"
"`Data.HVect.HVect`, a data type for heterogeneous vectors. The only difference\n"
"to our own `HList` is, that `HVect` is indexed over a vector of\n"
"types instead of a list of types. This makes it easier to express certain\n"
"operations at the type level.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1049
#, no-wrap
msgid ""
"      Write your own implementation of `HVect` together with functions\n"
"      `head`, `tail`, `(++)`, and `index`.\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1053
#, no-wrap
msgid ""
"For a real challenge, try implementing a function for\n"
"transposing a `Vect m (HVect ts)`. You'll first have to\n"
"be creative about how to even express this in the types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1060
#, no-wrap
msgid ""
"      Note: In order to implement this, you'll need to pattern match\n"
"      on an erased argument in at least one case to help Idris with\n"
"      type inference. Pattern matching on erased arguments is forbidden\n"
"      (they are erased after all, so we can't inspect them at runtime),\n"
"      *unless* the structure of the value being matched on can be derived\n"
"      from another, un-erased argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1064
#, no-wrap
msgid ""
"      Also, don't worry if you get stuck on this one. It took me several\n"
"      tries to figure it out. But I enjoyed the experience, so I just *had*\n"
"      to include it here. :-)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1068
#, no-wrap
msgid ""
"      Note, however, that such a function might be useful when working with\n"
"      CSV-files, as it allows us to convert a table represented as\n"
"      rows (a vector of tuples) to one represented as columns (a tuple of vectors).\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Functor.md:1072
#, no-wrap
msgid ""
"Show, that the composition of two applicative functors is\n"
"again an applicative functor by implementing `Applicative`\n"
"for `Comp f g`.\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Functor.md:1076
#, no-wrap
msgid ""
"Show, that the product of two applicative functors is\n"
"again an applicative functor by implementing `Applicative`\n"
"for `Prod f g`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:1077
#, no-wrap
msgid "Monad"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1084
#, no-wrap
msgid ""
"Finally, `Monad`. A lot of ink has been spilled about this one.\n"
"However, after what we already saw in the [chapter about `IO`](IO.md),\n"
"there is not much left to discuss here. `Monad` extends\n"
"`Applicative` and adds two new related functions: The *bind*\n"
"operator (`(>>=)`) and function `join`. Here is its definition:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1085
#, no-wrap
msgid ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1094
#, no-wrap
msgid ""
"Implementers of `Monad` are free to choose to either implement\n"
"`(>>=)` or `join` or both. You will show in an exercise, how\n"
"`join` can be implemented in terms of *bind* and vice versa.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1102
#, no-wrap
msgid ""
"The big difference between `Monad` and `Applicative` is, that the\n"
"former allows a computation to depend on the result of an\n"
"earlier computation. For instance, we could decide based on\n"
"a string read from standard input whether to delete a file\n"
"or play a song. The result of the first `IO` action\n"
"(reading some user input) will affect, which `IO` action to run next.\n"
"This is not possible with the *apply* operator:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1103
#, no-wrap
msgid "(<*>) : IO (a -> b) -> IO a -> IO b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1118
#, no-wrap
msgid ""
"The two `IO` actions have already been decided on when they\n"
"are being passed as arguments to `(<*>)`. The result of the first\n"
"cannot - in the general case - affect which computation to\n"
"run in the second. (Actually, with `IO` this would theoretically be\n"
"possible via side effects: The first action could write some\n"
"command to a file or overwrite some mutable state, and the\n"
"second action could read from that file or state, thus\n"
"deciding on the next thing to do. But this is a speciality\n"
"of `IO`, not of applicative functors in general. If the functor in\n"
"question was `Maybe`, `List`, or `Vector`, no such thing\n"
"would be possible.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1124
#, no-wrap
msgid ""
"Let's demonstrate the difference with an example. Assume\n"
"we'd like to enhance our CSV-reader with the ability to\n"
"decode a line of tokens to a sum type. For instance,\n"
"we'd like to decode CRUD requests from the lines of a\n"
"CSV-file:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1125
#, no-wrap
msgid ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1137
#, no-wrap
msgid ""
"We need a way to on each line decide, which data constructor\n"
"to choose for our decoding. One way to do this is to\n"
"put the name of the data constructor (or some other\n"
"tag of identification) in the first column of the CSV-file:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1138
#, no-wrap
msgid ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1167
#, no-wrap
msgid ""
"I added two utility function for helping with type inference\n"
"and to get slightly nicer syntax. The important thing to note\n"
"is, how we pattern match on the result of the first\n"
"parsing function to decide on the data constructor\n"
"and thus the next parsing function to use.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1169
#, no-wrap
msgid "Here's how this works at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1170
#, no-wrap
msgid ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1187
#, no-wrap
msgid ""
"To conclude, `Monad`, unlike `Applicative`, allows us to\n"
"chain computations sequentially, where intermediary\n"
"results can affect the behavior of later computations.\n"
"So, if you have n unrelated effectful computations and want\n"
"to combine them under a pure, n-ary function, `Applicative`\n"
"will be sufficient. If, however, you want to decide\n"
"based on the result of an effectful computation what\n"
"computation to run next, you need a `Monad`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1193
#, no-wrap
msgid ""
"Note, however, that `Monad` has one important drawback\n"
"compared to `Applicative`: In general, monads don't compose.\n"
"For instance, there is no `Monad` instance for `Either e . IO`.\n"
"We will later learn about monad transformers, which can\n"
"be composed with other monads.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:1194
#, no-wrap
msgid "Monad Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1197
#, no-wrap
msgid "Without further ado, here are the laws for `Monad`:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1201
#, no-wrap
msgid ""
"`ma >>= pure = ma` and `pure v >>= f = f v`.\n"
"These are monad's identity laws. Here they are as\n"
"concrete examples:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1202
#, no-wrap
msgid ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1215
#, no-wrap
msgid ""
"  These two laws state that `pure` should behave\n"
"  neutrally w.r.t. *bind*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1221
#, no-wrap
msgid ""
"`(m >>= f) >>= g = m >>= (f >=> g)`.\n"
"This is the law of associativity for monad.\n"
"You might not have seen the second operator `(>=>)`.\n"
"It can be used to sequence effectful computations\n"
"and has the following type:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1222
#, no-wrap
msgid ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1232
#, no-wrap
msgid ""
"The above are the *official* monad laws. However, we need to\n"
"consider a third one, given that in Idris (and Haskell)\n"
"`Monad` extends `Applicative`: As `(<*>)` can be implemented\n"
"in terms of `(>>=)`, the actual implementation of `(<*>)`\n"
"must behave the same as the implementation in terms of `(>>=)`:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1234
#, no-wrap
msgid "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:1240
#, no-wrap
msgid ""
"`Applicative` extends `Functor`, because every `Applicative`\n"
"is also a `Functor`. Proof this by implementing `map` in\n"
"terms of `pure` and `(<*>)`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:1244
#, no-wrap
msgid ""
"`Monad` extends `Applicative`, because every `Monad` is\n"
"also an `Applicative`. Proof this by implementing\n"
"`(<*>)` in terms of `(>>=)` and `pure`.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:1247
#, no-wrap
msgid ""
"Implement `(>>=)` in terms of `join` and other functions\n"
"in the `Monad` hierarchy.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:1250
#, no-wrap
msgid ""
"Implement `join` in terms of `(>>=)` and other functions\n"
"in the `Monad` hierarchy.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:1253
#, no-wrap
msgid ""
"There is no lawful `Monad` implementation for `Validated e`.\n"
"Why?\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:1259
#, no-wrap
msgid ""
"In this slightly extended exercise, we are going to simulate\n"
"CRUD operations on a data store. We will use a mutable\n"
"reference (imported from `Data.IORef` from the *base* library)\n"
"holding a list of `User`s paired with a unique ID\n"
"of type `Nat` as our user data base:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1260
#, no-wrap
msgid ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1270
#, no-wrap
msgid ""
"   Most operations on a database come with a risk of failure:\n"
"   When we try to update or delete a user, the entry in question\n"
"   might no longer be there. When we add a new user, a user\n"
"   with the given email address might already exist. Here is\n"
"   a custom error type to deal with this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1271
#, no-wrap
msgid ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1280
#, no-wrap
msgid ""
"   In general, our functions will therefore have a\n"
"   type similar to the following:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1281
#, no-wrap
msgid "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1287
#, no-wrap
msgid ""
"   We'd like to abstract over this, by introducing a new wrapper\n"
"   type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1288
#, no-wrap
msgid ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1297
#, no-wrap
msgid ""
"   We are now ready to write us some utility functions. Make sure\n"
"   to follow the following business rules when implementing the\n"
"   functions below:\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1300
#, no-wrap
msgid ""
"Email addresses in the DB must be unique. (Consider\n"
"implementing `Eq Email` to verify this).\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1302
#, no-wrap
msgid "The size limit of 1000 entries must not be exceeded.\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1306
#, no-wrap
msgid ""
"Operations trying to lookup a user by their ID must\n"
"fail with `UserNotFound` in case no entry was found\n"
"in the DB.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1311
#, no-wrap
msgid ""
"   You'll need the following functions from `Data.IORef` when working\n"
"   with mutable references: `newIORef`, `readIORef`, and `writeIORef`.\n"
"   In addition, functions `Data.List.lookup` and `Data.List.find` might\n"
"   be useful to implement some of the functions below.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1313
#, no-wrap
msgid "Implement interfaces `Functor`, `Applicative`, and `Monad` for `Prog`.\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1315
#, no-wrap
msgid "Implement interface `HasIO` for `Prog`.\n"
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1317
#, no-wrap
msgid "Implement the following utility functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1320
#, no-wrap
msgid ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1322
#, no-wrap
msgid "      getUsers : Prog (List (Nat,User))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1325
#, no-wrap
msgid ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1329
#, no-wrap
msgid ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1333
#, no-wrap
msgid ""
"Implement function `lookupUser`. This should fail\n"
"with an appropriate error, if a user with the given ID\n"
"cannot be found.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1337
#, no-wrap
msgid ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1342
#, no-wrap
msgid ""
"Implement function `deleteUser`. This should fail\n"
"with an appropriate error, if a user with the given ID\n"
"cannot be found. Make use of `lookupUser` in your\n"
"implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1346
#, no-wrap
msgid ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1352
#, no-wrap
msgid ""
"Implement function `addUser`. This should fail, if\n"
"a user with the given `Email` already exists, or\n"
"if the data banks size limit of 1000 entries is exceeded.\n"
"In addition, this should create and return a unique\n"
"ID for the new user entry.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1356
#, no-wrap
msgid ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Functor.md:1361
#, no-wrap
msgid ""
"Implement function `updateUser`. This should fail, if\n"
"the user in question cannot be found or\n"
"a user with the updated user's `Email` already exists.\n"
"The returned value should be the updated user.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1365
#, no-wrap
msgid ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   8. '
#: ../src/Tutorial/Functor.md:1369
#, no-wrap
msgid ""
"Data type `Prog` is actually too specific. We could just\n"
"as well abstract over the error type and the `DB`\n"
"environment:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1375
#, no-wrap
msgid ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1381
#, no-wrap
msgid ""
"      Verify, that all interface implementations you wrote\n"
"      for `Prog` can be used verbatim to implement the same\n"
"      interfaces for `Prog' env err`. The same goes for\n"
"      `throw` with only a slight adjustment in the function's\n"
"      type.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:1382
#, no-wrap
msgid "Background and further Reading"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1391
#, no-wrap
msgid ""
"Concepts like *functor* and *monad* have their origin in *category theory*,\n"
"a branch of mathematics. That is also where their laws come from.\n"
"Category theory was found to have applications in\n"
"programming language theory, especially functional programming.\n"
"It is a highly abstract topic, but there is a pretty accessible\n"
"introduction for programmers, written by\n"
"[Bartosz Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1397
#, no-wrap
msgid ""
"The usefulness of applicative functors as a middle ground between\n"
"functor and monad was discovered several years after monads had\n"
"already been in use in Haskell. They were introduced in the\n"
"article [*Applicative Programming with Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html),\n"
"which is freely available online and a highly recommended read.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1404
#, no-wrap
msgid ""
"Interfaces `Functor`, `Applicative`, and `Monad` abstract over\n"
"programming patterns that come up when working with type\n"
"constructors of type `Type -> Type`. Such data types are also\n"
"referred to as *values in a context*, or *effectful computations*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1407
#, no-wrap
msgid ""
"`Functor` allows us to *map* over values in a context without\n"
"affecting the context's underlying structure.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1410
#, no-wrap
msgid ""
"`Applicative` allows us to apply n-ary functions to n effectful\n"
"computations and to lift pure values into a context.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1414
#, no-wrap
msgid ""
"`Monad` allows us to chain effectful computations, where the\n"
"intermediary results can affect, which computation to run\n"
"further down the chain.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1418
#, no-wrap
msgid ""
"Unlike `Monad`, `Functor` and `Applicative` compose: The\n"
"product and composition of two functors or applicatives\n"
"are again functors or applicatives, respectively.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1422
#, no-wrap
msgid ""
"Idris provides syntactic sugar for working with some of\n"
"the interfaces presented here: Idiom brackets for `Applicative`,\n"
"*do blocks* and the bang operator for `Monad`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:1423 ../src/Tutorial/Intro.md:444
#, no-wrap
msgid "What's next?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1428
#, no-wrap
msgid ""
"In the [next chapter](Folds.md) we get to learn more about\n"
"recursion, totality checking, and an interface for\n"
"collapsing container types: `Foldable`.\n"
msgstr ""
