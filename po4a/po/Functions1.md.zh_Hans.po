# Chinese translations for po package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the po package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: po 4a\n"
"POT-Creation-Date: 2025-05-15 07:57+0000\n"
"PO-Revision-Date: 2025-05-15 03:06+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1398
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Install.md:102 ../src/Appendices/Neovim.md:364
#: ../src/Appendices/Projects.md:878 ../src/Appendices/QTT.md:442
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr "下一步是什么"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1430
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Intro.md:453
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1410 ../src/Tutorial/Traverse.md:1148
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, no-wrap
msgid "Functions Part 1"
msgstr "函数第 1 部分"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
msgid ""
"Idris is a *functional* programming language. This means, that functions are "
"its main form of abstraction (unlike for instance in an object oriented "
"language like Java, where *objects* and *classes* are the main form of "
"abstraction). It also means that we expect Idris to make it very easy for us "
"to compose and combine functions to create new functions. In fact, in Idris "
"functions are *first class*: Functions can take other functions as arguments "
"and can return functions as their results."
msgstr ""
"Idris 是一种*函数式*编程语言。这意味着，函数是它的主要抽象形式（与 Java 等面"
"向对象的语言不同，其中 *objects* 和 *classes* 是抽象的主要形式）。这也意味着"
"我们希望 Idris 能够让我们非常轻松地组合函数以创建新函数。实际上，在 Idris "
"中，函数是*一等*的：函数可以将其他函数作为参数，并且可以将函数作为结果返回。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
msgid ""
"We already learned about the basic shape of top level function declarations "
"in Idris in the [introduction](Intro.md), so we will continue from what we "
"learned there."
msgstr ""
"我们已经在 [介绍](Intro.md) 中了解了 Idris 中顶级函数声明的基本形式，因此我们"
"将从那里学到的内容继续。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr "module Tutorial.Functions1\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, no-wrap
msgid "Functions with more than one Argument"
msgstr "具有多个参数的函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
msgid ""
"Let's implement a function, which checks if its three `Integer` arguments "
"form a [Pythagorean triple](https://en.wikipedia.org/wiki/"
"Pythagorean_triple).  We get to use a new operator for this: `==`, the "
"equality operator."
msgstr ""
"让我们实现一个函数，它检查它的三个 `Integer` 参数是否形成一个 [勾股三元组]"
"(https://en.wikipedia.org/wiki/Pythagorean_triple)。我们为此使用一个新的运算"
"符：`==`，相等运算符。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
msgid ""
"Let's give this a spin at the REPL before we talk a bit about the types:"
msgstr "在讨论类型之前，让我们先在 REPL 上试一下："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr "从这个例子可以看出，多参函数的类型包含一个参数类型的序列（也称为 *输入类型*），由函数箭头（`->`）链接起来，其中由输出类型终止（在本例中为 `Bool`）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
msgid ""
"The implementation looks a bit like a mathematical equation: We list the "
"arguments on the left hand side of `=` and describe the computation(s) to "
"perform with them on the right hand side. Function implementations in "
"functional programming languages often have this more mathematical look "
"compared to implementations in imperative languages, which often describe "
"not *what* to compute, but *how* to compute it by describing an algorithm as "
"a sequence of imperative statements. We will later see that this imperative "
"style is also available in Idris, but whenever possible we prefer the "
"declarative style."
msgstr ""
"该实现看起来有点像一个数学方程：我们在 `=` 的左侧列出参数，并在右侧描述要使用"
"它们执行的计算。与命令式语言中的实现相比，函数式编程语言中的函数实现通常具有"
"更多的数学外观，命令式语言通常不是描述*要计算什么*，而是通过将算法描述为*如何"
"*来计算它命令式语句的序列。我们稍后会看到这种命令式风格在 Idris 中也可用，但"
"只要有可能，我们更喜欢声明式风格。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
msgid ""
"As can be seen in the REPL example, functions can be invoked by passing the "
"arguments separated by whitespace. No parentheses are necessary unless one "
"of the expressions we pass as the function's arguments contains itself "
"additional whitespace.  This comes in very handy when we apply functions "
"only partially (see later in this chapter)."
msgstr ""
"从 REPL 示例中可以看出，可以通过传递由空格分隔的参数来调用函数。除非我们作为"
"将包含额外的空格的表达式作为函数参数进行传递，否则不需要括号。当我们仅部分应"
"用函数时，这非常方便（见本章后面）。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive data type "
"built into the Idris language but just a custom data type that you could "
"have written yourself. We will learn more about declaring new data types in "
"the next chapter."
msgstr ""
"请注意，与 `Integer` 或 `Bits8` 不同，`Bool` 不是 Idris 语言中内置的原语数据"
"类型，而只是您可以自己编写的自定义数据类型.我们将在下一章了解更多关于声明新数"
"据类型的内容。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, no-wrap
msgid "Function Composition"
msgstr "函数组合"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
msgid ""
"Functions can be combined in several ways, the most direct probably being "
"the dot operator:"
msgstr "函数可以通过多种方式组合，最直接的可能是点运算符："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
msgid "Give this a try at the REPL! Does it do what you'd expect?"
msgstr "在 REPL 试试这个！它是否符合您的预期？"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
msgid ""
"We could have implemented `squareTimes2` without using the dot operator as "
"follows:"
msgstr "我们可以在不使用点运算符的情况下实现 `squareTimes2`，如下所示："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr "需要注意的是，由点链接的函数，运算符会从右到左调用： `times2 . square`，等同于 `\\n => times2 (square n)` ，而不是 `\\n => square (times2 n)`。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
msgid ""
"We can conveniently chain several functions using the dot operator to write "
"more complex functions:"
msgstr "我们可以方便地使用点运算符链接多个函数来编写更复杂的函数："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
msgid ""
"This will first multiply the argument by four, then square it twice before "
"converting it to a string (`show`) and reversing the resulting `String` "
"(functions `show` and `reverse` are part of the Idris *Prelude* and as such "
"are available in every Idris program)."
msgstr ""
"这将首先将参数乘以四，然后将其平方两次，然后将其转换为字符串 (`show`) 并反转"
"结果 `String`（函数 `show` 和 `reverse` 是 Idris *Prelude* 的一部分，因此在每"
"个 Idris 程序中都可用）。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, no-wrap
msgid "Higher-order Functions"
msgstr "高阶函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
msgid ""
"Functions can take other functions as arguments. This is an incredibly "
"powerful concept and we can go crazy with this very easily. But for sanity's "
"sake, we'll start slowly:"
msgstr ""
"函数可以将其他函数作为参数。这是一个非常强大的概念，我们可以很容易地为此发"
"疯。但为了理智起见，我们将慢慢开始："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
msgid ""
"First `isEven` uses the `mod` function to check, whether an integer is "
"divisible by two. But the interesting function is `testSquare`. It takes two "
"arguments: The first argument is of type *function from `Integer` to "
"`Bool`*, and the second of type `Integer`. This second argument is squared "
"before being passed to the first argument. Again, give this a go at the REPL:"
msgstr ""
"首先 `isEven` 使用 `mod` 函数来检查一个整数是否可以被 2 整除。但有趣的函数是 "
"`testSquare`。它有两个参数：第一个参数的类型是 *从 `Integer` 到 `Bool` 的函数"
"*，第二个参数是 `Integer` 类型。在传递给应用第一个参数之前，先把第二个参数进"
"行平方计算。继续在 REPL 上试一试："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
msgid ""
"Take your time to understand what's going on here. We pass function `isEven` "
"as an argument to `testSquare`. The second argument is an integer, which "
"will first be squared and then passed to `isEven`. While this is not very "
"interesting, we will see lots of use cases for passing functions as "
"arguments to other functions."
msgstr ""
"花点时间了解这里发生了什么。我们将函数 `isEven` 作为参数传递给 `testSquare`。"
"第二个参数是一个整数，它首先会被平方，然后传递给 `isEven`。虽然这不是很有趣，"
"但我们会看到很多将函数作为参数传递给其他函数的用例。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
msgid ""
"I said above, we could go crazy pretty easily.  Consider for instance the "
"following example:"
msgstr "我在上面说过，我们很容易发疯。例如，考虑以下示例："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:645
msgid "And at the REPL:"
msgstr "在 REPL 试一下："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
msgid ""
"You might be surprised about this behavior, so we'll try and break it down. "
"The following two expressions are identical in their behavior:"
msgstr ""
"您可能会对这种行为感到惊讶，因此我们将尝试对其进行分解。以下两个表达式的行为"
"相同："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
msgid ""
"So, `square` raises its argument to the 2nd power, `twice square` raises it "
"to its 4th power (by invoking `square` twice in succession), `twice (twice "
"square)` raises it to its 16th power (by invoking `twice square` twice in "
"succession), and so on, until `twice (twice (twice (twice square)))` raises "
"it to its 65536th power resulting in an impressively huge result."
msgstr ""
"因此，`square` 将其参数提升到 2 次方，`twice square` 将其提升到 4 次方（通过"
"连续调用 `square` 两次），`twice (twice square)` 将其提升到其 16 次方（通过连"
"续调用 `twice square` 两次），依此类推，直到 `twice (twice (twice (twice "
"square))))` 将其提高到 65536 次方，从而产生了令人印象深刻的巨大结果。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, no-wrap
msgid "Currying"
msgstr "柯里化"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
msgid ""
"Once we start using higher-order functions, the concept of partial function "
"application (also called *currying* after mathematician and logician Haskell "
"Curry) becomes very important."
msgstr ""
"一旦我们开始使用高阶函数，偏应用函数的概念（在数学家和逻辑学家 Haskell Curry "
"之后也称为 *柯里化*）变得非常重要。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
msgid "Load this file in a REPL session and try the following:"
msgstr "在 REPL 会话中加载此文件并尝试以下操作："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr "注意，我们如何在 Idris 中部分应用多参函数，并且返回一个新函数。例如， `isTriple 1` 会将参数 `1` 应用于函数 `isTriple` 并因此返回一个新函数，类型为为 `Integer -> Integer -> Bool`。我们甚至可以使用这种部分应用函数的结果作为一个新的顶级定义：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
msgid ""
"We already used partial function application in our `twice` examples above "
"to get some impressive results with very little code."
msgstr ""
"我们已经在上面的 `twice` 示例中使用了偏应用函数的应用程序，只需很少的代码即可"
"获得一些令人印象深刻的结果。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, no-wrap
msgid "Anonymous Functions"
msgstr "匿名函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
msgid ""
"Sometimes we'd like to pass a small custom function to a higher-order "
"function without bothering to write a top level definition. For instance, in "
"the following example, function `someTest` is very specific and probably not "
"very useful in general, but we'd still like to pass it to higher-order "
"function `testSquare`:"
msgstr ""
"有时我们想将一个小的自定义函数传递给一个高阶函数，而无需编写顶层定义。例如，"
"在下面的示例中，函数 `someTest` 非常具体，一般来说可能不是很有用，但我们仍然"
"希望将它传递给高阶函数 `testSquare`："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
msgid "Here's, how to pass it to `testSquare`:"
msgstr "下面将展示如何将其传递给 `testSquare`："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
msgid ""
"Instead of defining and using `someTest`, we can use an anonymous function:"
msgstr "我们也可以使用匿名函数，而不用定义和使用 `someTest`："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr "匿名函数有时也称为 *lambdas*（来自[λ演算](https://en.wikipedia.org/wiki/Lambda_calculus)),并且选择了反斜杠，因为它类似于希腊语字母 *λ*。 `\\n =>` 语法引入了一个新的参数为 `n` 的匿名函数，实现位于函数箭头的右侧。像其他顶级函数一样，lambda 可以有多个参数，并以逗号分隔：`\\x,y => x * x + y`。当我们将 lambdas 作为参数传递给高阶函数时，它们通常需要用括号括起来或由美元运算符 `($)` 分开（请参阅下一节）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
msgid ""
"Note that, in a lambda, arguments are not annotated with types, so Idris has "
"to be able to infer them from the current context."
msgstr ""
"请注意，在 lambda 中，参数不使用类型进行注释，因此 Idris 必须能够从当前上下文"
"中推断出它们。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, no-wrap
msgid "Operators"
msgstr "运算符"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into the "
"language, but are just regular Idris function with some special support for "
"using them in infix notation.  When we don't use operators in infix "
"notation, we have to wrap them in parentheses."
msgstr ""
"在 Idris 中，`.`、`*` 或 `+` 等中缀运算符并未内置于语言中，而只是常规的 "
"Idris 函数对应的中缀符号。当我们使用非中缀表示法的运算符时，我们必须将它们包"
"裹在括号中。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr "举个例子，让我们为类型为 `Bits8 -> Bits8` 的函数自定义运算符：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr "除了声明和定义运算符本身，我们还必须指定它的结合性：`infixr 4 >>>` 表示，`(>>>)` 关联到右边（意味着 `f >>> g >>> h` 将被解释为 `f >>> (g >>> h)`)优先级为 `4`。你也可以在 REPL 中 看看 *Prelude* 导出的运算符的结合性：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
msgid ""
"When you mix infix operators in an expression, those with a higher priority "
"bind more tightly. For instance, `(+)` is left associated with a priority of "
"8, while `(*)` is left associated with a priority of 9. Hence, `a * b + c` "
"is the same as `(a * b) + c` instead of `a * (b + c)`."
msgstr ""
"当您在表达式中混合使用中缀运算符时，具有较高优先级的运算符绑定得更紧密。例"
"如，`(+)` 的优先级为 8，而 `(*)` 的优先级为 9。因此，`a * b + c ` 与 `(a * "
"b) + c` 相同，而不是 `a * (b + c)`。"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, no-wrap
msgid "Operator Sections"
msgstr "运算符块"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
msgid ""
"Operators can be partially applied just like regular functions. In this "
"case, the whole expression has to be wrapped in parentheses and is called an "
"*operator section*. Here are two examples:"
msgstr ""
"运算符可以像常规函数一样被部分应用。在这种情况下，整个表达式必须用括号括起"
"来，称为 *运算符块*。这里有两个例子："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr "如您所见，`(< 10)`和 `(10 <)`。第一个测试，它的参数为是否小于10，第二，参数是否大于10。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
msgid ""
"One exception where operator sections will not work is with the *minus* "
"operator `(-)`. Here is an example to demonstrate this:"
msgstr ""
"运算符部分不起作用的一个例外是使用 *减法* 运算符 `(-)`。下面是一个例子来证明"
"这一点："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
msgid ""
"This is just a higher-order function applying the number ten to its function "
"argument. This works very well in the following example:"
msgstr ""
"这只是一个将数字 10 应用于其函数参数的高阶函数。这在以下示例中非常有效："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (* 2)\n"
"20\n"
msgstr ""
"Tutorial.Functions1> applyToTen (* 2)\n"
"20\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
msgid "However, if we want to subtract five from ten, the following will fail:"
msgstr "但是，如果我们想从 10 中减去 5，以下将失败："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal instead "
"of an operator section. In this special case, we therefore have to use an "
"anonymous function instead:"
msgstr ""
"这里的问题是，Idris 将 `- 5` 视为整数字面量而不是运算符块。在这种特殊情况下，"
"我们因此必须使用匿名函数："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr "非运算符的中缀表示法"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
msgid ""
"In Idris, it is possible to use infix notation for regular binary functions, "
"by wrapping them in backticks.  It is even possible to define a precedence "
"(fixity) for these and use them in operator sections, just like regular "
"operators:"
msgstr ""
"在 Idris 中，可以对常规双参函数使用中缀表示法，方法是将它们包装在反引号中。甚"
"至可以为这些定义优先级（结合性）并在运算符块中使用它们，就像常规运算符一样："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr "*Prelude* 导出的运算符"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
msgid ""
"Here is a list of important operators exported by the *Prelude*.  Most of "
"these are *constrained*, that is they work only for types implementing a "
"certain *interface*. Don't worry about this right now. We will learn about "
"interfaces in due time, and the operators behave as they intuitively "
"should.  For instance, addition and multiplication work for all numeric "
"types, comparison operators work for almost all types in the *Prelude* with "
"the exception of functions."
msgstr ""
"以下是 *Prelude* 导出的重要运算符列表。其中大多数具有 *约束 *，也就是说它们仅"
"适用于实现了某个 *接口* 的类型。现在不要担心这个。我们将在适当的时候了解接"
"口，运算符会按照直觉行事。例如，加法和乘法适用于所有数字类型，比较运算符适用"
"于 *Prelude* 中的几乎所有类型，但函数除外。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(.)`: Function composition"
msgstr "`(.)`：函数组合"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(+)`: Addition"
msgstr "`(+)`：加法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(*)`: Multiplication"
msgstr "`(*)`：乘法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(-)`: Subtraction"
msgstr "`(-)`：减法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/)`: Division"
msgstr "`(/)`：除法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(==)` : True, if two values are equal"
msgstr "`(==)` ：判断两个值是否相等"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/=)` : True, if two values are not equal"
msgstr "`(/=)` ：判断两个值是否不相等"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators"
msgstr "`(<=)`、`(>=)`、`(<)` 和 `(>)` ：比较运算符"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`($)`: Function application"
msgstr "`($)`：函数应用"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
msgid ""
"The most special of the above is the last one. It has a priority of 0, so "
"all other operators bind more tightly.  In addition, function application "
"binds more tightly, so this can be used to reduce the number of parentheses "
"required. For instance, instead of writing `isTriple 3 4 (2 + 3 * 1)` we can "
"write `isTriple 3 4 $ 2 + 3 * 1`, which is exactly the same. Sometimes, this "
"helps readability, sometimes, it doesn't. The important thing to remember is "
"that `fun $ x y` is just the same as `fun (x y)`."
msgstr ""
"上面最特别的是最后一个。它的优先级为 0，所有其他运算符都比他绑定得更紧密。因"
"此可以使用它来减少所需的括号数量。例如，不写 `isTriple 3 4 (2 + 3 * 1)` 我们"
"可以写成 `isTriple 3 4 $ 2 + 3 * 1`，这完全一样。有时，这有助于提高可读性，虽"
"然有时并不会。要记住的重要一点是 `fun $ x y` 与 `fun (x y)` 相同。"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr "练习"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot operator and "
"dropping the second arguments (have a look at the implementation of "
"`squareTimes2` to get an idea where this should lead you). This highly "
"concise way of writing function implementations is sometimes called *point-"
"free style* and is often the preferred way of writing small utility "
"functions."
msgstr ""
"通过使用点运算符并删除第二个参数重新实现函数 `testSquare` 和 `twice`（查看 "
"`squareTimes2` 的实现应该可以让你更加了解）。这种编写函数实现的高度简洁的方式"
"有时被称为 *无值风格*，并且通常是编写小型实用函数的首选方式。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven` from "
"above and `not` (from the Idris *Prelude*). Use point-free style."
msgstr ""
"通过组合上面的函数 `isEven` 和 `not`（来自 Idris *Prelude*）来声明和实现函数 "
"`isOdd`。使用无值风格。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
msgid ""
"Declare and implement function `isSquareOf`, which checks whether its first "
"`Integer` argument is the square of the second argument."
msgstr ""
"声明并实现函数 `isSquareOf`，检查它的第一个 `Integer` 参数是否是第二个参数的"
"平方。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
msgid ""
"Declare and implement function `isSmall`, which checks whether its `Integer` "
"argument is less than or equal to 100. Use one of the comparison operators "
"`<=` or `>=` in your implementation."
msgstr ""
"声明并实现函数 `isSmall`，检查其 `Integer` 参数是否小于或等于 100。在你的实现"
"中使用比较运算符 `<=` 或 `>=` 之一。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
msgid ""
"Declare and implement function `absIsSmall`, which checks whether the "
"absolute value of its `Integer` argument is less than or equal to 100.  Use "
"functions `isSmall` and `abs` (from the Idris *Prelude*) in your "
"implementation, which should be in point-free style."
msgstr ""
"声明并实现函数 `absIsSmall`，检查其 `Integer` 参数的绝对值是否小于等于100。在"
"你的实现中使用函数 `isSmall` 和 `abs `（来自 Idris *Prelude*），最好是无值风"
"格的。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
msgid ""
"In this slightly extended exercise we are going to implement some utilities "
"for working with `Integer` predicates (functions from `Integer` to `Bool`). "
"Implement the following higher-order functions (use boolean operators `&&`, "
"`||`, and function `not` in your implementations):"
msgstr ""
"在这个稍微扩展的练习中，我们将实现一些实用程序来处理 `Integer` 谓词（从 "
"`Integer` 到 `Bool` 的函数）。实现以下高阶函数（在您的实现中使用布尔运算符 "
"`&&`、`||` 和函数 `not`）："

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr "   完成这个练习后，在 REPL 中试一试。在下面的例子中，我们通过用反引号包裹来使用双参函数 `and` 的中缀表示法的。这只是一种语法糖，使某些功能应用程序更具可读性：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
msgid ""
"As explained above, Idris allows us to define our own infix operators.  Even "
"better, Idris supports *overloading* of function names, that is, two "
"functions or operators can have the same name, but different types and "
"implementations.  Idris will make use of the types to distinguish between "
"equally named operators and functions."
msgstr ""
"如上所述，Idris 允许我们定义自己的中缀运算符。更好的是，Idris 支持函数名的 *"
"重载*，即两个函数或运算符可以有相同的名称，但类型和实现不同。 Idris 将使用类"
"型来区分同名的运算符和函数。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr "   这允许我们重新实现函数 `and`、`or` 和 `negate`，在练习 6 中，使用布尔代数中现有的运算符和函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr "   实现另外两个函数并在 REPL 上测试它们：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
msgid "What we learned in this chapter:"
msgstr "我们在本章中学到了什么："

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr "* Idris 中的函数可以接受任意数量的参数，由函数类型中的 `->` 分隔。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr "* 函数可以依次使用点运算符进行组合，这会产生高度简洁的代码。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr "* 可以通过传递更少的函数来偏应用函数，参数少于函数的预期。结果是一个新的函数，预期传入剩下的参数。这种技术被称为 *柯里化*。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr "* 函数可以作为参数传递给其他函数，允许我们轻松组合小型程序单元来创建更复杂的行为。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr "* 如果编写相应的顶层函数太繁琐，我们可以将匿名函数 (*lambdas*) 传递给高阶函数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr "* Idris 允许我们定义自己的中缀运算符。这些必须写在括号中，除非它们被声明为中缀表示法。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr "* 也可以部分应用中缀运算符。这些 *运算符块* 必须用括号括起来，并且用作运算符的第一个或第二个参数被确定。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr "* Idris 支持名称重载：函数可以具有相同的名称，但拥有不同的实现。Idris 将根据所涉及的类型决定使用哪个函数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
msgid ""
"Please note, that function and operator names in a module must be unique. In "
"order to define two functions with the same name, they have to be declared "
"in distinct modules. If Idris is not able to decide, which of the two "
"functions to use, we can help name resolution by prefixing a function with "
"(a part of) its *namespace*:"
msgstr ""
"请注意，模块中的函数和运算符名称必须是唯一的。为了定义两个具有相同名称的函"
"数，它们必须在不同的模块中声明。如果 Idris 无法决定使用这两个函数中的哪一个，"
"我们可以通过在函数前面加上其 *命名空间* 的（部分）前缀来帮助名称解析："

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
msgid ""
"In the [next section](DataTypes.md), we will learn how to define our own "
"data types and how to construct and deconstruct values of these new types. "
"We will also learn about generic types and functions."
msgstr ""
"在 [下一节](DataTypes.md) 中，我们将学习如何定义我们自己的数据类型以及如何构"
"造和解构这些新类型的值。我们还将学习泛型类型和函数。"
